<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cocochimpBlog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-01-18T03:27:23.266Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>cocochimp</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>23种设计模式</title>
    <link href="http://example.com/2024/01/18/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2024/01/18/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-01-18T03:00:54.577Z</published>
    <updated>2024-01-18T03:27:23.266Z</updated>
    
    <content type="html"><![CDATA[<ul><li>面试题：<a href="https://blog.csdn.net/qq_30999361/article/details/124637874">设计模式面试题（14道含答案）</a></li><li>目标：掌握常见的设计模式，包括单例模式、工厂模式、装饰器模式、代理模式等，以提高代码的可维护性和可扩展性。</li><li>【重点&#x2F;常看】<a href="https://zhuanlan.zhihu.com/p/128145128">快速记忆23种设计模式</a></li><li>深造地址：<a href="https://blog.csdn.net/su2231595742/article/details/121708085">23种常见设计模式详解</a></li><li>拓展：<a href="https://zhuanlan.zhihu.com/p/93908252">Java程序员必备常用的八种设计模式讲解</a></li></ul><h1 id="1、OOP七大原则"><a href="#1、OOP七大原则" class="headerlink" title="1、OOP七大原则"></a>1、OOP七大原则</h1><ol><li><strong>开闭原则【*】：对拓展开放，对修改关闭；</strong>对修改关闭是说，我们辛辛苦苦加班写出来的代码，该实现的功能和该修复的 bug 都完成了，别人可不能说改就改；对扩展开放就比较好理解了，也就是说在我们写好的代码基础上，很容易实现扩展。</li><li><strong>里氏替换原则</strong>：继承必须确保超类所拥有的性质在子类中仍然成立。</li><li><strong>依赖倒置原则</strong>：<strong>面向接口编程，而不是面向实现</strong>。这个很重要，也是优雅的、可扩展的代码的第一步，这就不需要多说了吧。</li><li><strong>单一职责原则</strong>：每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来。【将对象解耦，提高内聚性】</li><li><strong>接口隔离原则</strong>：要为各个类建立它们需要的专用接口。</li><li><strong>迪米特法则</strong>：只与你的直接朋友交谈，不跟“陌生人”说话。</li><li><strong>合成复用原则</strong>：尽量先试用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</li></ol><h1 id="2、创建型模式"><a href="#2、创建型模式" class="headerlink" title="2、创建型模式"></a>2、创建型模式</h1><p>创建型模式的作用就是创建对象，说到创建一个对象，最熟悉的就是 new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要给客户端提供更加友好的创建对象的方式，尤其是那种我们定义了类，但是需要提供给其他开发者用的时候。</p><ol><li>简单工厂模式最简单； </li><li>工厂模式在简单工厂模式的基础上增加了选择工厂的维度，需要第一步选择合适的工厂； </li><li>抽象工厂模式有产品族的概念，如果各个产品是存在兼容性问题的，就要用抽象工厂模式。 </li><li>单例模式就不说了，为了保证全局使用的是同一对象，一方面是安全性考虑，一方面是为了节省资源； </li><li>建造者模式专门对付属性很多的那种类，为了让代码更优美； </li><li>原型模式用得最少，了解和 Object 类中的 clone() 方法相关的知识即可。</li></ol><h2 id="2-1-单例模式【-】"><a href="#2-1-单例模式【-】" class="headerlink" title="2.1 单例模式【**】"></a>2.1 单例模式【**】</h2><blockquote><p>一个班级只有一个班主任</p></blockquote><ol><li><strong>【概念】：</strong>确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</li></ol><ul><li>如何确保一个类只有一个实例?<ul><li><strong>构造方法</strong>不能 public, 不能被外界实例化使用：private修饰</li><li>这个实例是当前类的<strong>类成员变量</strong>（类静态变量），用static修饰</li></ul></li><li>如何向整个系统提供这个实例？<ul><li>使用方法向外界提供这个实例</li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688796888722-92a305f7-4d7f-4699-96c2-bda876ddfbb0.png#averageHue=%23efefef&clientId=uaef691d9-ff29-4&from=drop&id=u7a87046c&originHeight=328&originWidth=960&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32470&status=done&style=none&taskId=uaeddf1c9-0c1c-43fd-ad9b-0fd62f0f3fa&title=" alt="2020040715570631.png"></p><ol start="2"><li><strong>【使用场景】：</strong>工具类模式<ul><li>序列号生成器、Web页面计数器等</li><li>访问IO、数据库资源，使用单例模式减少资源的消耗</li></ul></li><li><strong>【优缺点】：</strong></li></ol><ul><li><strong>优点：</strong><ul><li>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 </li><li>2、避免对资源的多重占用（比如写文件操作）。</li></ul></li><li><strong>缺点：</strong><ul><li>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</li></ul></li></ul><ol start="4"><li><strong>【特点】：</strong><blockquote><p>根据对象实例化时机不同可以分为：<strong>饿汉式</strong>和<strong>懒汉式</strong></p></blockquote></li></ol><ul><li><p><strong>饿汉式：</strong></p><ul><li><strong>对象实例化后会一直被使用</strong>，且创建实例不会造成大量资源浪费。</li><li>代码实现简单，<strong>不需要处理多线程同步问题</strong>。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">//类加载就进行实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>懒汉式：</strong>在第一次使用时实例化</p><ul><li><strong>实例化这个对象比较耗费资源</strong>，例如数据库连接池对象，需要在需要时才创建实例。</li><li>不需要在程序刚启动的时候就创建实例，仅<strong>需要在需要时才创建实例</strong>。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">//new对象的时候：分配内存——&gt;初始化对象——&gt;指向刚分配的地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一次使用getInstance()成员方法的时候进行实例化</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//双层检查锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>嵌套类最经典，以后大家就用它吧：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton3</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton3</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，很多人都会把这个<strong>嵌套类</strong>说成是<strong>静态内部类</strong>，严格地说，内部类和嵌套类是不一样的，它们能访问的外部类权限也是不一样的。<br>最后，我们说一下枚举，枚举很特殊，它在类加载的时候会初始化里面的所有的实例，而且 JVM 保证了它们不会再被实例化，所以它天生就是单例的。</p></li></ul><p>双重检查加锁(DCL)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数私有，禁止外部实例化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:::tips<br>现在我们分析一下为什么要在变量singleton之间加上volatile关键字。要理解这个问题，先要了解对象的构造过程，实例化一个对象其实可以分为三个步骤：</p><ul><li>分配内存空间</li><li>初始化对象</li><li>将内存空间的地址赋值给对应的引用</li></ul><p>但是由于操作系统可以对指令进行重排序，所以上面的过程也可能会变成如下过程：</p><ul><li>分配内存空间。</li><li>将内存空间的地址赋值给对应的引用。</li><li>初始化对象</li></ul><p>如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量。<br>:::</p><h2 id="2-2-简单工厂模式-x"><a href="#2-2-简单工厂模式-x" class="headerlink" title="2.2 简单工厂模式(x)"></a>2.2 简单工厂模式(x)</h2><blockquote><p>静态工厂模式【类创建型模式—&gt;工厂类】</p></blockquote><ul><li><strong>目的：实现创建者和调用者的分离。</strong></li><li><strong>核心性质：实例化对象不使用new，用工厂方法代替</strong></li></ul><ol><li><strong>【概念】：</strong>在简单工厂模式中，可以根据<strong>参数的不同返回不同类的实例</strong>。简单工厂模式专门定义一个类来负责创建其他类的实例被创建的实例通常都具有共同的父类。</li></ol><ul><li>【核心思想】有一个专门的类**(工厂类)**来负责创建实例的过程。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688696245855-88a2b5d1-f5ff-42ae-a7b3-daa5ca6bdcaf.png#averageHue=%23efefec&clientId=uee24b681-3279-4&from=drop&height=389&id=ud4fcbf4d&originHeight=506&originWidth=553&originalType=binary&ratio=1&rotation=0&showTitle=false&size=63449&status=done&style=none&taskId=ubb8d83af-ba69-4062-9e10-e43bb7b3046&title=&width=425" alt="20200707204516186.png"></p><ul><li>Factory(工厂):核心部分，负责实现创建所有产品的内部逻辑，工厂类可以被外界直接调用，创建所需对象工厂类是整个模式的关键；</li><li>Product(抽象类产品)：工厂类所创建的所有对象的父类，封装了产品对象的公共方法，所有的具体产品为其子类对象；</li><li>ProductA、ProductB…(具体产品)：简单工厂模式的创建目标，所有被创建的对象都是某个具体类的实例。它要实现抽象产品中声明的抽象方法</li></ul><ol start="2"><li><strong>【使用场景】：</strong>JDK工具类DataFormat、IO等需要根据不同参数返回不同类的实例对象的类方法<ul><li>工厂类负责创建的对象比较少；</li><li>客户只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心；</li></ul></li><li><strong>【优缺点】：</strong></li></ol><ul><li><strong>优点：</strong><ul><li>用户不需要关注创建对象的细节（你只管调用这个方法就行了）</li></ul></li><li><strong>缺点：</strong><ul><li>创建对象的工厂类在需要变更时会变得很麻烦（专业一点就是简单工厂模式不够灵活）【<strong>违反开闭原则</strong>，不能做到灵活扩展<strong>】</strong></li></ul></li></ul><ol start="4"><li><strong>【特点】：</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Food <span class="title function_">makeFood</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;noodle&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">Food</span> <span class="variable">noodle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LanZhouNoodle</span>();</span><br><span class="line">            noodle.addSpicy(<span class="string">&quot;more&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> noodle;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;chicken&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">Food</span> <span class="variable">chicken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HuangMenChicken</span>();</span><br><span class="line">            chicken.addCondiment(<span class="string">&quot;potato&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> chicken;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><em>其中，LanZhouNoodle 和 HuangMenChicken 都继承自 Food。</em><br>简单地说，简单工厂模式通常就是这样，一个工厂类 xxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。<br>我们强调<strong>职责单一</strong>原则，一个类只提供一种功能，FoodFactory 的功能就是只要负责生产各种 Food。</li></ol><h2 id="2-3-工厂模式【-】"><a href="#2-3-工厂模式【-】" class="headerlink" title="2.3 工厂模式【*】"></a>2.3 工厂模式【*】</h2><blockquote><p>您需要一辆汽车，可以直接从汽车工厂里面提货（不在意产品族）</p></blockquote><ol><li><strong>【概念】：</strong></li></ol><p>定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688697120002-ee251c83-6697-432b-86bc-1e634534cf74.png#averageHue=%23f4f4f4&clientId=uee24b681-3279-4&from=drop&id=uaa523b71&originHeight=340&originWidth=750&originalType=binary&ratio=1&rotation=0&showTitle=false&size=65610&status=done&style=none&taskId=ufa0648d2-73e9-4e9e-a976-3e158fdde50&title=" alt="20200713212158676.png"></p><ul><li>AbstractFactory抽象工厂类：工厂方法模式的核心类，提供创建具体产品的接口，由具体工厂类实现；</li><li>Factory具体工厂类：继承于抽象工厂，实现创建对应具体产品对象的方式；</li><li>Product抽象产品类：是具体产品类的继承的父类或实现的接口。</li><li>ConcreteProductX具体产品类：工厂类所创建的对象就是此具体产品实例。</li></ul><ol start="2"><li><strong>【使用场景】：</strong>JDK的Collection集合类</li></ol><ul><li>客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688697573963-65c59680-bb9a-4438-9d9b-fa988dd698fc.png#averageHue=%23353432&clientId=uee24b681-3279-4&from=paste&height=427&id=u0cd4183d&originHeight=427&originWidth=725&originalType=binary&ratio=1&rotation=0&showTitle=false&size=80171&status=done&style=none&taskId=u9c08d40b-d113-48c9-af12-f0c8cd875ef&title=&width=725" alt="image.png"></p><ol start="3"><li><strong>【优缺点】：</strong></li></ol><ul><li><strong>优点：</strong><ul><li><strong>开放封闭原则：</strong> 新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可</li><li><strong>单一职责原则</strong> ：每个具体工厂类只负责创建对应的产品，简单工厂中的工厂类存在复杂的switch逻辑判断</li><li><strong>屏蔽产品类：</strong> 产品类的实现如何变化，调用者都不需要关心，它只需要关心产品的接口，只要接口保持不变，系统中的上层模块就不要发生变化，因为产品类的实例化工作是由工厂类负责，一个产品对象具体由哪一个产品生成是由工厂类决定的。</li></ul></li><li><strong>缺点：</strong><ul><li><strong>【开销增大，系统复杂度增加】</strong>如果产品种类过多，需要生产大量的工厂类。</li><li>一个具体工厂只能创建一种具体产品</li></ul></li></ul><ol start="4"><li><strong>【特点】：</strong></li></ol><ul><li><p>工厂模式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line">    Food <span class="title function_">makeFood</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChineseFoodFactory</span> <span class="keyword">implements</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeFood</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChineseFoodA</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChineseFoodB</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanFoodFactory</span> <span class="keyword">implements</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeFood</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanFoodA</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanFoodB</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端调用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">APP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 先选择一个具体的工厂</span></span><br><span class="line">        <span class="type">FoodFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChineseFoodFactory</span>();</span><br><span class="line">        <span class="comment">// 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象</span></span><br><span class="line">        <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> factory.makeFood(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>核心在于，我们需要在第一步选好我们需要的工厂</strong>。比如，我们有 LogFactory 接口，实现类有 FileLogFactory 和 KafkaLogFactory，分别对应将日志写入文件和写入 Kafka 中，显然，我们客户端第一步就需要决定到底要实例化 FileLogFactory 还是 KafkaLogFactory，这将决定之后的所有的操作。<br><img src="https://www.javadoop.com/blogimages/design-pattern/factory-1.png#id=fZfIL&originHeight=1154&originWidth=1542&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p></li></ul><h2 id="2-4-抽象工厂模式"><a href="#2-4-抽象工厂模式" class="headerlink" title="2.4 抽象工厂模式"></a>2.4 抽象工厂模式</h2><blockquote><p>您需要一辆汽车，可以直接从汽车工厂里面提货（在意产品族）</p></blockquote><ol><li><strong>【概念】：</strong>工厂方法模式的缺点是如果产品种类过多，需要生产大量的工厂类。当涉及到<strong>产品族</strong>的时候，就需要引入抽象工厂模式了。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688698224105-49c88494-d137-4fde-be5e-0250ec187e66.png#averageHue=%23f6f6f6&clientId=uee24b681-3279-4&from=paste&height=834&id=C6GLt&originHeight=834&originWidth=1415&originalType=binary&ratio=1&rotation=0&showTitle=false&size=370496&status=done&style=none&taskId=u2b03936d-2878-467a-84c0-fc8402d8043&title=&width=1415" alt="image.png"></p><ul><li>AbstractFactory抽象工厂类：工厂方法模式的核心类，提供创建具体产品的接口，由具体工厂类实现；</li><li>Factory具体工厂类：继承于抽象工厂，实现创建对应具体产品对象的方式；</li><li>Product抽象产品类：是具体产品类的继承的父类或实现的接口。</li><li>ConcreteProductX具体产品类：工厂类所创建的对象就是此具体产品实例。<blockquote><p>产品族：</p></blockquote></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688698445699-b834fd4f-2481-460d-ae41-9a877220266b.png#averageHue=%23fefefc&clientId=uee24b681-3279-4&height=347&id=psiIl&originHeight=515&originWidth=795&originalType=binary&ratio=1&rotation=0&showTitle=false&size=122373&status=done&style=none&taskId=u04583773-5dd2-40b4-be42-a9de07f4969&title=&width=535" alt="image.png"></p><ul><li><strong>工厂方法模式解决的范畴</strong>是产品等级（大众汽车发动机，奔驰汽车发动机等）；<strong>抽象工厂模式解决的范畴</strong>是产品族等级（大众汽车、奔驰汽车等）；</li></ul><ol start="2"><li><strong>【使用场景】：</strong></li></ol><ul><li>QQ 换皮肤，一整套一起换；</li><li>生成不同操作系统的程序。</li></ul><ol start="3"><li><strong>【优缺点】：</strong></li></ol><ul><li><strong>优点：</strong><ul><li><strong>【确保单一产品族】</strong>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</li><li><strong>【具体的创建实例过程与客户端分离】</strong>客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中</li></ul></li><li><strong>缺点：</strong><ul><li>不容易扩展新的产品等级，比如我要加一个轮胎什么的。那么就需要修改抽象工厂，这样就会导致修改所有的工厂实现类。<strong>【违背开闭原则，跟简单工厂模式相似】</strong></li></ul></li></ul><ol start="4"><li><strong>【特点】：</strong></li></ol><p>当涉及到这种产品族的问题的时候，就需要抽象工厂模式来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题。<br><img src="https://www.javadoop.com/blogimages/design-pattern/abstract-factory-3.png#id=BULkY&originHeight=868&originWidth=1522&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>这个时候，对于客户端来说，不再需要单独挑选 CPU厂商、主板厂商、硬盘厂商等，直接选择一家品牌工厂，品牌工厂会负责生产所有的东西，而且能保证肯定是兼容可用的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 第一步就要选定一个“大厂”</span></span><br><span class="line">    <span class="type">ComputerFactory</span> <span class="variable">cf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AmdFactory</span>();</span><br><span class="line">    <span class="comment">// 从这个大厂造 CPU</span></span><br><span class="line">    <span class="type">CPU</span> <span class="variable">cpu</span> <span class="operator">=</span> cf.makeCPU();</span><br><span class="line">    <span class="comment">// 从这个大厂造主板</span></span><br><span class="line">    <span class="type">MainBoard</span> <span class="variable">board</span> <span class="operator">=</span> cf.makeMainBoard();</span><br><span class="line">  <span class="comment">// 从这个大厂造硬盘</span></span><br><span class="line">  <span class="type">HardDisk</span> <span class="variable">hardDisk</span> <span class="operator">=</span> cf.makeHardDisk();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 将同一个厂子出来的 CPU、主板、硬盘组装在一起</span></span><br><span class="line">    <span class="type">Computer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(cpu, board, hardDisk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了<strong>对修改关闭，对扩展开放</strong>这个设计原则。</p><h2 id="2-5-建造者模式"><a href="#2-5-建造者模式" class="headerlink" title="2.5 建造者模式"></a>2.5 建造者模式</h2><blockquote><p>建房子</p></blockquote><ol><li><strong>【概念】：</strong>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688800648381-bd330041-3b59-4bfc-8850-6912fa8b86fe.png#averageHue=%233c3c3c&clientId=uaef691d9-ff29-4&from=paste&height=497&id=ub7af5856&originHeight=497&originWidth=879&originalType=binary&ratio=1&rotation=0&showTitle=false&size=115732&status=done&style=none&taskId=u39cf1373-3d37-4881-8e1e-cfc29d04830&title=&width=879" alt="image.png"></p><ul><li><strong>类图</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/35382725/1688800578366-cf159401-2e93-46d2-8a2f-eec10a4820f7.jpeg#averageHue=%23f1f1ec&clientId=uaef691d9-ff29-4&from=drop&id=u6e9ed115&originHeight=324&originWidth=474&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17202&status=done&style=none&taskId=u625d0c96-e65c-4e66-8d0a-0ad1cd5d6ca&title=" alt="OIP-C.jpg"></p><ul><li>Product: 最终要生成的对象，例如 Computer实例。</li><li>Builder： 构建者的抽象基类（有时会使用接口代替）。其定义了构建Product的抽象步骤，其实体类需要实现这些步骤。其会包含一个用来返回最终产品的方法Product getProduct()。</li><li>ConcreteBuilder: Builder的实现类。</li><li>Director: 决定如何构建最终产品的算法. 其会包含一个负责组装的方法void Construct(Builder builder)， 在这个方法中通过调用builder的方法，就可以设置builder，等设置完成后，就可以通过builder的 getProduct() 方法获得最终的产品。</li></ul><ol start="2"><li><strong>【使用场景】：</strong></li></ol><ul><li>JDK：StringBuilder</li></ul><ol start="3"><li><strong>【优缺点】：</strong></li></ol><ul><li><strong>优点：</strong><ul><li>建造者独立，易扩展；</li><li>便于控制细节风险。</li></ul></li><li><strong>缺点：</strong><ul><li>产品必须有共同点，范围有限制；</li><li>如内部变化复杂，会有很多的建造类。</li></ul></li></ul><ol start="4"><li><strong>【特点】：</strong></li></ol><p>经常碰见的 XxxBuilder 的类，通常都是建造者模式的产物。建造者模式其实有很多的变种，但是对于客户端来说，我们的使用通常都是一个模式的：<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230212181536775.png#id=JUdSp&originHeight=205&originWidth=460&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoodBuilder</span>().a().b().c().build();</span><br><span class="line"><span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> Food.builder().a().b().c().build();</span><br></pre></td></tr></table></figure><p>套路就是先 new 一个 Builder，然后可以链式地调用一堆方法，最后再调用一次 build() 方法，我们需要的对象就有了。<br>来一个中规中矩的建造者模式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// 下面是“一堆”的属性</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法私有化，不然客户端就会直接调用构造方法了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">User</span><span class="params">(String name, String password, String nickName, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">        <span class="built_in">this</span>.nickName = nickName;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 静态方法，用于生成一个 Builder，这个不一定要有，不过写这个方法是一个很好的习惯，</span></span><br><span class="line">    <span class="comment">// 有些代码要求别人写 new User.UserBuilder().a()...build() 看上去就没那么好</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserBuilder <span class="title function_">builder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserBuilder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserBuilder</span> &#123;</span><br><span class="line">        <span class="comment">// 下面是和 User 一模一样的一堆属性</span></span><br><span class="line">        <span class="keyword">private</span> String  name;</span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line">        <span class="keyword">private</span> String nickName;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">UserBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链式调用设置各个属性值，返回 this，即 UserBuilder</span></span><br><span class="line">        <span class="keyword">public</span> UserBuilder <span class="title function_">name</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> UserBuilder <span class="title function_">password</span><span class="params">(String password)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.password = password;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> UserBuilder <span class="title function_">nickName</span><span class="params">(String nickName)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.nickName = nickName;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> UserBuilder <span class="title function_">age</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// build() 方法负责将 UserBuilder 中设置好的属性“复制”到 User 中。</span></span><br><span class="line">        <span class="comment">// 当然，可以在 “复制” 之前做点检验</span></span><br><span class="line">        <span class="keyword">public</span> User <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (name == <span class="literal">null</span> || password == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户名和密码必填&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (age &lt;= <span class="number">0</span> || age &gt;= <span class="number">150</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;年龄不合法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 还可以做赋予”默认值“的功能</span></span><br><span class="line">          <span class="keyword">if</span> (nickName == <span class="literal">null</span>) &#123;</span><br><span class="line">                nickName = name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(name, password, nickName, age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心是：先把所有的属性都设置给 Builder，然后 build() 方法的时候，将这些属性<strong>复制</strong>给实际产生的对象。<br>看看客户端的调用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">APP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">d</span> <span class="operator">=</span> User.builder()</span><br><span class="line">                .name(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">                .password(<span class="string">&quot;pass12345&quot;</span>)</span><br><span class="line">                .age(<span class="number">25</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说实话，建造者模式的<strong>链式</strong>写法很吸引人，但是，多写了很多“无用”的 builder 的代码，感觉这个模式没什么用。不过，当属性很多，而且有些必填，有些选填的时候，这个模式会使代码清晰很多。我们可以在 <strong>Builder 的构造方法</strong>中强制让调用者提供必填字段，还有，在 build() 方法中校验各个参数比在 User 的构造方法中校验，代码要优雅一些。</p><ul><li>题外话：强烈建议读者使用 lombok，用了 lombok 以后，上面的一大堆代码会变成如下这样:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String  name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>怎么样，省下来的时间是不是又可以干点别的了。</p></blockquote></li></ul><p>当然，如果你只是想要链式写法，不想要建造者模式，有个很简单的办法，User 的 getter 方法不变，所有的 setter 方法都让其 <strong>return this</strong> 就可以了，然后就可以像下面这样调用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>().setName(<span class="string">&quot;&quot;</span>).setPassword(<span class="string">&quot;&quot;</span>).setAge(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><ul><li>很多人是这么用的，但是笔者觉得其实这种写法非常地不优雅，不是很推荐使用。</li></ul><h2 id="2-6-原型模式【-】"><a href="#2-6-原型模式【-】" class="headerlink" title="2.6 原型模式【*】"></a>2.6 原型模式【*】</h2><blockquote><p>细胞分裂</p></blockquote><ol><li><strong>【概念】：</strong>这种模式是实现了一个原型接口，该接口用于创建当前对象的<strong>“克隆”</strong>。当直接创建对象的代价比较大时，则采用这种模式。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688802266808-3555ffa2-798a-49f6-a01f-bd9b2290c358.png#averageHue=%232c2c2c&clientId=uaef691d9-ff29-4&from=paste&height=373&id=u1a576a19&originHeight=373&originWidth=767&originalType=binary&ratio=1&rotation=0&showTitle=false&size=175409&status=done&style=none&taskId=u2f36db2f-f9a3-48fc-987e-2ba4815ae58&title=&width=767" alt="image.png"></p><ul><li><strong>类图</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688802090549-55e725e8-e8b9-4c71-884c-986bc0ce4ed1.png#averageHue=%23fdfdfb&clientId=uaef691d9-ff29-4&from=paste&height=450&id=u559d220d&originHeight=450&originWidth=1167&originalType=binary&ratio=1&rotation=0&showTitle=false&size=194926&status=done&style=none&taskId=ucddb773e-c677-48e9-b4ca-647a023737d&title=&width=1167" alt="image.png"></p><ul><li>Client类：发出指令的客户端</li><li>Prototype类：是一个接口，描述了一个对象如何克隆自身，比如必须拥有 clone() 方法</li><li>ConcretePrototype类：就是克隆具体的实现，不同对象有不同的实现来拷贝自身</li></ul><ol start="2"><li><strong>【使用场景】：</strong></li></ol><ul><li>JDK：Object 类中有一个 clone() 方法，它用于生成一个新的对象，当然，如果我们要调用这个方法，java 要求我们的类必须先<strong>实现 Cloneable 接口</strong>，此接口没有定义任何方法，但是不这么做的话，在 clone() 的时候，会抛出CloneNotSupportedException 异常。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><strong>【优缺点】：</strong></li></ol><ul><li><strong>优点：</strong><ul><li>【减少对象创建的成本】使用原型模式可以通过复制现有对象来创建新对象，而无需创建新对象的成本。因为它避免了重新初始化和设置对象的属性。</li><li>【简化对象的创建过程】原型模式可以避免复杂对象的创建过程，尤其是当创建对象需要进行一系列复杂的步骤时。这意味着你可以在实际需要时轻松地创建和配置对象，而不必在程序的许多地方执行大量的初始化和配置代码。</li></ul></li><li><strong>缺点：</strong><ul><li>【复制对象可能会带来副作用】例如如果原型对象的属性是可变的，那么它们的值可能会在对象被克隆时改变。</li><li>【复制对象可能会导致深度克隆问题】如果一个对象具有多层嵌套结构，复制它可能会变得很困难，因为你需要确保复制所有嵌套的对象及其属性。这可能会导致深度克隆问题。</li></ul></li></ul><ol start="4"><li><strong>【特点】：</strong></li></ol><p><strong>原型模式有两种实现方式：浅克隆和深克隆。</strong><br>【浅克隆】java 的克隆是浅克隆，碰到对象引用的时候，克隆出来的对象和原对象中的引用将指向同一个对象。</p><ul><li>浅克隆</li></ul><p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230212184626855.png#id=ZeRhR&originHeight=252&originWidth=523&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>【深克隆】通常实现深克隆的方法是将对象进行序列化，然后再进行反序列化。</p><ul><li>深克隆</li></ul><p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230212184640045.png#id=KijBV&originHeight=266&originWidth=526&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>原型模式了解到这里我觉得就够了，各种变着法子说这种代码或那种代码是原型模式，没什么意义。</p><h1 id="3、结构型模式"><a href="#3、结构型模式" class="headerlink" title="3、结构型模式"></a>3、结构型模式</h1><p>作用：旨在通过改变代码结构来达到<strong>解耦</strong>的目的，使得我们的代码容易维护和扩展。</p><ol><li>代理模式是做方法增强的</li><li>适配器模式是把鸡包装成鸭这种用来适配接口的</li><li>桥梁模式做到了很好的解耦</li><li>装饰模式从名字上就看得出来，适合于装饰类或者说是增强类的场景</li><li>门面模式的优点是客户端不需要关心实例化过程，只要调用需要的方法即可</li><li>组合模式用于描述具有层次结构的数据</li><li>享元模式是为了在特定的场景中缓存已经创建的对象，用于提高性能。</li></ol><h2 id="3-1-代理模式【-】"><a href="#3-1-代理模式【-】" class="headerlink" title="3.1 代理模式【*】"></a>3.1 代理模式【*】</h2><blockquote><p>房东中介租房</p></blockquote><ol><li><strong>【概念】：</strong>为其他对象提供一种代理以控制对这个对象的访问。</li></ol><p>对客户端隐藏真实实现，由代理来负责客户端的所有请求。当然，代理只是个代理，它不会完成实际的业务逻辑，而是一层皮而已，但是对于客户端来说，它必须表现得就是客户端需要的真实实现。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688795893193-782b9b05-5fb4-4d6e-b38d-beb5d1bab0dd.png#averageHue=%23f3f3f3&clientId=uaef691d9-ff29-4&from=drop&id=u7e68262d&originHeight=242&originWidth=902&originalType=binary&ratio=1&rotation=0&showTitle=false&size=55852&status=done&style=none&taskId=u0a9559de-0ca8-41d5-a6bd-45b660d6d5e&title=" alt="20200712210951913.png"></p><ul><li>类图</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688795568343-e109224c-8557-469e-99a2-1e2889d779f1.png#averageHue=%23f8f6f4&clientId=uaef691d9-ff29-4&from=paste&height=596&id=u74811513&originHeight=596&originWidth=915&originalType=binary&ratio=1&rotation=0&showTitle=false&size=186036&status=done&style=none&taskId=u2b440129-77a8-4899-b534-52fdf562e8a&title=&width=915" alt="image.png"></p><ul><li>Client（客户方）</li><li>Proxy（代理角色类）</li><li>RealSubject（真实角色类）</li><li>Subject（抽象角色类）</li></ul><ol start="2"><li><strong>【使用场景】：</strong></li></ol><ul><li>Spring 中实现动态代理：如 UserService 接口和 UserServiceImpl 实现</li><li>采用 JDK 的动态代理：java.lang.reflect.Proxy 类；</li><li>远程代理</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688796111305-44aadb28-3e21-41a4-b170-6e29d4f16dd0.png#averageHue=%23ebded6&clientId=uaef691d9-ff29-4&from=drop&id=u067a41af&originHeight=205&originWidth=553&originalType=binary&ratio=1&rotation=0&showTitle=false&size=96375&status=done&style=none&taskId=u7d15f37c-6555-4ab6-ae1d-f6e48603f44&title=" alt="20200712212908111.png"></p><ul><li>虚拟代理：根据需要创建开销很大的对象，通过它来存放实例化需要很长时间的真实对象，使其只有在真正需要时才被创建。</li><li>防火墙（Firewall）代理。</li></ul><ol start="3"><li><strong>【优缺点】：</strong></li></ol><ul><li><strong>优点：</strong><ul><li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li><li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li><li>代理对象可以扩展目标对象的功能；</li></ul></li><li><strong>缺点：</strong><ul><li>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；</li><li>增加了系统的复杂度；</li></ul></li></ul><ol start="4"><li><strong>【特点】：</strong></li></ol><p>理解<strong>代理</strong>这个词，这个模式其实就简单了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FoodService</span> &#123;</span><br><span class="line">    Food <span class="title function_">makeChicken</span><span class="params">()</span>;</span><br><span class="line">    Food <span class="title function_">makeNoodle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FoodServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">FoodService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeChicken</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">Food</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chicken</span>()</span><br><span class="line">        f.setChicken(<span class="string">&quot;1kg&quot;</span>);</span><br><span class="line">      f.setSpicy(<span class="string">&quot;1g&quot;</span>);</span><br><span class="line">      f.setSalt(<span class="string">&quot;3g&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeNoodle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Food</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Noodle</span>();</span><br><span class="line">        f.setNoodle(<span class="string">&quot;500g&quot;</span>);</span><br><span class="line">        f.setSalt(<span class="string">&quot;5g&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理要表现得“就像是”真实实现类，所以需要实现 FoodService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FoodServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">FoodService</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 内部一定要有一个真实的实现类，当然也可以通过构造方法注入</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">FoodService</span> <span class="variable">foodService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoodServiceImpl</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeChicken</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我们马上要开始制作鸡肉了&quot;</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 如果我们定义这句为核心代码的话，那么，核心代码是真实实现类做的，</span></span><br><span class="line">        <span class="comment">// 代理只是在核心代码前后做些“无足轻重”的事情</span></span><br><span class="line">        <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> foodService.makeChicken();</span><br><span class="line">      </span><br><span class="line">        System.out.println(<span class="string">&quot;鸡肉制作完成啦，加点胡椒粉&quot;</span>); <span class="comment">// 增强</span></span><br><span class="line">      food.addCondiment(<span class="string">&quot;pepper&quot;</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> food;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeNoodle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备制作拉面~&quot;</span>);</span><br><span class="line">        <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> foodService.makeNoodle();</span><br><span class="line">        System.out.println(<span class="string">&quot;制作完成啦&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> food;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用，注意，我们要用代理来实例化接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里用代理类来实例化</span></span><br><span class="line"><span class="type">FoodService</span> <span class="variable">foodService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoodServiceProxy</span>();</span><br><span class="line">foodService.makeChicken();</span><br></pre></td></tr></table></figure><p><img src="https://www.javadoop.com/blogimages/design-pattern/proxy-1.png#id=XQpQe&originHeight=778&originWidth=1540&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>我们发现没有，代理模式说白了就是做 <strong>“方法包装”</strong> 或做 <strong>“方法增强”</strong>。在面向切面编程中，其实就是动态代理的过程。比如 Spring 中，我们自己不定义代理类，但是 Spring 会帮我们动态来定义代理，然后把我们定义在 @Before、@After、@Around 中的代码逻辑动态添加到代理中。<br>说到动态代理，又可以展开说，Spring 中实现动态代理有两种，一种是如果我们的类定义了接口，如 UserService 接口和 UserServiceImpl 实现，那么采用 JDK 的动态代理，感兴趣的读者可以去看看 java.lang.reflect.Proxy 类的源码；另一种是我们自己没有定义接口的，Spring 会采用 CGLIB 进行动态代理，它是一个 jar 包，性能还不错。</p><h2 id="3-2-适配器模式【-】"><a href="#3-2-适配器模式【-】" class="headerlink" title="3.2 适配器模式【*】"></a>3.2 适配器模式【*】</h2><blockquote><p>适配器转换头</p></blockquote><ul><li>跟“装饰器模式”的区别，装饰器模式要修改原先的接口，对功能进行扩展；适配器模式是原先接口没问题，但是存在“不兼容问题”，不需要修改原先的接口。</li></ul><ol><li><strong>【概念】：</strong>将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688701067620-14fa076e-293d-4cc1-9ee7-a0c77993c8e1.png#averageHue=%232e2e2e&clientId=uaef691d9-ff29-4&from=paste&height=694&id=u2ce79f64&originHeight=694&originWidth=1339&originalType=binary&ratio=1&rotation=0&showTitle=false&size=235036&status=done&style=none&taskId=ufbf3fb34-c9b2-4b38-8fa2-c49ff09f4b2&title=&width=1339" alt="image.png"></p><ul><li>Target：是一个接口，它是我们客户端使用的目标接口；</li><li>Adaptee：我们想要使用的接口与Target不兼容的类，它可以是一个接口，也可以是一个类；</li><li>Adapter适配器类：此模式的核心。它需要实现目标接口Target，而且必须要引用Adaptee，因为我们要在此类中包装Adaptee的功能；</li></ul><ol start="2"><li><strong>【使用场景】：</strong></li></ol><ul><li>JAVA中的JDBC数据库连接池</li><li>在 LINUX 上运行 WINDOWS 程序</li></ul><ol start="3"><li><strong>【优缺点】：</strong></li></ol><ul><li><strong>优点：</strong><ul><li>【增强程序的可扩展性】可以随意扩展程序的功能，但却不需要修改接口</li><li>【增加类的透明性和复用性】由于适配器模式将目标类和被适配类解耦，使得这些类可以独立地进行变化和复用。</li></ul></li><li><strong>缺点：</strong><ul><li>【增加系统的复杂性】由于适配器模式需要增加一个适配器类来进行接口转换，因此系统的结构变得更加复杂。</li><li>【降低系统的性能】由于适配器模式需要进行额外的接口转换操作，因此可能会降低系统的性能。</li></ul></li></ul><ol start="4"><li><strong>【特点】：</strong></li></ol><ul><li><p><strong>实现：</strong>假设我们有一个音乐播放器程序，其中包括一个播放MP3音乐的接口MusicPlayer和一个播放CD音乐的接口CdPlayer，而我们想要将CdPlayer适配成MusicPlayer接口，这时就可以使用适配器模式。</p></li><li><p>首先，我们定义目标接口MusicPlayer：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MusicPlayer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String fileName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后，我们定义被适配者接口CdPlayer：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CdPlayer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playCd</span><span class="params">(String cdName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接下来，我们实现一个适配器类CdPlayerAdapter，它实现了目标接口MusicPlayer，并将被适配者接口CdPlayer的playCd方法转换成了目标接口MusicPlayer的play方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CdPlayerAdapter</span> <span class="keyword">implements</span> <span class="title class_">MusicPlayer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CdPlayer cdPlayer;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CdPlayerAdapter</span><span class="params">(CdPlayer cdPlayer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cdPlayer = cdPlayer;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        cdPlayer.playCd(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后，我们可以使用适配器类CdPlayerAdapter来播放CD音乐了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CdPlayer</span> <span class="variable">cdPlayer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CdPlayerImpl</span>();</span><br><span class="line">        <span class="type">MusicPlayer</span> <span class="variable">musicPlayer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CdPlayerAdapter</span>(cdPlayer);</span><br><span class="line">        musicPlayer.play(<span class="string">&quot;CD_NAME&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>拓展：</strong></p></li></ul><p>适配器模式总体来说分三种：默认适配器模式——&gt;对象适配器模式——&gt;类适配器模式</p><blockquote><p><strong>1、默认适配器模式</strong></p></blockquote><p>首先，我们先看看最简单的适配器模式**默认适配器模式(Default Adapter)**是怎么样的。<br>我们用 Appache commons-io 包中的FileAlterationListener 做例子，此接口定义了很多的方法，用于对文件或文件夹进行监控，一旦发生了对应的操作，就会触发相应的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FileAlterationListener</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onDirectoryCreate</span><span class="params">(<span class="keyword">final</span> File directory)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onDirectoryChange</span><span class="params">(<span class="keyword">final</span> File directory)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onDirectoryDelete</span><span class="params">(<span class="keyword">final</span> File directory)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onFileCreate</span><span class="params">(<span class="keyword">final</span> File file)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onFileChange</span><span class="params">(<span class="keyword">final</span> File file)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onFileDelete</span><span class="params">(<span class="keyword">final</span> File file)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此接口的一大问题是抽象方法太多了，如果我们要用这个接口，意味着我们要实现每一个抽象方法，如果我们只是想要监控文件夹中的<strong>文件创建</strong>和<strong>文件删除</strong>事件，可是我们还是不得不实现所有的方法，很明显，这不是我们想要的。<br>所以，我们需要下面的一个<strong>适配器</strong>，它用于实现上面的接口，但是<strong>所有的方法都是空方法</strong>，这样，我们就可以转而定义自己的类来继承下面这个类即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileAlterationListenerAdaptor</span> <span class="keyword">implements</span> <span class="title class_">FileAlterationListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDirectoryCreate</span><span class="params">(<span class="keyword">final</span> File directory)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDirectoryChange</span><span class="params">(<span class="keyword">final</span> File directory)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDirectoryDelete</span><span class="params">(<span class="keyword">final</span> File directory)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileCreate</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileChange</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileDelete</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们可以定义以下类，我们仅仅需要实现我们想实现的方法就可以了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileMonitor</span> <span class="keyword">extends</span> <span class="title class_">FileAlterationListenerAdaptor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileCreate</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">        <span class="comment">// 文件创建</span></span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileDelete</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">        <span class="comment">// 文件删除</span></span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>MVC中也有默认适配器模式</li></ul><p>当然，上面说的只是适配器模式的其中一种，也是最简单的一种，无需多言。下面，再介绍<strong>“正统的”</strong>适配器模式。</p><blockquote><p><strong>2、对象适配器模式</strong></p></blockquote><p>来看一个《Head First 设计模式》中的一个例子，我稍微修改了一下，看看怎么将鸡适配成鸭，这样鸡也能当鸭来用。因为，现在鸭这个接口，我们没有合适的实现类可以用，所以需要适配器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span>; <span class="comment">// 鸭的呱呱叫</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>; <span class="comment">// 飞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Cock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gobble</span><span class="params">()</span>; <span class="comment">// 鸡的咕咕叫</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>; <span class="comment">// 飞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WildCock</span> <span class="keyword">implements</span> <span class="title class_">Cock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gobble</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;咕咕叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鸡也会飞哦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鸭接口有 fly() 和 quare() 两个方法，鸡 Cock 如果要冒充鸭，fly() 方法是现成的，但是鸡不会鸭的呱呱叫，没有 quack() 方法。这个时候就需要适配了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 毫无疑问，首先，这个适配器肯定需要 implements Duck，这样才能当做鸭来用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CockAdapter</span> <span class="keyword">implements</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">  </span><br><span class="line">    Cock cock;</span><br><span class="line">    <span class="comment">// 构造方法中需要一个鸡的实例，此类就是将这只鸡适配成鸭来用</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">CockAdapter</span><span class="params">(Cock cock)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cock = cock;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 实现鸭的呱呱叫方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 内部其实是一只鸡的咕咕叫</span></span><br><span class="line">        cock.gobble();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        cock.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用很简单了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 有一只野鸡</span></span><br><span class="line">  <span class="type">Cock</span> <span class="variable">wildCock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WildCock</span>();</span><br><span class="line">  <span class="comment">// 成功将野鸡适配成鸭</span></span><br><span class="line">  <span class="type">Duck</span> <span class="variable">duck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CockAdapter</span>(wildCock);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，大家也就知道了适配器模式是怎么回事了。无非是我们需要一只鸭，但是我们只有一只鸡，这个时候就需要定义一个适配器，由这个适配器来充当鸭，但是适配器里面的方法还是由鸡来实现的。<br>我们用一个图来简单说明下：<br><img src="https://www.javadoop.com/blogimages/design-pattern/adapter-1.png#id=fRnW3&originHeight=908&originWidth=1522&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>上图应该还是很容易理解的，我就不做更多的解释了。下面，我们看看类适配模式怎么样的。</p><blockquote><p><strong>3、类适配器模式</strong></p></blockquote><p>废话少说，直接上图：<br><img src="https://www.javadoop.com/blogimages/design-pattern/adapter-2.png#id=r64pt&originHeight=854&originWidth=1514&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>看到这个图，大家应该很容易理解的吧，通过继承的方法，适配器自动获得了所需要的大部分方法。这个时候，客户端使用更加简单，直接 <code>Target t = new SomeAdapter();</code> 就可以了。</p><blockquote><p><strong>4、适配器模式总结</strong></p></blockquote><ol><li>** 类适配<strong>和</strong>对象适配**的异同<br>一个采用继承，一个采用组合；<br>类适配属于静态实现，对象适配属于组合的动态实现，对象适配需要多实例化一个对象。<br>总体来说，对象适配用得比较多。 </li><li>适配器模式和代理模式的异同<br>比较这两种模式，其实是比较对象适配器模式和代理模式，在代码结构上，它们很相似，都需要一个具体的实现类的实例。但是它们的目的不一样，代理模式做的是增强原方法的活；适配器做的是适配的活，为的是提供“把鸡包装成鸭，然后当做鸭来使用”，而鸡和鸭它们之间原本没有继承关系。<br><img src="https://www.javadoop.com/blogimages/design-pattern/adapter-5.png#id=VjvAG&originHeight=1148&originWidth=1470&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></li></ol><h2 id="3-3-桥接模式"><a href="#3-3-桥接模式" class="headerlink" title="3.3 桥接模式"></a>3.3 桥接模式</h2><blockquote><p>电商线下卖各种商品【二维变一维，解耦】</p></blockquote><ol><li><strong>【概念】：</strong>将抽象和实现解耦，使得两者可以独立地变化。</li></ol><p>理解桥梁模式，其实就是理解代码抽象和解耦。（继承改为关联关系）</p><ul><li><strong>类图</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688803746140-d745eefd-1134-4727-afd9-ed30071335a2.png#averageHue=%236b6a6b&clientId=uaef691d9-ff29-4&from=paste&height=637&id=ucd40e3c2&originHeight=637&originWidth=971&originalType=binary&ratio=1&rotation=0&showTitle=false&size=230203&status=done&style=none&taskId=ude0c375c-0b86-4ec0-aeca-7b55576a888&title=&width=971" alt="image.png"></p><ul><li><strong>抽象化(Abstraction)角色</strong>：抽象化给出的定义，并保存一个对实现化对象的引用。</li><li><strong>修正抽象化(Refined Abstraction)角色</strong>：扩展抽象化角色，改变和修正父类对抽象化的定义。</li><li><strong>实现化(Implementation)角色</strong>：这个角色给出实现化角色的接口，但不给出具体的实现。必须指出的是，这个接口不一定和抽象化角色的接口定义相同，实际上，这两个接口可以非常不一样。实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作。</li><li><strong>具体实现化(Concrete Implementor)角色</strong>：这个角色给出实现化角色接口的具体实现。</li></ul><ol start="2"><li><strong>【使用场景】：</strong></li></ol><ul><li>在抽象和具体之间需要增加更多灵活性的场景；</li><li>一个类存在2个或者以上独立变化的维度，而这些维度又需要独立进行扩展时。</li></ul><ol start="3"><li><strong>【优缺点】：</strong></li></ol><ul><li><strong>优点：</strong><ul><li>【分离抽象接口及其实现部分】桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。</li><li>【提高系统的可扩展性】在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合“开闭原则”</li></ul></li><li><strong>缺点：</strong><ul><li>【增加系统的理解与设计难度】由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程。</li></ul></li></ul><ol start="4"><li><strong>【特点】：</strong></li></ol><ul><li><strong>解耦前：</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688804023377-a1ddd553-c685-4d91-b83e-75f1e8cf863f.png#averageHue=%232e2f32&clientId=uaef691d9-ff29-4&from=paste&height=397&id=HTYrq&originHeight=592&originWidth=742&originalType=binary&ratio=1&rotation=0&showTitle=false&size=215530&status=done&style=none&taskId=u5fd57b5e-196f-4418-8829-3a2230a0030&title=&width=497" alt="image.png"></p><ul><li><strong>解耦后：</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688804066444-1167d38e-7cfa-445e-8835-d81598e67bad.png#averageHue=%23302f31&clientId=uaef691d9-ff29-4&from=paste&height=204&id=u11690c19&originHeight=524&originWidth=1493&originalType=binary&ratio=1&rotation=0&showTitle=false&size=178178&status=done&style=none&taskId=u6a20dbf1-1ccd-476e-9629-c3977ac0beb&title=&width=580" alt="image.png"><br>我们首先需要一个桥梁，它是一个接口，定义提供的接口方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是一系列实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedPen</span> <span class="keyword">implements</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用红色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreenPen</span> <span class="keyword">implements</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用绿色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BluePen</span> <span class="keyword">implements</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用蓝色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个抽象类，此类的实现类都需要使用 DrawAPI：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> DrawAPI drawAPI;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Shape</span><span class="params">(DrawAPI drawAPI)</span> &#123;<span class="comment">//构造</span></span><br><span class="line">        <span class="built_in">this</span>.drawAPI = drawAPI;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义抽象类的子类：他可以注入笔</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 圆形</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> radius;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">int</span> radius, DrawAPI drawAPI)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(drawAPI);<span class="comment">//调用父类的有参构造</span></span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        drawAPI.draw(radius, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 长方形</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, DrawAPI drawAPI)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(drawAPI);</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        drawAPI.draw(<span class="number">0</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们来看客户端演示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Shape</span> <span class="variable">greenCircle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">10</span>, <span class="keyword">new</span> <span class="title class_">GreenPen</span>());</span><br><span class="line">    <span class="type">Shape</span> <span class="variable">redRectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">4</span>, <span class="number">8</span>, <span class="keyword">new</span> <span class="title class_">RedPen</span>());</span><br><span class="line">    greenCircle.draw();</span><br><span class="line">    redRectangle.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能大家看上面一步步还不是特别清晰，我把所有的东西整合到一张图上：<br><img src="https://www.javadoop.com/blogimages/design-pattern/bridge-1.png#id=aAUGW&originHeight=1158&originWidth=1544&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>这回大家应该就知道抽象在哪里，怎么解耦了吧。桥梁模式的优点也是显而易见的，就是非常容易进行扩展。</p><h2 id="3-4-装饰器模式【-】"><a href="#3-4-装饰器模式【-】" class="headerlink" title="3.4 装饰器模式【*】"></a>3.4 装饰器模式【*】</h2><blockquote><p>将一个形状装饰上不同的颜色，同时又不改变形状。<br>孙悟空有72变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能；</p></blockquote><ol><li><strong>【概念】：</strong>装饰器模式又名包装(Wrapper)模式。动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。</li></ol><ul><li>装饰器模式以对客户端透明的方式拓展对象的功能，是继承关系的一种替代方案。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/35382725/1688811320289-d289fa79-a1fe-47a9-af9e-c4bb24b928ae.jpeg#averageHue=%23f1f1f1&clientId=uaef691d9-ff29-4&from=drop&height=444&id=u60c0bee4&originHeight=483&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=34640&status=done&style=none&taskId=u28610a00-7ce7-4a6d-9540-65e234235c0&title=&width=460" alt="v2-e522782edd431352b249572452ec36f6_b.jpg"></p><ul><li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</li><li>具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li><li>抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li><li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li></ul><p>Component 实现类 ConcreteComponent 的区别是，它们只是装饰者，起<strong>装饰</strong>作用，也就是即使它们看上去牛逼轰轰，但是它们都只是在具体的实现中<strong>加了层皮来装饰</strong>而已。</p><ol start="2"><li><strong>【使用场景】：Java的IO流——&gt;InputStream流</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688699688789-ddf41b61-ed31-4b82-8a2b-7fba6b8e78cf.png#averageHue=%23343431&clientId=uee24b681-3279-4&from=paste&height=300&id=u3fe76574&originHeight=300&originWidth=1462&originalType=binary&ratio=1&rotation=0&showTitle=false&size=117047&status=done&style=none&taskId=ubd929e4e-cfd3-442d-997f-79cd0b32874&title=&width=1462" alt="image.png"></p><ol start="3"><li><strong>【优缺点】：</strong></li></ol><ul><li><strong>优点：</strong><ul><li>装饰这模式和继承的目的都是扩展对象的功能，但装饰者模式比继承更灵活 通过使用不同的具体装饰类以及这些类的排列组合，设计师可以创造出很多不同行为的组合装饰者模式有很好地可扩展性</li><li>装饰类和被装饰类可以独立发展，而不会相互耦合。Component类无须知道Decorator类，而Decorator也不用知道具体的构件，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”。</li></ul></li><li>缺点：<ul><li>装饰者模式会导致设计中出现许多小对象，如果过度使用，会让程序变的更复杂。并且更多的对象会是的差错变得困难，特别是这些对象看上去都很像。</li></ul></li></ul><ol start="4"><li><strong>【特点】：</strong></li></ol><ul><li>“快乐柠檬”案例：</li></ul><p><img src="https://www.javadoop.com/blogimages/design-pattern/decorator-2.png#id=zu7Ew&originHeight=1158&originWidth=1546&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ul><li>装饰模式应用：Stream流</li></ul><p>下面，我们再来说说 java IO 中的装饰模式。看下图 InputStream 派生出来的部分类：<br><img src="https://www.javadoop.com/blogimages/design-pattern/decorator-3.png#id=fuZKC&originHeight=742&originWidth=1536&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>我们知道 InputStream 代表了输入流，具体的输入来源可以是文件（FileInputStream）、管道（PipedInputStream）、数组（ByteArrayInputStream）等，属于基础输入流。<br>FilterInputStream 承接了装饰模式的关键节点，它的实现类是一系列装饰器，</p><ul><li>比如 BufferedInputStream 代表用缓冲来装饰，也就<strong>使得输入流具有了缓冲的功能</strong></li><li>DataInputStream 的装饰，使得我们可以从输入流转换为 java 中的<strong>基本类型值</strong></li><li>LineNumberInputStream 代表用行号来装饰，在操作的时候就可以<strong>取得行号</strong>了</li></ul><p>当然，在 java IO 中，如果我们使用装饰器的话，就不太适合面向接口编程了，如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LineNumberInputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;&quot;</span>)));</span><br></pre></td></tr></table></figure><p>这样的结果是，InputStream 还是不具有读取行号的功能，因为读取行号的方法定义在 LineNumberInputStream 类中。<br>我们应该像下面这样使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DataInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(</span><br><span class="line">                              <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;&quot;</span>)));</span><br></pre></td></tr></table></figure><blockquote><p>所以说嘛，要找到纯的严格符合设计模式的代码还是比较难的。</p></blockquote><h2 id="3-5-门面-外观模式"><a href="#3-5-门面-外观模式" class="headerlink" title="3.5 门面&#x2F;外观模式"></a>3.5 门面&#x2F;外观模式</h2><blockquote><p>公安局开证明，让工作人员安排</p></blockquote><ol><li><strong>【概念】：</strong>要求一个子系统的外与其内部的通信必须通过一个统一的对象进行，外观模式提供一个高层次的接口，使得子系统更易使用。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688811386066-2e0792b7-911a-4d5f-8798-9f03f68e14ad.png#averageHue=%23f2f2f2&clientId=uaef691d9-ff29-4&from=paste&height=364&id=ud0b87bf8&originHeight=387&originWidth=577&originalType=binary&ratio=1&rotation=0&showTitle=false&size=75829&status=done&style=none&taskId=u4aaabbd3-5292-47d1-a4c6-ab5da0fe580&title=&width=542" alt="image.png"></p><ul><li><strong>类图：</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688787626733-754f382f-56a2-47b8-a5ec-d55f2d62c46d.png#averageHue=%23f6f6f6&clientId=uaef691d9-ff29-4&from=drop&id=wuCNw&originHeight=396&originWidth=770&originalType=binary&ratio=1&rotation=0&showTitle=false&size=52052&status=done&style=none&taskId=ue0912b89-486e-43f1-a4b1-ab02a4bb92f&title=" alt="20210520114447433.png"></p><ul><li>外观（Facade）角色：为多个子系统对外提供一个共同的接口。</li><li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</li><li>客户（Client）角色：通过一个外观角色访问各个子系统的功能。</li></ul><ol start="2"><li><strong>【使用场景】：</strong></li></ol><ul><li>slf4j 就可以理解为是门面模式的应用；</li></ul><ol start="3"><li><strong>【优缺点】：</strong></li></ol><ul><li><strong>优点：</strong><ul><li>【<strong>降低系统复杂度 &amp; 耦合度</strong>】通过引入一个新的外观角色来<strong>降低原有系统的复杂度，同时降低客户类与子系统的耦合度</strong>（所指的子系统是一个广义的概念，它可以是一个类、一个功能模块、系统的一个组成部分或者一个完整的系统），使得子系统更加易用</li><li><strong>【松耦合】</strong>它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可</li></ul></li><li><strong>缺点：</strong><ul><li><strong>【减少可变性和灵活性】</strong>不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性</li><li><strong>【违背开闭原则】</strong>如果设计不当，增加新的子系统可能需要修改外观类的源代码</li></ul></li></ul><ol start="4"><li><strong>【特点】：</strong></li></ol><p>首先，我们定义一个接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义几个实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Circle::draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Rectangle::draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 画一个圆形</span></span><br><span class="line">  <span class="type">Shape</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">  circle.draw();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 画一个长方形</span></span><br><span class="line">  <span class="type">Shape</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">  rectangle.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是我们常写的代码，我们需要画圆就要先实例化圆，画长方形就需要先实例化一个长方形，然后再调用相应的 draw() 方法。<br>下面，我们看看怎么用门面模式来让客户端调用更加友好一些。<br>我们先定义一个门面：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeMaker</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> Shape circle;</span><br><span class="line">   <span class="keyword">private</span> Shape rectangle;</span><br><span class="line">   <span class="keyword">private</span> Shape square;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">ShapeMaker</span><span class="params">()</span> &#123;</span><br><span class="line">      circle = <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">      rectangle = <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">      square = <span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 下面定义一堆方法，具体应该调用什么方法，由这个门面来决定</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">()</span>&#123;</span><br><span class="line">      circle.draw();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">()</span>&#123;</span><br><span class="line">      rectangle.draw();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawSquare</span><span class="params">()</span>&#123;</span><br><span class="line">      square.draw();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看现在客户端怎么调用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">ShapeMaker</span> <span class="variable">shapeMaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShapeMaker</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 客户端调用现在更加清晰了</span></span><br><span class="line">  shapeMaker.drawCircle();</span><br><span class="line">  shapeMaker.drawRectangle();</span><br><span class="line">  shapeMaker.drawSquare();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>门面模式的优点显而易见，客户端不再需要关注实例化时应该使用哪个实现类，直接调用门面提供的方法就可以了，因为门面类提供的方法的方法名对于客户端来说已经很友好了。</p><h2 id="3-6-组合模式"><a href="#3-6-组合模式" class="headerlink" title="3.6 组合模式"></a>3.6 组合模式</h2><blockquote><p>地图（乡-镇-县-市-省-国）</p></blockquote><ol><li><strong>【概念】：</strong>组合模式依据<strong>树形结构</strong>来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/webp/35382725/1688811440742-f80b9c8d-e365-4f2a-bfad-2ad26a160bcf.webp#averageHue=%23f7f7f7&clientId=uaef691d9-ff29-4&from=drop&id=u2d1181e4&originHeight=390&originWidth=610&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11196&status=done&style=none&taskId=u990385ce-7cd2-4c88-a6aa-677b07f898f&title=" alt="v2-1525efc414a6ad216bb71ccc8e4889e8_720w.webp"></p><ul><li><strong>类图</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/35382725/1688811456903-0eccd8cf-ce69-4faa-a627-cee666af78c0.jpeg#averageHue=%23f0f0f0&clientId=uaef691d9-ff29-4&from=drop&id=u33bd26c9&originHeight=519&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=41909&status=done&style=none&taskId=u24a1082c-b2a4-418c-b0dd-8d92a46efb4&title=" alt="v2-44c5f1708c950ea16871b8d91315d0ea_b.jpg"></p><ul><li><strong>抽象构件（Component）角色：</strong>它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。（总的抽象类或接口，定义一些通用的方法，比如新增、删除）</li><li><strong>树叶构件（Leaf）角色：</strong>是组合中的叶节点对象，它没有子节点，用于继承或实现抽象构件。</li><li><strong>树枝构件（Composite）角色 &#x2F; 中间构件：</strong>是组合中的分支节点对象，它有子节点，用于继承和实现抽象构件。它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法。</li></ul><ol start="2"><li><strong>【使用场景】：</strong></li></ol><ul><li>算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数；</li><li>JDK：AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。</li></ul><ol start="3"><li><strong>【优缺点】：</strong></li></ol><ul><li><strong>优点：</strong><ul><li>利用多态和递归机制更方便地使用复杂树结构；</li><li>【符合开闭原则】节点自由增加；</li></ul></li><li><strong>缺点：</strong><ul><li>【违反依赖倒置原则】在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口；</li></ul></li></ul><ol start="4"><li><strong>【特点】：</strong><blockquote><p>桥接模式是传入对象，组合模式是list和对象调用方法一致</p></blockquote></li></ol><p>组合模式用于表示具有层次结构的数据，使得我们对单个对象和组合对象的访问具有一致性。<br>直接看一个例子吧，每个员工都有姓名、部门、薪水这些属性，同时还有下属员工集合（虽然可能集合为空），而下属员工和自己的结构是一样的，也有姓名、部门这些属性，同时也有他们的下属员工集合。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String dept;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> salary;</span><br><span class="line">   <span class="keyword">private</span> List&lt;Employee&gt; subordinates; <span class="comment">// 下属</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name,String dept, <span class="type">int</span> sal)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="built_in">this</span>.dept = dept;</span><br><span class="line">      <span class="built_in">this</span>.salary = sal;</span><br><span class="line">      subordinates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Employee&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Employee e)</span> &#123;</span><br><span class="line">      subordinates.add(e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Employee e)</span> &#123;</span><br><span class="line">      subordinates.remove(e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">getSubordinates</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> subordinates;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="string">&quot;Employee :[ Name : &quot;</span> + name + <span class="string">&quot;, dept : &quot;</span> + dept + <span class="string">&quot;, salary :&quot;</span> + salary+<span class="string">&quot; ]&quot;</span>);</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常，这种类需要定义 add(node)、remove(node)、getChildren() 这些方法。</p><blockquote><p>很多源码中如果出现xxxComposite的样式，就是组合模式</p></blockquote><h2 id="3-7-享元模式"><a href="#3-7-享元模式" class="headerlink" title="3.7 享元模式"></a>3.7 享元模式</h2><blockquote><p>共享单车【池技术：内部状态共享，外部状态实现子类定义】</p></blockquote><ol><li><strong>【概念】：</strong>运用共享技术有效地支持大量细粒度的对象。主要用于减少创建对象的数量，以减少内存占用和提高性能。它提供了减少对象数量从而改善应用所需的对象结构的方式。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688798623479-fe315228-421a-449e-be21-e21558c4733a.png#averageHue=%232a2a2a&clientId=uaef691d9-ff29-4&from=paste&height=307&id=u842df804&originHeight=307&originWidth=833&originalType=binary&ratio=1&rotation=0&showTitle=false&size=48442&status=done&style=none&taskId=uacab6053-8e8e-4e04-8705-8966d2b2e9f&title=&width=833" alt="image.png"></p><ul><li><strong>类图：</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688798148356-3443376e-3217-411d-bda8-f464ca3709bb.png#averageHue=%23f3f3f3&clientId=uaef691d9-ff29-4&from=paste&height=346&id=ud7356f19&originHeight=346&originWidth=754&originalType=binary&ratio=1&rotation=0&showTitle=false&size=70820&status=done&style=none&taskId=u6c9ba4e6-465e-4e96-9861-385f9fc6a6a&title=&width=754" alt="image.png"></p><ul><li>享元工厂（FlyweightFactory）：用于创建具体享元类，维护相同的享元对象。</li><li>抽象享元（Flyweight）：定义需要共享的对象业务接口。</li><li>具体享元（ConcreteFlyweight）：实现抽象享元类的接口，完成某一具体逻辑。</li></ul><ol start="2"><li><strong>【使用场景】：</strong></li></ol><ul><li>JDK：String类，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。</li><li>连接池：数据库连接池 &amp;&amp; 并发线程连接池</li></ul><ol start="3"><li><strong>【优缺点】：</strong></li></ol><ul><li><strong>优点：</strong><ul><li>【减少内存消耗】通过共享对象，可以减少系统中对象的数量，从而减少内存消耗。</li><li>【实现对象的复用】通过共享对象，可以实现对象的复用，避免重复创建对象。</li></ul></li><li><strong>缺点：</strong><ul><li>【提高系统的复杂度】需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。</li></ul></li></ul><ol start="4"><li><strong>【特点】：</strong></li></ol><p>定义抽象享元类（Book）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">borrow</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体享元类（ConcreteBook）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteBook</span> <span class="keyword">implements</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="comment">//被借出的书名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteBook</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">borrow</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;图书馆借出一本书，书名为：&quot;</span> + <span class="built_in">this</span>.name );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>享元工厂（Llibrary）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Library</span> &#123;</span><br><span class="line">    <span class="comment">//图书馆维护一个图书列表</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Book&gt; bookPools = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Book&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Library</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Library</span>();</span><br><span class="line">    <span class="comment">//图书馆只有一个</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Library <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//图书馆外借图书</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">libToBorrow</span><span class="params">(String bookName)</span>&#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">order</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//如果书架有，直接借出</span></span><br><span class="line">        <span class="keyword">if</span> (bookPools.containsKey(bookName)) &#123;</span><br><span class="line">            order = bookPools.get(bookName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果书架没有，那就调进来一本新书</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            order = <span class="keyword">new</span> <span class="title class_">ConcreteBook</span>(bookName);</span><br><span class="line">            bookPools.put(bookName, order);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//图书馆书架上的书的数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAllBookSize</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookPools.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟学生去借书</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">//图书馆书架上的书</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Book&gt; books = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Book&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Library library;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        library = Library.getInstance();</span><br><span class="line">        studentBorrow(<span class="string">&quot;java编程思想&quot;</span>);</span><br><span class="line">        studentBorrow(<span class="string">&quot;java核心卷一&quot;</span>);</span><br><span class="line">        studentBorrow(<span class="string">&quot;java从入门到精通&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;后两本没学会，又借了一次 &quot;</span>);</span><br><span class="line">        studentBorrow(<span class="string">&quot;java核心卷一&quot;</span>);</span><br><span class="line">        studentBorrow(<span class="string">&quot;java从入门到精通&quot;</span>);</span><br><span class="line">        <span class="comment">//把每一本书借出去</span></span><br><span class="line">        <span class="keyword">for</span> (Book book : books) &#123;</span><br><span class="line">            book.borrow();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出一些学生一共借多少本书</span></span><br><span class="line">        System.out.println(<span class="string">&quot;学生一共借了 &quot;</span> + books.size() + <span class="string">&quot; 本书! &quot;</span>);</span><br><span class="line">        <span class="comment">//输出一下图书馆一共借出多少本书</span></span><br><span class="line">        System.out.println(<span class="string">&quot;图书馆实际借出&quot;</span> + library.getAllBookSize() + <span class="string">&quot; 本书&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">studentBorrow</span><span class="params">(String bookName)</span> &#123;</span><br><span class="line">        books.add(library.libToBorrow(bookName));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是享元模式的代码实现，其实在这里最为关键的就是<strong>享元工厂类</strong>。享元模式的思想也主要在这个类中去体现。最后我们把享元模式和其他的模式进行一个对比分析。</p><h1 id="4、行为型模式"><a href="#4、行为型模式" class="headerlink" title="4、行为型模式"></a>4、行为型模式</h1><p>行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使得我们的代码更加地清晰。<br>行为型模式部分介绍了策略模式、观察者模式、责任链模式、模板方法模式和状态模式，其实，经典的行为型模式还包括备忘录模式、命令模式等。</p><h2 id="4-1-策略模式【-】"><a href="#4-1-策略模式【-】" class="headerlink" title="4.1 策略模式【*】"></a>4.1 策略模式【*】</h2><blockquote><p>洗衣机的模式选择</p></blockquote><ol><li><strong>【概念】：</strong>定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688794977369-c0299402-f29f-48a1-9035-e5d3edb37ef3.png#averageHue=%232e2a2a&clientId=uaef691d9-ff29-4&from=paste&height=525&id=ude845edf&originHeight=525&originWidth=875&originalType=binary&ratio=1&rotation=0&showTitle=false&size=57708&status=done&style=none&taskId=ud87384e0-d709-455c-b442-46b6006179c&title=&width=875" alt="image.png"></p><ul><li>类图</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688794949647-822087e3-f273-44aa-9cfb-2b321c58878c.png#averageHue=%23f6f4f1&clientId=uaef691d9-ff29-4&from=paste&height=440&id=uedc8052c&originHeight=440&originWidth=1075&originalType=binary&ratio=1&rotation=0&showTitle=false&size=191187&status=done&style=none&taskId=ue6a2eadc-f7fe-435d-8163-636873508cd&title=&width=1075" alt="image.png"></p><ul><li>Context（环境类）：使用策略算法的角色</li><li>Strategy(抽象策略类)：声明了抽象方法，是所有策略类的父类，它可以是抽象类或者具体类，也可以是接口。</li><li>ConcreteStrategy(具体策略类)：实现了在抽象策略类中声明的算法，使用一种具体的算法实现某个业务功能。</li></ul><ol start="2"><li><strong>【使用场景】：</strong></li></ol><ul><li><strong>JDK：</strong>ThreadPoolExecutor线程池里的拒绝策略</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688794869674-af170ddd-42f2-45ec-ac72-557f4e4a6aee.png#averageHue=%23333230&clientId=uaef691d9-ff29-4&from=paste&height=407&id=u98240ea0&originHeight=407&originWidth=1007&originalType=binary&ratio=1&rotation=0&showTitle=false&size=88288&status=done&style=none&taskId=u6e977453-1822-4bd5-b8b6-e44cbf16bf4&title=&width=1007" alt="image.png"></p><ul><li><strong>JDK：</strong>Collections.sort(List<T> list, Comparator&lt;? super T&gt; c)方法，这个方法接受一个比较器Compartor参数，客户端在运行时可以传入一个比较器的实现，sort()方法中根据不同实现，按照不同的方式进行排序。</li></ul><ol start="3"><li><strong>【优缺点】：</strong></li></ol><ul><li><strong>优点：</strong><ul><li>策略模式符合开闭原则；</li><li>避免使用多重条件转移语句，如if…else…语句、switch语句；</li><li>使用策略模式可以提高算法的保密性和安全性；</li></ul></li><li><strong>缺点：</strong><ul><li>客户端必须知道所有的策略，并且自行决定使用哪一个策略类；</li><li>代码中会产生非常多策略类，增加维护难度；</li></ul></li></ul><ol start="4"><li><strong>【特点】：</strong></li></ol><p>首先，先定义一个策略接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们定义具体的几个策略：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedPen</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;用红色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreenPen</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;用绿色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BluePen</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;用蓝色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用策略的类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(Strategy strategy)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">executeDraw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> strategy.draw(radius, x, y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端演示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">BluePen</span>()); <span class="comment">// 使用绿色笔来画</span></span><br><span class="line">  context.executeDraw(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>放到一张图上，让大家看得清晰些：<br><img src="https://www.javadoop.com/blogimages/design-pattern/strategy-1.png#id=TUHvK&originHeight=1156&originWidth=1544&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>这个时候，大家有没有联想到结构型模式中的桥梁模式，它们其实非常相似，我把桥梁模式的图拿过来大家对比下：<br><img src="https://www.javadoop.com/blogimages/design-pattern/bridge-1.png#id=jHM8K&originHeight=1158&originWidth=1544&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>要我说的话，它们非常相似，桥梁模式在左侧加了一层抽象而已。<strong>桥梁模式的耦合更低</strong>，结构更复杂一些。</p><h2 id="4-2-观察者模式"><a href="#4-2-观察者模式" class="headerlink" title="4.2 观察者模式"></a>4.2 观察者模式</h2><blockquote><p>欠钱还钱，有钱就通知</p></blockquote><ol><li><strong>【概念】：</strong>观察者模式(Observer Pattern):定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688702180424-3eb182a3-be9f-4c7e-bc58-1a2c2117f4d8.png#averageHue=%232c2c2c&clientId=uaef691d9-ff29-4&from=paste&height=417&id=ub57f7908&originHeight=809&originWidth=1113&originalType=binary&ratio=1&rotation=0&showTitle=false&size=144691&status=done&style=none&taskId=u3c60d3f6-d0d0-4c01-b03b-659d6ead0c7&title=&width=574" alt="image.png"></p><ul><li>类图</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/35382725/1688787096869-b6b20ce8-bc69-41e4-b28e-a197b03fdbe7.jpeg#averageHue=%23f4f4f4&clientId=uaef691d9-ff29-4&from=drop&height=408&id=udb42b9d7&originHeight=462&originWidth=590&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18802&status=done&style=none&taskId=u56087300-8a4b-4169-b4c1-641000c1bd4&title=&width=521" alt="v2-4ad3e0b3c15d542518aa433ed9a8c640_720w.jpg"></p><ul><li><strong>抽象主题（Subject）角色：</strong>也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。</li><li><strong>具体主题（Concrete Subject）角色：</strong>也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</li><li><strong>抽象观察者（Observer）角色：</strong>它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。</li><li><strong>具体观察者（Concrete Observer）角色：</strong>实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。</li></ul><ol start="2"><li><strong>【使用场景】：java.util.Observable 和 java.util.Observer 这两个类</strong></li><li><strong>【优缺点】：</strong></li></ol><ul><li><strong>优点：</strong><ul><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li><li>目标与观察者之间建立了一套触发机制。</li></ul></li><li><strong>缺点：</strong><ul><li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</li><li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</li></ul></li></ul><ol start="4"><li><strong>【特点】：</strong></li></ol><p>观察者模式对于我们来说，真是再简单不过了。无外乎两个操作，观察者订阅自己关心的主题和主题有数据变化后通知观察者们。**(注册观察者后通知)**<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688702223331-af234c6a-8f5a-4c8a-b568-181907a4260f.png#averageHue=%23302f2f&clientId=uaef691d9-ff29-4&from=paste&height=380&id=u4ce72b49&originHeight=380&originWidth=918&originalType=binary&ratio=1&rotation=0&showTitle=false&size=139778&status=done&style=none&taskId=ud21cc16b-c7dc-4977-9298-455119d37a4&title=&width=918" alt="image.png"><br>首先，需要定义主题，每个主题需要持有观察者列表的引用，用于在数据变更的时候通知各个观察者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">        <span class="comment">// 数据已变更，通知观察者们</span></span><br><span class="line">        notifyAllObservers();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册观察者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知观察者们</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyAllObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义观察者接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Subject subject;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实如果只有一个观察者类的话，接口都不用定义了，不过，通常场景下，既然用到了观察者模式，我们就是希望一个事件出来了，会有多个不同的类需要处理相应的信息。比如，订单修改成功事件，我们希望发短信的类得到通知、发邮件的类得到通知、处理物流信息的类得到通知等。<br>我们来定义具体的几个观察者类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryObserver</span> <span class="keyword">extends</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">// 在构造方法中进行订阅主题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BinaryObserver</span><span class="params">(Subject subject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subject = subject;</span><br><span class="line">        <span class="comment">// 通常在构造方法中将 this 发布出去的操作一定要小心</span></span><br><span class="line">        <span class="built_in">this</span>.subject.attach(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该方法由主题类在数据变更的时候进行调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> Integer.toBinaryString(subject.getState());</span><br><span class="line">        System.out.println(<span class="string">&quot;订阅的数据发生变化，新的数据处理为二进制值为：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HexaObserver</span> <span class="keyword">extends</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HexaObserver</span><span class="params">(Subject subject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subject = subject;</span><br><span class="line">        <span class="built_in">this</span>.subject.attach(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> Integer.toHexString(subject.getState()).toUpperCase();</span><br><span class="line">        System.out.println(<span class="string">&quot;订阅的数据发生变化，新的数据处理为十六进制值为：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端使用也非常简单：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 先定义一个主题</span></span><br><span class="line">    <span class="type">Subject</span> <span class="variable">subject1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Subject</span>();</span><br><span class="line">    <span class="comment">// 定义观察者</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">BinaryObserver</span>(subject1);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HexaObserver</span>(subject1);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 模拟数据变更，这个时候，观察者们的 update 方法将会被调用</span></span><br><span class="line">    subject.setState(<span class="number">11</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">订阅的数据发生变化，新的数据处理为二进制值为：1011</span><br><span class="line">订阅的数据发生变化，新的数据处理为十六进制值为：B</span><br></pre></td></tr></table></figure><p>实际生产过程中，观察者模式往往用消息中间件来实现，如果要实现单机观察者模式，笔者建议读者使用 Guava 中的 EventBus，它有同步实现也有异步实现，本文主要介绍设计模式，就不展开说了。<br>还有，即使是上面的这个代码，也会有很多变种，大家只要记住核心的部分，那就是一定有一个地方存放了所有的观察者，然后在事件发生的时候，遍历观察者，调用它们的回调函数。</p><h2 id="4-3-责任链模式"><a href="#4-3-责任链模式" class="headerlink" title="4.3 责任链模式"></a>4.3 责任链模式</h2><blockquote><p>请假审批流程</p></blockquote><ol><li><strong>【概念】：</strong>责任链模式(Chain of Responsibility)是一种处理请求的模式，它让多个处理器都有机会处理该请求，直到其中某个处理成功为止。责任链模式把多个处理器串成链，然后让请求在链上传递。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688796371382-b477ced1-0b5c-4ea7-a9be-18e0f002bac4.png#averageHue=%232b2b2b&clientId=uaef691d9-ff29-4&from=paste&height=271&id=u12504a84&originHeight=271&originWidth=1242&originalType=binary&ratio=1&rotation=0&showTitle=false&size=78682&status=done&style=none&taskId=u91e640ad-0757-441d-90c4-512f7bc85ae&title=&width=1242" alt="image.png"></p><ul><li><strong>类图：</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/webp/35382725/1688796526469-67534bdc-4ce3-4817-9808-a38e1fce01bc.webp#averageHue=%23f1f1f1&clientId=uaef691d9-ff29-4&from=drop&id=ua462ec68&originHeight=458&originWidth=720&originalType=binary&ratio=1&rotation=0&showTitle=false&size=28448&status=done&style=none&taskId=u56718c9a-6f60-410c-90b5-caaca9df2b9&title=" alt="v2-323352bbdc7d89ec9835819fc63e779c_720w.webp"></p><ul><li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li><li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li><li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li><li><strong>结构图：</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/35382725/1688796551714-b03d3eda-8700-48e9-9f86-f6b4b8095920.jpeg#averageHue=%23f5f5f5&clientId=uaef691d9-ff29-4&from=drop&id=ub5906214&originHeight=178&originWidth=650&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16886&status=done&style=none&taskId=uf0d260c6-e56a-489b-8106-b829a625e62&title=" alt="v2-56e0265703ecd889cb2f4b14a414d5c9_720w.jpg"></p><ol start="2"><li><strong>【使用场景】：</strong></li></ol><ul><li>JS 中的事件冒泡；</li><li>JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。</li></ul><ol start="3"><li><strong>【优缺点】：</strong></li></ol><ul><li><strong>优点：</strong><ul><li>【降低耦合度】它将请求的发送者和接收者解耦 </li><li>【简化对象】使得对象不需要知道链的结构 </li><li>【增强给对象指派职责的灵活性】允许动态地新增或者删除责任链 </li><li>增加新的请求处理类方便</li></ul></li><li><strong>缺点：</strong><ul><li>不能保证请求一定被接收； </li><li>系统性能将受到一定影响，调试时不方便，可能会造成循环调用</li></ul></li></ul><ol start="4"><li><strong>【特点】：</strong></li></ol><p>有这么一个场景，用户参加一个活动可以领取奖品，但是活动需要进行很多的规则校验然后才能放行，比如首先需要校验用户是否是新用户、今日参与人数是否有限额、全场参与人数是否有限额等等。设定的规则都通过后，才能让用户领走奖品。<br>首先，我们要定义流程上节点的基类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RuleHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 后继节点 ，如果把这个类命名为next你就更能理解了</span></span><br><span class="line">    <span class="keyword">protected</span> RuleHandler successor;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Context context)</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuccessor</span><span class="params">(RuleHandler successor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> RuleHandler <span class="title function_">getSuccessor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们需要定义具体的每个节点了。<br>校验用户是否是新用户：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewUserRuleHandler</span> <span class="keyword">extends</span> <span class="title class_">RuleHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (context.isNewUser()) &#123;</span><br><span class="line">            <span class="comment">// 如果有后继节点的话，传递下去</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.getSuccessor() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.getSuccessor().apply(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;该活动仅限新用户参与&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>校验用户所在地区是否可以参与：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocationRuleHandler</span> <span class="keyword">extends</span> <span class="title class_">RuleHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">allowed</span> <span class="operator">=</span> activityService.isSupportedLocation(context.getLocation);</span><br><span class="line">        <span class="keyword">if</span> (allowed) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.getSuccessor() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.getSuccessor().apply(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;非常抱歉，您所在的地区无法参与本次活动&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>校验奖品是否已领完：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LimitRuleHandler</span> <span class="keyword">extends</span> <span class="title class_">RuleHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">remainedTimes</span> <span class="operator">=</span> activityService.queryRemainedTimes(context); <span class="comment">// 查询剩余奖品</span></span><br><span class="line">        <span class="keyword">if</span> (remainedTimes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.getSuccessor() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.getSuccessor().apply(userInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;您来得太晚了，奖品被领完了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">RuleHandler</span> <span class="variable">newUserHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewUserRuleHandler</span>();</span><br><span class="line">    <span class="type">RuleHandler</span> <span class="variable">locationHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocationRuleHandler</span>();</span><br><span class="line">    <span class="type">RuleHandler</span> <span class="variable">limitHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LimitRuleHandler</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 假设本次活动仅校验地区和奖品数量，不校验新老用户</span></span><br><span class="line">    locationHandler.setSuccessor(limitHandler);</span><br><span class="line">  </span><br><span class="line">    locationHandler.apply(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码其实很简单，就是先定义好一个链表，然后在通过任意一节点后，如果此节点有后继节点，那么传递下去。<br>至于它和我们前面说的用一个 List 存放需要执行的规则的做法有什么异同，留给读者自己琢磨吧。</p><h2 id="4-4-模板方法模式【-】"><a href="#4-4-模板方法模式【-】" class="headerlink" title="4.4 模板方法模式【*】"></a>4.4 模板方法模式【*】</h2><blockquote><p>新东方学做菜</p></blockquote><ol><li><strong>【概念】：</strong>定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤【在含有继承结构的代码中，模板方法模式是非常常用的。(回调)】</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688797613102-d96e6bba-bd11-4a13-8fa0-9bb6ea4da7da.png#averageHue=%23323131&clientId=uaef691d9-ff29-4&from=paste&height=525&id=u7df2bbc2&originHeight=525&originWidth=1019&originalType=binary&ratio=1&rotation=0&showTitle=false&size=93676&status=done&style=none&taskId=u3104c5e7-6d5b-4765-86f4-c3524f2e49b&title=&width=1019" alt="image.png"></p><ul><li><strong>类图</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688797472069-d03bfc7d-612f-4555-9b87-e11cc9331021.png#averageHue=%232f2e2e&clientId=uaef691d9-ff29-4&from=paste&height=730&id=ub6b255cd&originHeight=730&originWidth=1121&originalType=binary&ratio=1&rotation=0&showTitle=false&size=174386&status=done&style=none&taskId=u25401e49-5a2e-4485-820f-42e0dbafa95&title=&width=1121" alt="image.png"></p><ul><li>AbstractClass（抽象模板类）</li><li>ConcreteClass（模板实现子类）</li></ul><ol start="2"><li><strong>【使用场景】：</strong></li></ol><ul><li>JDK：静态的Arrays.sort(Object[])，sort()是一个模板方法，然后需要我们自定义实现 compareTo()方法,用来“填补”模板方法的缺陷；</li><li>Java并发包的大核心，AbstactQueuedSynchronizer（简称AQS），其提供的 acquire() 方法用来获取锁，但是需要具体的锁实现类去自定义完成 tryAcquire() 方法。</li></ul><ol start="3"><li><strong>【优缺点】：</strong></li></ol><ul><li><strong>优点：</strong><ul><li>【提高代码的复用性】利用模板方法将相同处理逻辑的代码放到抽象父类中；</li><li>【提高代码的扩展性】将不同的代码不同的子类中，通过对子类的扩展增加新的行为；</li><li>【符合开闭原则】把不变的行为写在父类上，去除子类的重复代码，提供了一个很好的代码复用平台。</li></ul></li><li><strong>缺点：</strong><ul><li>【增加系统实现复杂度】类数目的增加，每一个抽象类都需要一个子类来实现，这样导致类的个数增加。</li><li>【继承关系自身缺点】如果父类添加新的抽象方法，所有子类都要改一遍。</li></ul></li></ul><ol start="4"><li><strong>【特点】：</strong></li></ol><p>通常会有一个抽象类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractTemplate</span> &#123;</span><br><span class="line">    <span class="comment">// 这就是模板方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        init();</span><br><span class="line">        apply(); <span class="comment">// 这个是重点</span></span><br><span class="line">        end(); <span class="comment">// 可以作为钩子方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init 抽象层已经实现，子类也可以选择覆写&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 留给子类实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板方法中调用了 3 个方法，其中 apply() 是抽象方法，子类必须实现它，其实模板方法中有几个抽象方法完全是自由的，我们也可以将三个方法都设置为抽象方法，让子类来实现。也就是说，模板方法只负责定义第一步应该要做什么，第二步应该做什么，第三步应该做什么，至于怎么做，由子类来实现。<br>我们写一个实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteTemplate</span> <span class="keyword">extends</span> <span class="title class_">AbstractTemplate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类实现抽象方法 apply&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我们可以把 method3 当做钩子方法来使用，需要的时候覆写就可以了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用演示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AbstractTemplate</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteTemplate</span>();</span><br><span class="line">    <span class="comment">// 调用模板方法</span></span><br><span class="line">    t.templateMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码其实很简单，基本上看到就懂了，关键是要学会用到自己的代码中。</p><blockquote><p>如果在源码中看到了final修饰符，而该方法中调用了其他源码，很可能就是模板方法模式</p></blockquote><h2 id="4-5-状态模式"><a href="#4-5-状态模式" class="headerlink" title="4.5 状态模式"></a>4.5 状态模式</h2><blockquote><p>根据心情做事情，解决if else问题</p></blockquote><ol><li><strong>【概念】：</strong>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States),状态模式是一种对象行为型模式。</li></ol><p>【阿里Java开发手册】如果非得使用if()..else if()…else..方式表达逻辑，【强制】避免后续代码维护困难，请勿超过3层。<br><strong>正例：超过3层的if-eLse的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，</strong></p><ul><li><p><strong>卫语句</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)&#123;</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688788458311-4d6d8f73-01b2-4f1d-bc08-965eab23f56d.png#averageHue=%23f4f2ee&clientId=uaef691d9-ff29-4&from=paste&height=353&id=ucf32a376&originHeight=355&originWidth=772&originalType=binary&ratio=1&rotation=0&showTitle=false&size=131661&status=done&style=none&taskId=uc81f1dcc-4497-460b-8b57-1620bf43aa6&title=&width=768" alt="image.png"></p></li><li><p>State：是一个接口，封装了状态及其行为</p></li><li><p>ConcreteState X：State的实现类，表示具体的状态</p></li><li><p>Context：保持并切换各个状态，其持有一个State的引用。它将依赖状态的各种操作委托给不同的状态对象执行。其负责与客户端交互</p></li></ul><ol start="2"><li><strong>【使用场景】：</strong></li></ol><ul><li>打篮球的时候运动员可以有正常状态、不正常状态和超常状态。</li><li>曾侯乙编钟中，’钟是抽象接口’,’钟A’等是具体状态，’曾侯乙编钟’是具体环境（Context）。</li></ul><ol start="3"><li><strong>【优缺点】：</strong></li></ol><ul><li><strong>优点：</strong><ul><li>【增强了程序的可扩展性】因为我们很容易添加一个State</li><li>【增强了程序的封装性】每个状态的操作都被封装到了一个状态类中</li></ul></li><li><strong>缺点：</strong><ul><li>【系统复杂度增加】类变多了</li></ul></li></ul><ol start="4"><li><strong>【特点】：</strong></li></ol><p>商品库存中心有个最基本的需求是减库存和补库存。<br>核心在于，我们的关注点不再是 Context 是该进行哪种操作，而是关注在这个 Context 会有哪些操作。<br>定义状态接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAction</span><span class="params">(Context context)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义减库存的状态：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeductState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAction</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;商品卖出，准备减库存&quot;</span>);</span><br><span class="line">        context.setState(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... 执行减库存的具体操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Deduct State&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义补库存状态：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RevertState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAction</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;给此商品补库存&quot;</span>);</span><br><span class="line">        context.setState(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... 执行加库存的具体操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Revert State&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面用到了 context.setState(this)，我们来看看怎么定义 Context 类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(State state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看下客户端调用，大家就一清二楚了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 我们需要操作的是 iPhone X</span></span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="string">&quot;iPhone X&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 看看怎么进行补库存操作</span></span><br><span class="line">  <span class="type">State</span> <span class="variable">revertState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RevertState</span>();</span><br><span class="line">  revertState.doAction(context);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 同样的，减库存操作也非常简单</span></span><br><span class="line">  <span class="type">State</span> <span class="variable">deductState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeductState</span>();</span><br><span class="line">  deductState.doAction(context);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果需要我们可以获取当前的状态</span></span><br><span class="line">    <span class="comment">// context.getState().toString();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读者可能会发现，在上面这个例子中，如果我们不关心当前 context 处于什么状态，那么 Context 就可以不用维护 state 属性了，那样代码会简单很多。<br>不过，商品库存这个例子毕竟只是个例，我们还有很多实例是需要知道当前 context 处于什么状态的。</p><h2 id="4-6-访问者模式"><a href="#4-6-访问者模式" class="headerlink" title="4.6 访问者模式"></a>4.6 访问者模式</h2><blockquote><p>您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。</p></blockquote><ol><li><strong>【概念】：</strong>用于封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688808261187-6e31e012-8e23-4d85-9bc3-40c15ce8abc6.png#averageHue=%232f2a2d&clientId=uaef691d9-ff29-4&from=paste&height=362&id=uc4470929&originHeight=362&originWidth=1200&originalType=binary&ratio=1&rotation=0&showTitle=false&size=67959&status=done&style=none&taskId=ubfd48018-a562-491f-9f84-c38ff5eaf03&title=&width=1200" alt="image.png"></p><ul><li><strong>类图</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/webp/35382725/1688804819908-dc40c552-9b87-41bb-a01b-f26dbf6a40fe.webp#averageHue=%23f4f4f4&clientId=uaef691d9-ff29-4&from=drop&height=410&id=u3942a4fe&originHeight=462&originWidth=590&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18802&status=done&style=none&taskId=ue77514e6-2011-482c-94f1-f719a2e8087&title=&width=524" alt="v2-4ad3e0b3c15d542518aa433ed9a8c640_720w.webp"></p><ul><li>抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。</li><li>具体主题（Concrete Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</li><li>抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。</li><li>具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。</li></ul><ol start="2"><li><strong>【使用场景】：</strong></li></ol><ul><li>JDK：Files 类提供了 walkFileTree() 方法，该方法可以很容易的对目录下的所有文件进行遍历，需要 Path、FileVisitor 两个参数。其中，Path 是要遍历文件的路径，FileVisitor 则可以看成一个文件访问器。</li><li>Spring：PropertySourcesPlaceholderConfigurer 允许我们用 Properties 文件中的属性来定义应用上下文。</li></ul><ol start="3"><li><strong>【优缺点】：</strong></li></ol><ul><li><strong>优点：</strong><ul><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li><li>目标与观察者之间建立了一套触发机制。</li></ul></li><li><strong>缺点：</strong><ul><li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</li><li>【影响程序的效率】当观察者对象很多时，通知的发布会花费很多时间。</li></ul></li></ul><ol start="4"><li><strong>【特点】：</strong><blockquote><p>精髓：传入一个对象，在我们这里调用该对象的方法，而该方法会把this指针传进去</p></blockquote></li></ol><ul><li><p>传入访问者，遍历元素调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体元素类, 用于访问者访问</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ElementA</span> <span class="keyword">implements</span> <span class="title class_">IElement</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ElementA</span><span class="params">(String name)</span> &#123;  <span class="built_in">this</span>.name = name;  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 接受访问者访问自己  */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(IVisitor visitor)</span> &#123;</span><br><span class="line">        visitor.viewElementA(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;   <span class="keyword">return</span> name; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体访问者类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 具体访问者类, 用于访问元素 **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisitorA</span> <span class="keyword">implements</span>  <span class="title class_">IVisitor</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">viewElementA</span><span class="params">(ElementA elementA)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A访问者 访问 A元素: &quot;</span> + elementA.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">viewElementB</span><span class="params">(ElementB elementB)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A访问者 访问 B元素: &quot;</span> + elementB.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ElementStructure</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;IElement&gt; listElement = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addElement</span><span class="params">(IElement element)</span> &#123;</span><br><span class="line">        lstElement.add(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(IVisitor visitor)</span> &#123;<span class="comment">// 传入访问者</span></span><br><span class="line">        <span class="keyword">for</span> (IElement element : listElement) &#123;</span><br><span class="line">            element.accept(visitor);<span class="comment">//visitor.viewElementA(this);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-7-中介者模式"><a href="#4-7-中介者模式" class="headerlink" title="4.7 中介者模式"></a>4.7 中介者模式</h2><blockquote><p>机场调度系统</p></blockquote><ol><li><strong>【概念】：</strong>中介者模式是一种行为设计模式，能让你减少对象之间混乱无序的依赖关系。该模式会限制对象之间的直接交互，迫使它们通过一个中介者对象进行合作。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688808425055-fee581a2-6079-4f99-803f-469386d2ae84.png#averageHue=%23343433&clientId=uaef691d9-ff29-4&from=paste&height=339&id=u7c0505a6&originHeight=610&originWidth=924&originalType=binary&ratio=1&rotation=0&showTitle=false&size=125750&status=done&style=none&taskId=ue026bcfe-c297-4425-be0e-531878a031a&title=&width=514" alt="image.png"></p><ul><li><strong>类图：</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/35382725/1688806511654-dee5a8f7-9805-4267-94d2-acd64139ab01.jpeg#averageHue=%23eeeeee&clientId=uaef691d9-ff29-4&from=drop&id=u643045a2&originHeight=375&originWidth=690&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43123&status=done&style=none&taskId=u709d76c2-faef-467c-a2ff-b60229a8aa2&title=" alt="v2-2757530b097845dd5d611dddfb5b5697_b.jpg"></p><ul><li>抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</li><li>具体中介者（Concrete Mediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。</li><li>抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</li><li>具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</li></ul><ol start="2"><li><strong>【使用场景】：</strong></li></ol><ul><li>JDK源码中的Timer类：我们任意查看其中的几个schedule方法，所有的task都放入了Timer类中维护的task队列中。所以Timer就是充当了一个中介者的角色，而task队列内的任务就是具体同事对象。</li></ul><ol start="3"><li><strong>【优缺点】：</strong></li></ol><ul><li><strong>优点：</strong><ul><li>【可扩展性】将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。</li><li>【符合迪米特法则】类之间各司其职。</li><li>【降低对象之间的耦合性】使得对象易于独立地被复用。</li></ul></li><li><strong>缺点：</strong><ul><li>中介者模式将原本多个对象直接的相互依赖变成了中介者和多个同事类的依赖关系。当同事类越多时，中介者就会越臃肿，变得复杂且难以维护。</li></ul></li></ul><ol start="4"><li><strong>【特点】：</strong></li></ol><ul><li><p>首先设计子系统</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子系统Light</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Light</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> Srtring position;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Light</span><span class="params">(String postion)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.position = position;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="built_in">this</span>.positioin + <span class="string">&quot;灯打开！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="built_in">this</span>.positioin + <span class="string">&quot;灯关闭！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="comment">//子系统Fan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fan</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="built_in">this</span>.positioin + <span class="string">&quot;风扇打开！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="built_in">this</span>.positioin + <span class="string">&quot;风扇关闭！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子系统AirCondition</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AirCondition</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="built_in">this</span>.positioin + <span class="string">&quot;空调打开！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="built_in">this</span>.positioin + <span class="string">&quot;空调关闭！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子系统TV</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TV</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="built_in">this</span>.positioin + <span class="string">&quot;电视打开！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="built_in">this</span>.positioin + <span class="string">&quot;电视关闭！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>外观类统一管理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//外观类GeneralSwitchFacade</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GeneralSwitchFacade</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> Light lights[] = <span class="keyword">new</span> <span class="title class_">Light</span>[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">private</span> Fan fan;</span><br><span class="line"><span class="keyword">private</span> AirCondition ac;</span><br><span class="line"><span class="keyword">private</span> TV tv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">GeneralSwitchFacade</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">lights[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Light</span>(<span class="string">&quot;左前&quot;</span>);</span><br><span class="line">lights[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Light</span>(<span class="string">&quot;右前&quot;</span>);</span><br><span class="line">lights[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Light</span>(<span class="string">&quot;左后&quot;</span>);</span><br><span class="line">lights[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Light</span>(<span class="string">&quot;右后&quot;</span>);</span><br><span class="line">fan = <span class="keyword">new</span> <span class="title class_">Fan</span>();</span><br><span class="line">ac = <span class="keyword">new</span> <span class="title class_">AirCondition</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">lights[<span class="number">0</span>].on();</span><br><span class="line">lights[<span class="number">1</span>].on();</span><br><span class="line">lights[<span class="number">2</span>].on();</span><br><span class="line">lights[<span class="number">3</span>].on();</span><br><span class="line">fan.on();</span><br><span class="line">ac.on();</span><br><span class="line">tv.on();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">lights[<span class="number">0</span>].off();</span><br><span class="line">lights[<span class="number">1</span>].off();</span><br><span class="line">lights[<span class="number">2</span>].off();</span><br><span class="line">lights[<span class="number">3</span>].off();</span><br><span class="line">fan.off();</span><br><span class="line">ac.off();</span><br><span class="line">tv.off();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">&#123;</span><br><span class="line">         <span class="type">GeneralSwitchFacade</span> <span class="variable">gsf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeneralSwitchFacade</span>();</span><br><span class="line">         gsf.on();</span><br><span class="line">         gsf.off();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码非常简洁，子系统的各类交互逻辑都封装在外观类，客户只需要对接好封装的on方法和off方法。</p></li></ul><h2 id="4-8-命令模式"><a href="#4-8-命令模式" class="headerlink" title="4.8 命令模式"></a>4.8 命令模式</h2><blockquote><p>打开电视机、关闭电视机和切换频道。</p></blockquote><ol><li><strong>【概念】：</strong>它可将请求转换为一个包含与请求相关的所有信息的独立对象。该转换让你能根据不同的请求将方法参数化、延迟请求执行或将其放入<strong>队列</strong>中，且能实现可撤销操作。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688799198055-48d1238e-4faa-4288-a599-09e782bd68d9.png#averageHue=%23262525&clientId=uaef691d9-ff29-4&from=paste&height=426&id=u2afa3931&originHeight=426&originWidth=1137&originalType=binary&ratio=1&rotation=0&showTitle=false&size=105836&status=done&style=none&taskId=uf7341643-8977-4760-a9ab-6507aa2bcdf&title=&width=1137" alt="image.png"></p><ul><li><strong>类图</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/gif/35382725/1688799459219-2ddc766f-ec2d-4540-aa45-43e7e05cb4d3.gif#averageHue=%23f3f3f3&clientId=uaef691d9-ff29-4&from=drop&height=485&id=V1pqf&originHeight=612&originWidth=550&originalType=binary&ratio=1&rotation=0&showTitle=false&size=30549&status=done&style=none&taskId=ue35d22eb-f0ae-440f-8023-2b22e104bd1&title=&width=436" alt="aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xODExMTYvMy0xUTExNjExMzM1RTQ0LmdpZg.gif"></p><ul><li>抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()。</li><li>具体命令角色（Concrete Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。</li><li>实现者&#x2F;接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。</li><li>调用者&#x2F;请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。</li></ul><ol start="2"><li><strong>【使用场景】：</strong></li></ol><ul><li>现实语义中存在具备“命令”的操作，如：dos命令，shell命令。</li><li>请求调用者和请求的接收者需要解耦，使得调用者和接收者不直接互相调用。</li><li>需要抽象出等待执行的行为，比如撤销和和恢复等操作。</li><li>需要支持命令宏(即命令组合)操作。</li></ul><ol start="3"><li><strong>【优缺点】：</strong></li></ol><ul><li><strong>优点：</strong><ul><li>【降低系统的耦合度】命令模式能将调用操作的对象与实现该操作的对象解耦；</li><li>【满足开闭原则】增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类；</li><li>【可以实现宏命令】命令模式与组合模式结合，将多个命令装配成一个组合命令，即宏命令；</li><li>【方便实现 Undo 和 Redo 操作】命令模式与备忘录模式结合，实现命令的撤销与恢复。</li></ul></li><li><strong>缺点：</strong><ul><li>【可能产生大量具体命令类】因为计对每一个具体操作都需要设计一个具体命令类，这将增加系统的复杂性。</li></ul></li></ul><ol start="4"><li><strong>【特点】：</strong></li></ol><ul><li><p>调用者Invoker</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Invoker</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Invoker</span><span class="params">(Command command)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.command=command;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommand</span><span class="params">(Command command)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.command=command;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用者执行命令command...&quot;</span>);</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象命令Command</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体命令ConcreteCommand</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line">    ConcreteCommand()</span><br><span class="line">    &#123;</span><br><span class="line">        receiver=<span class="keyword">new</span> <span class="title class_">Receiver</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        receiver.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接收者Receiver</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Receiver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收者的action()方法被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-9-备忘录模式"><a href="#4-9-备忘录模式" class="headerlink" title="4.9 备忘录模式"></a>4.9 <strong>备忘录模式</strong></h2><blockquote><p>打游戏时的存档；数据库的事务管理。</p></blockquote><ol><li><strong>【概念】：</strong>在不破坏封装的前提下，捕获一个对象的内部状态，并在对象之外保存这个状态，这样我们就可以在需要的时候将该对象恢复到原先保存的状态了，备忘录模式属于行为型模式。【回滚机制】</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688809308802-1622dcf1-b155-4601-afad-28744b85ee7e.png#averageHue=%234f4e50&clientId=uaef691d9-ff29-4&from=paste&height=216&id=uade8e3e6&originHeight=268&originWidth=743&originalType=binary&ratio=1&rotation=0&showTitle=false&size=52222&status=done&style=none&taskId=uca795727-2bdd-4d06-ab6b-f2f277813cc&title=&width=599" alt="image.png"></p><ul><li><strong>类图</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688803549180-2ea1653b-825c-42c4-b3cc-ba53e983d801.png#averageHue=%23706e70&clientId=uaef691d9-ff29-4&from=paste&height=517&id=h3j3Y&originHeight=517&originWidth=813&originalType=binary&ratio=1&rotation=0&showTitle=false&size=163387&status=done&style=none&taskId=u9bdea211-37d8-4ded-bdd3-1911213d8af&title=&width=813" alt="image.png"></p><ul><li>发起人角色(Originator)：负责创建一个备忘录，记录自身需要保存的状态，而且需要具备状态的回滚功能。</li><li>备忘录角色(Memento)：用于存储Originator角色的内部状态，且可以防止Originator以外的对象进行访问。</li><li>备忘录管理员角色(Caretaker)：负责存储，管理备忘录功能。且其本身应该无法对备忘录的内容进行访问。</li></ul><ol start="2"><li><strong>【使用场景】：</strong></li></ol><ul><li>Spring中的spring-webflow包的类StateManageableMessageContext</li></ul><ol start="3"><li><strong>【优缺点】：</strong></li></ol><ul><li><strong>优点：</strong><ul><li>简化了发起人的的职责，将状态的存储和获取进行了隔离，而且客户端无需关心状态的保存细节。</li></ul></li><li><strong>缺点：</strong><ul><li>消耗资源，如果每个快照的内容都非常大，会消耗大量内存。</li></ul></li></ul><ol start="4"><li><strong>【特点】：</strong></li></ol><p>下面我们就以常见的富文本编辑器来编辑文章的功能为例来写一个简单的示例来看看备忘录模式是如何实现的。</p><ul><li><p>首先建立一个类来保存最新文章信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwx.design.pattern.memento;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArticleText</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArticleText</span><span class="params">(String title, String content, Date createTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">        <span class="built_in">this</span>.createTime = createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTitle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTitle</span><span class="params">(String title)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getCreateTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCreateTime</span><span class="params">(Date createTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.createTime = createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArticleMemento <span class="title function_">saveToMemento</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ArticleMemento</span> <span class="variable">articleMemento</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArticleMemento</span>(<span class="built_in">this</span>.title,<span class="built_in">this</span>.content,<span class="built_in">this</span>.createTime);</span><br><span class="line">        <span class="keyword">return</span> articleMemento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getArticleFromMemento</span><span class="params">(ArticleMemento articleMemento)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.title = articleMemento.getTitle();</span><br><span class="line">        <span class="built_in">this</span>.content = articleMemento.getContent();</span><br><span class="line">        <span class="built_in">this</span>.createTime = articleMemento.getCreateTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意：这里面除了getter&#x2F;setter方法之外还有一个方法用来备份，一个方法用来还原。</p></li><li><p>建立一个类用来保存历史数据，这个类的信息必须要和原始类一样，否则无法完全备份：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwx.design.pattern.memento;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArticleMemento</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArticleMemento</span><span class="params">(String title, String content, Date createTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">        <span class="built_in">this</span>.createTime = createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTitle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTitle</span><span class="params">(String title)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getCreateTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCreateTime</span><span class="params">(Date createTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.createTime = createTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后还需要一个类来管理历史快照信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwx.design.pattern.memento;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArticleCaretaker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ArticleMemento&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArticleMemento <span class="title function_">getArticle</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setArticle</span><span class="params">(ArticleMemento articleMemento)</span>&#123;</span><br><span class="line">        list.add(articleMemento);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后来一个测试类测试一下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwx.design.pattern.memento;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMemento</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArticleCaretaker</span> <span class="variable">articleCaretaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArticleCaretaker</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">ArticleText</span> <span class="variable">articleText</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArticleText</span>(<span class="string">&quot;标题1&quot;</span>,<span class="string">&quot;内容1&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="type">ArticleMemento</span> <span class="variable">articleMemento</span> <span class="operator">=</span> articleText.saveToMemento();</span><br><span class="line">        articleCaretaker.setArticle(articleMemento);<span class="comment">//备忘1次</span></span><br><span class="line"></span><br><span class="line">        articleText = <span class="keyword">new</span> <span class="title class_">ArticleText</span>(<span class="string">&quot;标题2&quot;</span>,<span class="string">&quot;内容2&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;修改后的标题为【%s】，内容为【%s】&quot;</span>,articleText.getTitle(),articleText.getContent()));</span><br><span class="line"></span><br><span class="line">        articleText.getArticleFromMemento(articleCaretaker.getArticle(<span class="number">0</span>));</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;还原后的标题为【%s】，内容为【%s】&quot;</span>,articleText.getTitle(),articleText.getContent()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>结果：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修改后的标题为【标题<span class="number">2</span>】，内容为【内容<span class="number">2</span>】</span><br><span class="line">还原后的标题为【标题<span class="number">1</span>】，内容为【内容<span class="number">1</span>】</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-10-迭代器模式【-】"><a href="#4-10-迭代器模式【-】" class="headerlink" title="4.10 迭代器模式【*】"></a>4.10 迭代器模式【*】</h2><blockquote><p>Java中的iterator</p></blockquote><ol><li><strong>【概念】：</strong>迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。</li></ol><p>提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。</p><ul><li><strong>类图</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688802998917-fbd3e0e8-788d-4a16-9f03-64dd106bef1d.png#averageHue=%23717171&clientId=uaef691d9-ff29-4&from=paste&height=592&id=EzZDp&originHeight=592&originWidth=756&originalType=binary&ratio=1&rotation=0&showTitle=false&size=104856&status=done&style=none&taskId=u82b40184-15c1-4781-b007-5c7afe19f15&title=&width=756" alt="image.png"></p><ul><li>Iterator（抽象迭代器）：它定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法，例如：用于获取第一个元素的first()方法，用于访问下一个元素的next()方法，用于判断是否还有下一个元素的hasNext()方法，用于获取当前元素的currentItem()方法等，在具体迭代器中将实现这些方法。</li><li>ConcreteIterator（具体迭代器）：它实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置，在具体实现时，游标通常是一个表示位置的非负整数。</li><li>IterableCollection（抽象聚合类）：它用于存储和管理元素对象，声明一个createIterator()方法用于创建一个迭代器对象，充当抽象迭代器工厂角色。</li><li>ConcreteCollection（具体聚合类）：它实现了在抽象聚合类中声明的createIterator()方法，该方法返回一个与该具体聚合类对应的具体迭代器ConcreteIterator实例。</li></ul><ol start="2"><li><strong>【使用场景】：</strong><a href="https://blog.csdn.net/qq_36970993/article/details/112156234">迭代器模式在JDK以及MyBatis源码中的应用</a></li></ol><ul><li><p>Java集合中的迭代器模式：<strong>new ArrayList&lt;&gt;().iterator();</strong></p><ul><li>最重要的两个方法是hasNext()和next()<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Mybatis中的迭代器模式</p></li></ul><ol start="3"><li><strong>【优缺点】：</strong></li></ol><ul><li><strong>优点：</strong><ul><li>它支持以不同的方式遍历一个聚合对象。</li><li>迭代器简化了聚合类。</li><li>在同一个聚合上可以有多个遍历。</li><li>在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。</li></ul></li><li><strong>缺点：</strong><ul><li>增加了类的个数，这在一定程度上增加了系统的复杂性。</li></ul></li></ul><ol start="4"><li><strong>【特点】：</strong></li></ol><p>我们来实现一个学生报数的示例</p><ul><li><p>定义一个学生类，有一个报数方法 count()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, Integer number)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">count</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;我是 %d 号 %s&quot;</span>, <span class="built_in">this</span>.number, <span class="built_in">this</span>.name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义班级接口和班级类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentAggregate</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addStudent</span><span class="params">(Student student)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeStudent</span><span class="params">(Student student)</span>;</span><br><span class="line"></span><br><span class="line">    StudentIterator <span class="title function_">getStudentIterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentAggregateImpl</span> <span class="keyword">implements</span> <span class="title class_">StudentAggregate</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; list;  <span class="comment">// 学生列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StudentAggregateImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addStudent</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list.add(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeStudent</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list.remove(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> StudentIterator <span class="title function_">getStudentIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentIteratorImpl</span>(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义迭代器接口并实现迭代器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentIterator</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hashNext</span><span class="params">()</span>;</span><br><span class="line">    Student <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentIteratorImpl</span> <span class="keyword">implements</span> <span class="title class_">StudentIterator</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; list;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Student currentStudent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StudentIteratorImpl</span><span class="params">(List&lt;Student&gt; list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hashNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> position &lt; list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        currentStudent = list.get(position);</span><br><span class="line">        position ++;</span><br><span class="line">        <span class="keyword">return</span> currentStudent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试，进行报数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StudentAggregate</span> <span class="variable">classOne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentAggregateImpl</span>();</span><br><span class="line">        classOne.addStudent(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">1</span>));</span><br><span class="line">        classOne.addStudent(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">2</span>));</span><br><span class="line">        classOne.addStudent(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">3</span>));</span><br><span class="line">        classOne.addStudent(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;赵六&quot;</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历，报数</span></span><br><span class="line">        <span class="type">StudentIterator</span> <span class="variable">iterator</span> <span class="operator">=</span> classOne.getStudentIterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hashNext())&#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            student.count();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我是 <span class="number">1</span> 号 张三</span><br><span class="line">我是 <span class="number">2</span> 号 李四</span><br><span class="line">我是 <span class="number">3</span> 号 王五</span><br><span class="line">我是 <span class="number">4</span> 号 赵六</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-11-解释器模式"><a href="#4-11-解释器模式" class="headerlink" title="4.11 解释器模式"></a>4.11 解释器模式</h2><blockquote><p>编译器、运算表达式计算</p></blockquote><ol><li><strong>【概念】：</strong>提供了评估语言的语法或表达式的方式，这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。</li></ol><ul><li><strong>定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的”语言”是指使用规定格式和语法的代码。解释器模式是一种类行为型模式。</strong></li><li><strong>解释过程</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688805322718-de60b843-ca56-4045-a031-d087d4ac4058.png#averageHue=%23e7ecec&clientId=uaef691d9-ff29-4&from=paste&height=175&id=MZdBi&originHeight=175&originWidth=1184&originalType=binary&ratio=1&rotation=0&showTitle=false&size=128339&status=done&style=none&taskId=u60df0928-679e-46ae-83ef-d43334453ac&title=&width=1184" alt="image.png"></p><ul><li><strong>类图</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688805219233-88da67ab-8478-4b5c-9bda-b8f992e53bab.png#averageHue=%23353437&clientId=uaef691d9-ff29-4&from=paste&height=695&id=XGWIx&originHeight=695&originWidth=1356&originalType=binary&ratio=1&rotation=0&showTitle=false&size=188959&status=done&style=none&taskId=u75858de3-cd07-46ee-8eca-ee760af22bf&title=&width=1356" alt="image.png"></p><ul><li>上下文环境(Context)：包含解释器之外的全局信息。一般用来存放文法中各个终结符所对应的具体值；</li><li>抽象表达式(AbstractExpression)：一般会定义一个解释方法，具体如何解析会交由子类进行实现(如示例中的IExpression)；</li><li>终结符表达式(Terminal Expression)：实现文法中与终结符有关的解释操作(如示例中的AddExpression,SubExpression)；</li><li>非终符结表达式(NonTerminal Expression)：实现文法中与非终结符有关的解释操作(如示例中的NumberExpression)；</li></ul><ol start="2"><li><strong>【使用场景】：</strong></li></ol><ul><li>JDK中的正则表达式：Pattern类；</li><li>Spring里面的ExpressionParse接口；</li><li>作为解释器的模板，帮助我们生成解释器（类似：加减运算解释器）</li></ul><ol start="3"><li><strong>【优缺点】：</strong></li></ol><ul><li><strong>优点：</strong><ul><li>可扩展性比较好，灵活；</li><li>增加了新的解释表达式的方式；</li><li>易于实现简单文法。</li></ul></li><li><strong>缺点：</strong><ul><li>当文法规则比较复杂时，会引起类膨胀，比较难维护；</li><li>当文法规则比较复杂时，如果出错了，调试比较困难；</li><li>执行效率比较低下。因为当表达式比较复杂，结果层层依赖的话会采用递归方式进行解析；</li></ul></li></ul><ol start="4"><li><strong>【特点】：</strong></li></ol><p>下面我们就以简单的加减法表达式类简单写一个示例：</p><ul><li><p>首先建立一个顶层的表达式接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwx.design.pattern.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IExpression</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">interpret</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义一个抽象的非终结表达式(比如加号和减号这种就属于非终结表达式)：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwx.design.pattern.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非终结表达式-抽象表达式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractNonTerminalExpression</span> <span class="keyword">implements</span> <span class="title class_">IExpression</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> IExpression leftExpression;</span><br><span class="line">    <span class="keyword">protected</span> IExpression rightExpression;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractNonTerminalExpression</span><span class="params">(IExpression leftExpression, IExpression rightExpression)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.leftExpression = leftExpression;</span><br><span class="line">        <span class="built_in">this</span>.rightExpression = rightExpression;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>因为本次示例中只列举加法和减法，所以我们还需要一个加法类和一个减法类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwx.design.pattern.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非终结表达式-具体表达式-加法表达式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddExpression</span> <span class="keyword">extends</span> <span class="title class_">AbstractNonTerminalExpression</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AddExpression</span><span class="params">(IExpression leftExpression, IExpression rightExpression)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(leftExpression, rightExpression);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.leftExpression.interpret() + <span class="built_in">this</span>.rightExpression.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwx.design.pattern.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非终结表达式-具体表达式-减法表达式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubExpression</span> <span class="keyword">extends</span> <span class="title class_">AbstractNonTerminalExpression</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubExpression</span><span class="params">(IExpression leftExpression, IExpression rightExpression)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(leftExpression, rightExpression);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.leftExpression.interpret() - <span class="built_in">this</span>.rightExpression.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>再建立一个终结表达式(如加减法运算中的数值)：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwx.design.pattern.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 终结表达式-数值表达式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberExpression</span> <span class="keyword">implements</span> <span class="title class_">IExpression</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumberExpression</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = Integer.valueOf(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后我们还需要一个上下文信息来存储我们的运算结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwx.design.pattern.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExpressionContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer currValue;<span class="comment">//记录当前运算结果，空表示暂未运算</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;IExpression&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExpressionContext</span><span class="params">(String expression)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.parse(expression);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(String expression)</span> &#123;</span><br><span class="line">        String[] elementArr = expression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;elementArr.length;i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> elementArr[i];</span><br><span class="line">            <span class="keyword">if</span> (element.equals(<span class="string">&quot;+&quot;</span>))&#123;</span><br><span class="line">                <span class="type">IExpression</span> <span class="variable">leftExpression</span> <span class="operator">=</span> stack.pop();<span class="comment">//栈内元素出栈</span></span><br><span class="line">                <span class="type">IExpression</span> <span class="variable">rightExpression</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumberExpression</span>(elementArr[++i]);<span class="comment">//取出+号后的下一个元素</span></span><br><span class="line">                <span class="type">IExpression</span> <span class="variable">addExpression</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddExpression</span>(leftExpression,rightExpression);</span><br><span class="line">                stack.push(<span class="keyword">new</span> <span class="title class_">NumberExpression</span>(addExpression.interpret() + <span class="string">&quot;&quot;</span>));<span class="comment">//将计算结果入栈</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (element.equals(<span class="string">&quot;-&quot;</span>))&#123;</span><br><span class="line">                <span class="type">IExpression</span> <span class="variable">leftExpression</span> <span class="operator">=</span> stack.pop();<span class="comment">//栈内元素出栈</span></span><br><span class="line">                <span class="type">IExpression</span> <span class="variable">rightExpression</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumberExpression</span>(elementArr[++i]);<span class="comment">//取出-号后的下一个元素</span></span><br><span class="line">                <span class="type">IExpression</span> <span class="variable">subExpression</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubExpression</span>(leftExpression,rightExpression);</span><br><span class="line">                stack.push(<span class="keyword">new</span> <span class="title class_">NumberExpression</span>(subExpression.interpret() + <span class="string">&quot;&quot;</span>));<span class="comment">//将计算结果入栈</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(<span class="keyword">new</span> <span class="title class_">NumberExpression</span>(element));<span class="comment">//如果是数字则直接入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calcuate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.pop().interpret();<span class="comment">//经过前面解析，到这里stack内只会剩下唯一一个数字，即运算结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后新建一个测试类来测试一下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwx.design.pattern.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInterpreter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExpressionContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExpressionContext</span>(<span class="string">&quot;666 + 888 - 777&quot;</span>);</span><br><span class="line">        System.out.println(context.calcuate());</span><br><span class="line">        context = <span class="keyword">new</span> <span class="title class_">ExpressionContext</span>(<span class="string">&quot;123 - 456 + 11&quot;</span>);</span><br><span class="line">        System.out.println(context.calcuate());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行结果为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">777</span></span><br><span class="line">-<span class="number">322</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;面试题：&lt;a href=&quot;https://blog.csdn.net/qq_30999361/article/details/124637874&quot;&gt;设计模式面试题（14道含答案）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;目标：掌握常见的设计模式，包括单例模式、工厂模式、装饰器</summary>
      
    
    
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JUC并发编程</title>
    <link href="http://example.com/2024/01/18/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2024/01/18/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</id>
    <published>2024-01-18T03:00:43.042Z</published>
    <updated>2024-01-18T03:09:50.128Z</updated>
    
    <content type="html"><![CDATA[<ul><li>面试题：<a href="https://blog.csdn.net/qq_30999361/article/details/124545403">Java并发编程面试题（123道含答案）</a></li></ul><p><a href="https://pdai.tech/md/java/thread/java-thread-x-juc-overview.html">JUC - 类汇总和学习指南</a></p><h1 id="1、Locks-锁"><a href="#1、Locks-锁" class="headerlink" title="1、Locks 锁"></a>1、Locks 锁</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696994312722-08a830ea-3580-4cb7-ae08-fa458b1da016.png#averageHue=%23f0ecec&clientId=ud6f5435f-a1f8-4&from=paste&height=457&id=u37ebfb29&originHeight=571&originWidth=1007&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=118568&status=done&style=none&taskId=ud5ca5b42-025a-4a7c-bdba-ba243e6386e&title=&width=805.6" alt="image.png"></p><h2 id="1-1-Lock接口"><a href="#1-1-Lock接口" class="headerlink" title="1.1 Lock接口"></a>1.1 Lock接口</h2><h2 id="1-2-ReentrantLock-重入锁"><a href="#1-2-ReentrantLock-重入锁" class="headerlink" title="1.2 ReentrantLock 重入锁"></a>1.2 ReentrantLock 重入锁</h2><h2 id="1-3-ReadWriteLock-读写锁"><a href="#1-3-ReadWriteLock-读写锁" class="headerlink" title="1.3 ReadWriteLock 读写锁"></a>1.3 ReadWriteLock 读写锁</h2><h2 id="1-4-Condition"><a href="#1-4-Condition" class="headerlink" title="1.4 Condition"></a>1.4 Condition</h2><h2 id="1-5-LockSupport"><a href="#1-5-LockSupport" class="headerlink" title="1.5 LockSupport"></a>1.5 LockSupport</h2><h2 id="1-6-AQS"><a href="#1-6-AQS" class="headerlink" title="1.6 AQS"></a>1.6 AQS</h2><h1 id="2、Tools-工具类"><a href="#2、Tools-工具类" class="headerlink" title="2、Tools 工具类"></a>2、Tools 工具类</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696994322635-a3a6631b-3bb2-4cad-a832-ac1dd6107ef1.png#averageHue=%23f0ecec&clientId=ud6f5435f-a1f8-4&from=paste&height=457&id=u6666b0c0&originHeight=571&originWidth=1007&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=118568&status=done&style=none&taskId=u3f7f3fed-b002-4978-83ca-ef7f1dbfe3e&title=&width=805.6" alt="image.png"></p><ul><li>标志为绿色的内容</li></ul><h2 id="2-1-CountDownLatch"><a href="#2-1-CountDownLatch" class="headerlink" title="2.1 CountDownLatch"></a>2.1 CountDownLatch</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686474741620-08518dd6-d0e6-4b66-9a06-67a6f13d777e.png#averageHue=%23f6f1f1&clientId=udaf2058c-f549-4&id=LUeC3&originHeight=677&originWidth=1222&originalType=binary&ratio=1&rotation=0&showTitle=false&size=86017&status=done&style=none&taskId=u9d80393e-1e6f-4ac4-a510-a7abc282c8f&title=" alt="image.png"><br><strong>其实就是一个减法计数器，对于计数器归零之后再进行后面的操作，这是一个计数器！</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是一个计数器  减法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//总数是6</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; Go out&quot;</span>);</span><br><span class="line">                countDownLatch.countDown(); <span class="comment">//每个线程都数量-1</span></span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();  <span class="comment">//等待计数器归零  然后向下执行</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;close door&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要方法：</p><ul><li>countDown 减一操作；</li><li>await 等待计数器归零。</li></ul><p>await等待计数器为0，就唤醒，再继续向下运行。</p><h2 id="2-2-CyclickBarrier"><a href="#2-2-CyclickBarrier" class="headerlink" title="2.2 CyclickBarrier"></a>2.2 CyclickBarrier</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686474741624-6d8e53c9-4773-4d3a-be9f-101e33c0c889.png#averageHue=%23f6f3f3&clientId=udaf2058c-f549-4&id=qtOGp&originHeight=206&originWidth=1168&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24223&status=done&style=none&taskId=u91b4ad1e-535e-44dd-a4d2-5c2e5ab4976&title=" alt="image.png"><br>其实就是一个加法计数器；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主线程</span></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">7</span>,()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;召唤神龙~&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//子线程</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 收集了第 &#123;&quot;</span>+ finalI+<span class="string">&quot;&#125; 颗龙珠&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await(); <span class="comment">//加法计数 等待</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-Semaphore"><a href="#2-3-Semaphore" class="headerlink" title="2.3 Semaphore"></a>2.3 Semaphore</h2><p>Semaphore（信号量）：多个共享资源互斥的使用！ 并发限流，控制最大的线程数！<br>抢车位：3个车位 6辆车：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//停车位为3个</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire(); <span class="comment">//得到</span></span><br><span class="line">                    <span class="comment">//抢到车位</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 抢到了车位&#123;&quot;</span>+ finalI +<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>); <span class="comment">//停车2s</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 离开车位&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();<span class="comment">//释放</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:::tips<br><strong>原理：</strong><br>semaphore.acquire()获得资源，如果资源已经使用完了，就等待资源释放后再进行使用！<br>semaphore.release()释放，会将当前的信号量释放+1，然后唤醒等待的线程！<br>:::</p><h1 id="3、Collections-并发集合"><a href="#3、Collections-并发集合" class="headerlink" title="3、Collections 并发集合"></a>3、Collections 并发集合</h1><h2 id="3-1-ConcurrentHashMap"><a href="#3-1-ConcurrentHashMap" class="headerlink" title="3.1 ConcurrentHashMap"></a>3.1 ConcurrentHashMap</h2><h2 id="3-2-CopyOnWriteArrayList"><a href="#3-2-CopyOnWriteArrayList" class="headerlink" title="3.2 CopyOnWriteArrayList"></a>3.2 CopyOnWriteArrayList</h2><h2 id="3-3-BlockingQueue"><a href="#3-3-BlockingQueue" class="headerlink" title="3.3 BlockingQueue"></a>3.3 BlockingQueue</h2><h2 id="3-4-ConcurrentLinkedQueue"><a href="#3-4-ConcurrentLinkedQueue" class="headerlink" title="3.4 ConcurrentLinkedQueue"></a>3.4 ConcurrentLinkedQueue</h2><h2 id="3-5-Fork-Join"><a href="#3-5-Fork-Join" class="headerlink" title="3.5 Fork&#x2F;Join"></a>3.5 Fork&#x2F;Join</h2><p><strong>在JDK1.7中对并发框架进行扩充，引入了java.util.concurrent.forkjoin包。</strong><br><strong>Frok&#x2F;Join模式是处理并行编程的一种经典方法。</strong><br><strong>下面是Fork&#x2F;Join模式的示意图：</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697182246402-8e07aa72-e243-4533-a516-62a8fd1b45ff.png#averageHue=%23e9efe4&clientId=u82ebc67f-374a-4&from=paste&id=uf6f26667&originHeight=216&originWidth=572&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u5b41ed28-dd54-48db-93af-97bbbb59fd7&title="></p><blockquote><p>1、什么是ForkJoin？</p></blockquote><p>ForkJoin 在JDK1.7，并行执行任务！提高效率~。在大数据量速率会更快！<br>大数据中：<strong>MapReduce 核心思想-&gt;把大任务拆分为小任务！</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696999198865-e8f69dca-10bd-4e59-a00d-baace0c620a2.png#averageHue=%23fefffe&clientId=ud6f5435f-a1f8-4&id=xbyQx&originHeight=540&originWidth=590&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u960028e8-f1b9-4a69-b0cd-36b22e32f5c&title="></p><blockquote><p>2、<strong>ForkJoin 特点： 工作窃取！</strong></p></blockquote><p>实现原理是：<strong>双端队列</strong>！从上面和下面都可以去拿到任务进行执行！<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696999198860-1aeee17e-68d1-4086-86d0-1cf6f55655ed.png#averageHue=%23eff1ef&clientId=ud6f5435f-a1f8-4&id=ntQAX&originHeight=513&originWidth=325&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue5444664-624c-4b0f-bcc1-0ae5cc58fad&title="></p><blockquote><p>3、如何使用ForkJoin?</p></blockquote><ul><li>1、通过<strong>ForkJoinPool</strong>来执行</li><li>2、计算任务 <strong>execute(ForkJoinTask&lt;?&gt; task)</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696999198894-90363f7c-f016-4be1-bd37-09c69064f043.png#averageHue=%23f2f0eb&clientId=ud6f5435f-a1f8-4&id=hOBD4&originHeight=308&originWidth=722&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud2216785-88f6-4466-a9e4-36e902dd3f0&title="></p><ul><li>3、计算类要去继承ForkJoinTask；</li></ul><p><strong>ForkJoin的计算类！</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ogj.forkjoin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinDemo</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> star;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//临界值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> temp=<span class="number">1000000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ForkJoinDemo</span><span class="params">(<span class="type">long</span> star, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.star = star;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Long</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>((end-star)&lt;temp)&#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Long</span> <span class="variable">i</span> <span class="operator">=</span> star; i &lt; end; i++) &#123;</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            System.out.println(sum);</span></span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//使用forkJoin 分而治之 计算</span></span><br><span class="line">            <span class="comment">//计算平均值</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">middle</span> <span class="operator">=</span> (star+ end)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">ForkJoinDemo</span> <span class="variable">forkJoinDemoTask1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(star, middle);</span><br><span class="line">            forkJoinDemoTask1.fork();  <span class="comment">//拆分任务，把线程任务压入线程队列</span></span><br><span class="line">            <span class="type">ForkJoinDemo</span> <span class="variable">forkJoinDemoTask2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(middle, end);</span><br><span class="line">            forkJoinDemoTask2.fork();  <span class="comment">//拆分任务，把线程任务压入线程队列</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">taskSum</span> <span class="operator">=</span> forkJoinDemoTask1.join() + forkJoinDemoTask2.join();</span><br><span class="line">            <span class="keyword">return</span> taskSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试类！</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ogj.forkjoin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.LongStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        test1();</span><br><span class="line">        test2();</span><br><span class="line">        test3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通计算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">star</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">20_0000_0000</span>; i++) &#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span>+<span class="string">&quot;时间：&quot;</span>+(end-star));</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用ForkJoin</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">star</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(<span class="number">0L</span>, <span class="number">20_0000_0000L</span>);</span><br><span class="line">        ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">aLong</span> <span class="operator">=</span> submit.get();</span><br><span class="line">        System.out.println(aLong);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span>+<span class="string">&quot;时间：&quot;</span>+(end-star));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用Stream 并行流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">star</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//Stream并行流()</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> LongStream.range(<span class="number">0L</span>, <span class="number">20_0000_0000L</span>).parallel().reduce(<span class="number">0</span>, Long::sum);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span>+<span class="string">&quot;时间：&quot;</span>+(end-star));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696999198909-28972d4f-5a54-4772-b85f-00df07fae079.png#averageHue=%233b3630&clientId=ud6f5435f-a1f8-4&id=NvnAk&originHeight=279&originWidth=699&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6e858ad1-c7e6-4e4f-85c4-dd56fdc9d2f&title="><br><strong>.parallel().reduce(0, Long::sum)使用一个并行流去计算整个计算，提高效率。</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696999198964-c384a954-a5f4-415d-bd93-a0a3bed04bdd.png#averageHue=%23fbfafa&clientId=ud6f5435f-a1f8-4&id=FAdNk&originHeight=317&originWidth=694&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ucca0d959-a338-438f-8aaf-fe59c010d07&title="><br><strong>reduce方法的优点：</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696999199905-e95e1874-6b08-47ce-be8a-bcdb40726019.png#averageHue=%23fdfbfb&clientId=ud6f5435f-a1f8-4&id=M28c0&originHeight=709&originWidth=1094&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u583cc531-6502-4dd5-a209-13cf7359a0f&title="></p><h1 id="4、Executors-线程池"><a href="#4、Executors-线程池" class="headerlink" title="4、Executors 线程池"></a>4、Executors 线程池</h1><ul><li>建议</li></ul><p><strong>注：线程池这块的拒绝策略、核心参数配置什么的，如果你不了解，实际项目中使用线程池可能就用的不是很明白，容易出现问题。</strong><br>线程池配置无界队列了之后，拒绝策略其实就失去了意义，因为无论有多少任务提交到线程池，都会被放入队列中等待执行，不会触发拒绝策略。不过，这样可能堆积大量的请求，从而导致 OOM。因此，一般不推荐使用误解队列。<br>:::tips<br>假设不是无界队列的话，如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，ThreadPoolTaskExecutor 定义一些拒绝策略:</p><ul><li>ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException来拒绝新任务的处理。</li><li>ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li><li>ThreadPoolExecutor.DiscardPolicy：不处理新任务，直接丢弃掉。</li><li>ThreadPoolExecutor.DiscardOldestPolicy：此策略将丢弃最早的未处理的任务请求。<br>:::</li></ul><h2 id="4-1-Executor"><a href="#4-1-Executor" class="headerlink" title="4.1 Executor"></a>4.1 Executor</h2><h2 id="4-2-ThreadPoolExecutor"><a href="#4-2-ThreadPoolExecutor" class="headerlink" title="4.2 ThreadPoolExecutor"></a>4.2 ThreadPoolExecutor</h2><p><a href="https://zhuanlan.zhihu.com/p/610096853">一文搞懂ThreadPoolExecutor</a></p><h2 id="4-3-FutureTask"><a href="#4-3-FutureTask" class="headerlink" title="4.3 FutureTask"></a>4.3 FutureTask</h2><h1 id="5、Atomic-原子类"><a href="#5、Atomic-原子类" class="headerlink" title="5、Atomic 原子类"></a>5、Atomic 原子类</h1><h2 id="5-1-基本类型"><a href="#5-1-基本类型" class="headerlink" title="5.1 基本类型"></a>5.1 基本类型</h2><h2 id="5-2-Array"><a href="#5-2-Array" class="headerlink" title="5.2 Array"></a>5.2 Array</h2><h2 id="5-3-Reference"><a href="#5-3-Reference" class="headerlink" title="5.3 Reference"></a>5.3 Reference</h2><h2 id="5-4-FieldUpdator"><a href="#5-4-FieldUpdator" class="headerlink" title="5.4 FieldUpdator"></a>5.4 FieldUpdator</h2><h1 id="1、JUC体系结构"><a href="#1、JUC体系结构" class="headerlink" title="1、JUC体系结构"></a>1、JUC体系结构</h1><h2 id="1-1-JUC的概念"><a href="#1-1-JUC的概念" class="headerlink" title="1.1 JUC的概念"></a>1.1 JUC的概念</h2><p>学习方法：源码+官方文档</p><blockquote><p>JUC是 java util concurrent</p></blockquote><ul><li>面试高频问JUC~！</li></ul><p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727195421667.png#id=utfxj&originHeight=398&originWidth=839&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>java.util 是Java的一个工具包~<br><strong>业务：普通的线程代码 Thread</strong><br><strong>Runnable：</strong> 没有返回值、效率相比于<strong>Callable</strong> 相对较低！<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727195447249.png#id=I2ztm&originHeight=886&originWidth=1273&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="1-2-线程和进程"><a href="#1-2-线程和进程" class="headerlink" title="1.2 线程和进程"></a>1.2 线程和进程</h2><blockquote><p>1、概述</p></blockquote><p><strong>进程：一个程序，QQ.EXE Music.EXE；数据+代码+pcb</strong><br>一个进程可以包含多个线程，至少包含一个线程！<br>Java默认有几个线程？<strong>2个线程！</strong> main线程、GC线程<br><strong>线程：开了一个进程Typora，写字，等待几分钟会进行自动保存(线程负责的)</strong><br>对于Java而言：Thread、Runnable、Callable进行开启线程的，我们之前。<br><strong>提问？JAVA真的可以开启线程吗？ 开不了的！</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * This method is not invoked for the main method thread or &quot;system&quot;</span></span><br><span class="line"><span class="comment">        * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">        * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * A zero status value corresponds to state &quot;NEW&quot;.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">        * so that it can be added to the group&#x27;s list of threads</span></span><br><span class="line"><span class="comment">        * and the group&#x27;s unstarted count can be decremented. */</span></span><br><span class="line">       group.add(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">       <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           start0();</span><br><span class="line">           started = <span class="literal">true</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                   group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">               <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                 it will be passed up the call stack */</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//这是一个C++底层，Java是没有权限操作底层硬件的</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>Java是没有权限去开启线程、操作硬件的，这是一个native的一个本地方法，它调用的底层的C++代码。</p><blockquote><p>2、并发、并行</p></blockquote><p><strong>并发：</strong> 多线程操作同一个资源。</p><ul><li>CPU 只有一核，模拟出来多条线程，天下武功，唯快不破。那么我们就可以使用CPU快速交替，来模拟多线程。</li></ul><p><strong>并行：</strong> 多个人一起行走</p><ul><li>CPU多核，多个线程可以同时执行。 我们可以使用线程池！<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取cpu的核数</span></span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>并发编程的本质：<strong>充分利用CPU的资源！</strong></li></ul><blockquote><p>3、线程有几个状态？</p></blockquote><p>线程的状态：6个状态<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686474410156-2c42c511-caa1-47e2-a7ed-0917176b6e4e.png#averageHue=%23f8f6f6&clientId=udaf2058c-f549-4&from=drop&id=u19181597&originHeight=616&originWidth=965&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=173974&status=done&style=none&taskId=uec8f7401-4b38-4e9e-b2b4-94fa8158254&title=" alt="78c61007d62ab122867e5dd437fb4687_r.png"></p><ul><li>Runnable：就绪态</li><li>Blocked：阻塞态</li><li>Running：运行态</li></ul><blockquote><p>4、wait&#x2F;sleep的区别</p></blockquote><p><strong>1、来自不同的类</strong><br>wait &#x3D;&gt; Object<br>sleep &#x3D;&gt; Thread<br>一般情况企业中使用休眠是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TimeUnit.DAYS.sleep(<span class="number">1</span>); <span class="comment">//休眠1天</span></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>); <span class="comment">//休眠1s</span></span><br></pre></td></tr></table></figure><p><strong>2、关于锁的释放</strong><br>wait 会释放锁；<br>sleep睡觉了，不会释放锁；<br><strong>3、使用的范围是不同的</strong><br>wait 必须在同步代码块中；<br>sleep 可以在任何地方睡；<br><strong>4、是否需要捕获异常</strong><br>wait是不需要捕获异常；<br>sleep必须要捕获异常；</p><h1 id="2、锁"><a href="#2、锁" class="headerlink" title="2、锁"></a>2、锁</h1><h2 id="2-1-Lock锁【-】"><a href="#2-1-Lock锁【-】" class="headerlink" title="2.1 Lock锁【*】"></a>2.1 Lock锁【*】</h2><blockquote><p>1、传统的Synchronized</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真正的多线程开发</span></span><br><span class="line"><span class="comment"> * 线程就是一个单独的资源类，没有任何的附属操作！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//多线程操作</span></span><br><span class="line">        <span class="comment">//并发：多线程操作同一个资源类，把资源类丢入线程</span></span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//@FunctionalInterface 函数式接口 jdk1.8之后 lambda表达式</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">40</span>;i++)&#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">40</span>;i++)&#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">40</span>;i++)&#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//资源类</span></span><br><span class="line"><span class="comment">//属性+方法</span></span><br><span class="line"><span class="comment">//oop</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number=<span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//卖票的方式</span></span><br><span class="line">    <span class="comment">// synchronized 本质：队列，锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 卖出了第&quot;</span>+number+<span class="string">&quot; 张票,剩余：&quot;</span>+number+<span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">            number--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2、Lock接口</p></blockquote><p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727195732117.png#id=Mw0g4&originHeight=886&originWidth=1458&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ul><li>接口实现类</li></ul><p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/2020080112041218.png#id=AljRy&originHeight=202&originWidth=905&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ul><li>源码：</li></ul><p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727195818181.png#id=SUKwQ&originHeight=378&originWidth=1014&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>公平锁：</strong> 十分公平，必须先来后到~；<br><strong>非公平锁：</strong> 十分不公平，可以插队；**(默认为非公平锁)**</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//多线程操作</span></span><br><span class="line">        <span class="comment">//并发：多线程操作同一个资源类，把资源类丢入线程</span></span><br><span class="line">        <span class="type">Ticket2</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket2</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">40</span>;i++) ticket.sale(); &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">40</span>;i++) ticket.sale(); &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">40</span>;i++) ticket.sale(); &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lock三部曲</span></span><br><span class="line"><span class="comment">//1、    Lock lock=new ReentrantLock();</span></span><br><span class="line"><span class="comment">//2、    lock.lock() 加锁</span></span><br><span class="line"><span class="comment">//3、    finally=&gt; 解锁：lock.unlock();</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket2</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number=<span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    Lock lock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//卖票的方式</span></span><br><span class="line">    <span class="comment">// 使用Lock 锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//业务代码</span></span><br><span class="line">            <span class="keyword">if</span>(number&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 卖出了第&quot;</span>+number+<span class="string">&quot; 张票,剩余：&quot;</span>+number+<span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">                number--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>3、Synchronized 和 Lock区别</p></blockquote><ul><li>1、Synchronized 内置的Java关键字，Lock是一个Java类 </li><li>2、Synchronized 无法判断获取锁的状态，Lock可以判断 </li><li>3、Synchronized 会自动释放锁，lock必须要手动加锁和手动释放锁！<strong>可能会遇到死锁</strong> </li><li>4、Synchronized 线程1(获得锁-&gt;阻塞)、线程2(等待)；<br>lock就不一定会一直等待下去，<strong>lock会有一个trylock去尝试获取锁</strong>，不会造成长久的等待。 </li><li>5、Synchronized 是可重入锁，不可以中断的，非公平的；Lock，可重入的，可以判断锁，可以自己设置公平锁和非公平锁； </li><li>6、Synchronized 适合锁少量的代码同步问题，Lock适合锁大量的同步代码； <blockquote><p>锁到底是什么？ 如何判断锁的是谁？</p></blockquote></li></ul><p>锁是实现同步互斥的一种机制。</p><h2 id="2-2-公平锁-非公平锁"><a href="#2-2-公平锁-非公平锁" class="headerlink" title="2.2 公平锁&#x2F;非公平锁"></a>2.2 公平锁&#x2F;非公平锁</h2><p><strong>公平锁</strong>：非常公平；不能插队的，必须先来后到；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment"> * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>非公平锁</strong>：非常不公平，允许插队的，可以改变顺序。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment"> * given fairness policy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-可重入锁"><a href="#2-3-可重入锁" class="headerlink" title="2.3 可重入锁"></a>2.3 可重入锁</h2><p>可重入锁(递归锁)<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686474593869-7b554d58-272b-4d80-a9dd-85416afff56a.png#averageHue=%23bcb9b7&clientId=udaf2058c-f549-4&id=RsRYg&originHeight=308&originWidth=519&originalType=binary&ratio=1&rotation=0&showTitle=false&size=49396&status=done&style=none&taskId=ua074200a-f757-459e-bbc1-7596a366736&title=" alt="image.png"></p><blockquote><p>1、Synchronized锁</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sms</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt; sms&quot;</span>);</span><br><span class="line">        call();<span class="comment">//这里也有一把锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt; call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2、lock锁</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//lock</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone2</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone2</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone2</span>&#123;</span><br><span class="line"></span><br><span class="line">    Lock lock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sms</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock(); <span class="comment">//细节：这个是两把锁，两个钥匙</span></span><br><span class="line">        <span class="comment">//lock锁必须配对，否则就会死锁在里面</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt; sms&quot;</span>);</span><br><span class="line">            call();<span class="comment">//这里也有一把锁</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt; call&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>lock锁必须配对，相当于lock和 unlock 必须数量相同；</li><li>在外面加的锁，也可以在里面解锁；在里面加的锁，在外面也可以解锁；</li></ul><h2 id="2-4-自旋锁"><a href="#2-4-自旋锁" class="headerlink" title="2.4 自旋锁"></a>2.4 自旋锁</h2><ul><li>spinlock<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>自我设计自旋锁：</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinlockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int 0</span></span><br><span class="line">    <span class="comment">//thread null</span></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference=<span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myLock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(thread.getName()+<span class="string">&quot;===&gt; mylock&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自旋锁</span></span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="literal">null</span>,thread))&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; ==&gt; 自旋中~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myunlock</span><span class="params">()</span>&#123;</span><br><span class="line">        Thread thread=Thread.currentThread();</span><br><span class="line">        System.out.println(thread.getName()+<span class="string">&quot;===&gt; myUnlock&quot;</span>);</span><br><span class="line">        atomicReference.compareAndSet(thread,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSpinLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ReentrantLock</span> <span class="variable">reentrantLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        reentrantLock.unlock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用CAS实现自旋锁</span></span><br><span class="line">        SpinlockDemo spinlockDemo=<span class="keyword">new</span> <span class="title class_">SpinlockDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            spinlockDemo.myLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                spinlockDemo.myunlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            spinlockDemo.myLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                spinlockDemo.myunlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>运行结果：<br><strong>t2进程必须等待t1进程Unlock后，才能Unlock，在这之前进行自旋等待</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686474594443-68dbe5c6-9e50-460f-a167-64e646713df0.png#averageHue=%233f3831&clientId=udaf2058c-f549-4&id=rq5D1&originHeight=555&originWidth=1759&originalType=binary&ratio=1&rotation=0&showTitle=false&size=837615&status=done&style=none&taskId=u0ffc500d-ff84-4205-8b90-979707ec6c2&title=" alt="image.png"></li></ul><h2 id="2-5-死锁"><a href="#2-5-死锁" class="headerlink" title="2.5 死锁"></a>2.5 死锁</h2><blockquote><p>1、死锁是什么？</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686474593909-c7738312-3c47-4114-bea3-b3d8d9227e12.png#averageHue=%23c4c8c2&clientId=udaf2058c-f549-4&id=d8Aoq&originHeight=226&originWidth=356&originalType=binary&ratio=1&rotation=0&showTitle=false&size=53596&status=done&style=none&taskId=u140ef82d-38a0-4d24-a9cc-af789a43e6f&title=" alt="image.png"><br>死锁测试，怎么排除死锁：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ogj.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String lockA= <span class="string">&quot;lockA&quot;</span>;</span><br><span class="line">        String lockB= <span class="string">&quot;lockB&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>(lockA,lockB),<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>(lockB,lockA),<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lockA;</span><br><span class="line">    <span class="keyword">private</span> String lockB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String lockA, String lockB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lockA = lockA;</span><br><span class="line">        <span class="built_in">this</span>.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; lock&quot;</span>+lockA+<span class="string">&quot;===&gt;get&quot;</span>+lockB);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; lock&quot;</span>+lockB+<span class="string">&quot;===&gt;get&quot;</span>+lockA);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2、解决问题</p></blockquote><p><strong>1、使用jps定位进程号，jdk的bin目录下： 有一个jps</strong><br>命令：<code>jps -l</code><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686474594034-8ac72bce-9b63-4703-8414-2df036fe183b.png#averageHue=%23494239&clientId=udaf2058c-f549-4&id=Jr8GT&originHeight=305&originWidth=856&originalType=binary&ratio=1&rotation=0&showTitle=false&size=210104&status=done&style=none&taskId=u757b59d0-39f4-4e43-80bb-83516a44b22&title=" alt="image.png"><br><strong>2、使用</strong><code>**jstack**</code>** 进程进程号 找到死锁信息**<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686474594325-33d8872c-48d5-4c1c-86e0-b221ada432f5.png#averageHue=%23453e36&clientId=udaf2058c-f549-4&id=QKtMQ&originHeight=660&originWidth=1024&originalType=binary&ratio=1&rotation=0&showTitle=false&size=617200&status=done&style=none&taskId=u79f160c6-a322-4d06-950e-36243da8366&title=" alt="image.png"><br><strong>一般情况信息在最后：</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686474595487-e6e6ff86-d250-4a09-9454-a471180a7a43.png#averageHue=%23493d35&clientId=udaf2058c-f549-4&id=KzHpQ&originHeight=616&originWidth=964&originalType=binary&ratio=1&rotation=0&showTitle=false&size=495542&status=done&style=none&taskId=u114997c2-1ec1-444d-a76e-6c79e047fc7&title=" alt="image.png"></p><h2 id="2-6-读写锁"><a href="#2-6-读写锁" class="headerlink" title="2.6 读写锁"></a>2.6 读写锁</h2><p>先对于不加锁的情况：<br>如果我们做一个我们自己的cache缓存。分别有写入操作、读取操作；<br>我们采用五个线程去写入，使用十个线程去读取。<br>我们来看一下这个的效果，如果我们不加锁的情况！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ogj.rw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyCache_ReadWriteLock</span> <span class="variable">mycache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCache_ReadWriteLock</span>();</span><br><span class="line">        <span class="comment">//开启5个线程 写入数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">5</span> ; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                mycache.put(String.valueOf(finalI),String.valueOf(finalI));</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开启10个线程去读取数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">o</span> <span class="operator">=</span> mycache.get(String.valueOf(finalI));</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCache_ReadWriteLock</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String,String&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用读写锁</span></span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock readWriteLock=<span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="comment">//普通锁</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key,String value)</span>&#123;</span><br><span class="line">        <span class="comment">//写入</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 线程 开始写入&quot;</span>);</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 线程 写入OK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        <span class="comment">//得到</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 线程 开始读取&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">o</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 线程 读取OK&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Thread-0 线程 开始写入</span><br><span class="line">Thread-4 线程 开始写入  <span class="comment"># 插入了其他的线程进行写入</span></span><br><span class="line">Thread-4 线程 写入OK</span><br><span class="line">Thread-3 线程 开始写入</span><br><span class="line">Thread-1 线程 开始写入</span><br><span class="line">Thread-2 线程 开始写入</span><br><span class="line">Thread-1 线程 写入OK</span><br><span class="line">Thread-3 线程 写入OK</span><br><span class="line">Thread-0 线程 写入OK   <span class="comment"># 对于这种情况会出现 数据不一致等情况</span></span><br><span class="line">Thread-2 线程 写入OK</span><br><span class="line">Thread-5 线程 开始读取</span><br><span class="line">Thread-6 线程 开始读取</span><br><span class="line">Thread-6 线程 读取OK</span><br><span class="line">Thread-7 线程 开始读取</span><br><span class="line">Thread-7 线程 读取OK</span><br><span class="line">Thread-5 线程 读取OK</span><br><span class="line">Thread-8 线程 开始读取</span><br><span class="line">Thread-8 线程 读取OK</span><br><span class="line">Thread-9 线程 开始读取</span><br><span class="line">Thread-9 线程 读取OK</span><br><span class="line">Thread-10 线程 开始读取</span><br><span class="line">Thread-11 线程 开始读取</span><br><span class="line">Thread-12 线程 开始读取</span><br><span class="line">Thread-12 线程 读取OK</span><br><span class="line">Thread-10 线程 读取OK</span><br><span class="line">Thread-14 线程 开始读取</span><br><span class="line">Thread-13 线程 开始读取</span><br><span class="line">Thread-13 线程 读取OK</span><br><span class="line">Thread-11 线程 读取OK</span><br><span class="line">Thread-14 线程 读取OK</span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br></pre></td></tr></table></figure><p>所以如果我们不加锁的情况，多线程的读写会造成数据不可靠的问题。<br>我们也可以采用<strong>synchronized</strong>这种重量锁和轻量锁 <strong>lock</strong>去保证数据的可靠。<br>但是这次我们采用更细粒度的锁：<strong>ReadWriteLock</strong> 读写锁来保证<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686482351456-b9b0209f-f928-4b31-8608-d9547230560c.png#averageHue=%23f3f2f2&clientId=uc59d1b67-bcbd-4&id=D3Gpl&originHeight=865&originWidth=1151&originalType=binary&ratio=1&rotation=0&showTitle=false&size=99893&status=done&style=none&taskId=ucfeb32ac-c2e3-46ef-974e-d0aa69c3ab0&title=" alt="image.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ogj.rw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyCache_ReadWriteLock</span> <span class="variable">mycache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCache_ReadWriteLock</span>();</span><br><span class="line">        <span class="comment">//开启5个线程 写入数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">5</span> ; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                mycache.put(String.valueOf(finalI),String.valueOf(finalI));</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开启10个线程去读取数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">o</span> <span class="operator">=</span> mycache.get(String.valueOf(finalI));</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCache_ReadWriteLock</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String,String&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用读写锁</span></span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock readWriteLock=<span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="comment">//普通锁</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key,String value)</span>&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//写入</span></span><br><span class="line">            <span class="comment">//业务流程</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 线程 开始写入&quot;</span>);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 线程 写入OK&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.writeLock().unlock(); <span class="comment">//解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        String o=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//得到</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 线程 开始读取&quot;</span>);</span><br><span class="line">            o = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 线程 读取OK&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Thread-0 线程 开始写入</span><br><span class="line">Thread-0 线程 写入OK</span><br><span class="line">Thread-1 线程 开始写入</span><br><span class="line">Thread-1 线程 写入OK</span><br><span class="line">Thread-2 线程 开始写入</span><br><span class="line">Thread-2 线程 写入OK</span><br><span class="line">Thread-3 线程 开始写入</span><br><span class="line">Thread-3 线程 写入OK</span><br><span class="line">Thread-4 线程 开始写入</span><br><span class="line">Thread-4 线程 写入OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上 整个过程没有再出现错乱的情况，对于读取，我们运行多个线程同时读取，</span></span><br><span class="line"><span class="comment"># 因为这样不会造成数据不一致问题，也能在一定程度上提高效率</span></span><br><span class="line">Thread-9 线程 开始读取</span><br><span class="line">Thread-9 线程 读取OK</span><br><span class="line">Thread-10 线程 开始读取</span><br><span class="line">Thread-5 线程 开始读取</span><br><span class="line">Thread-11 线程 开始读取</span><br><span class="line">Thread-11 线程 读取OK</span><br><span class="line">Thread-10 线程 读取OK</span><br><span class="line">Thread-7 线程 开始读取</span><br><span class="line">Thread-7 线程 读取OK</span><br><span class="line">Thread-6 线程 开始读取</span><br><span class="line">Thread-5 线程 读取OK</span><br><span class="line">Thread-14 线程 开始读取</span><br><span class="line">Thread-8 线程 开始读取</span><br><span class="line">Thread-14 线程 读取OK</span><br><span class="line">Thread-6 线程 读取OK</span><br><span class="line">Thread-13 线程 开始读取</span><br><span class="line">Thread-12 线程 开始读取</span><br><span class="line">Thread-13 线程 读取OK</span><br><span class="line">Thread-8 线程 读取OK</span><br><span class="line">Thread-12 线程 读取OK</span><br></pre></td></tr></table></figure><h1 id="3、四大函数式接口【-】"><a href="#3、四大函数式接口【-】" class="headerlink" title="3、四大函数式接口【**】"></a>3、四大函数式接口【**】</h1><p>新时代的程序员：<strong>lambda表达式、链式编程、函数式接口、Stream流式计算</strong></p><ul><li>函数式接口：只有一个方法的接口<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//超级多的@FunctionalInterface</span></span><br><span class="line"><span class="comment">//简化编程模型，在新版本的框架底层大量应用</span></span><br><span class="line"><span class="comment">//foreach()的参数也是一个函数式接口，消费者类的函数式接口</span></span><br></pre></td></tr></table></figure><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686474878495-b726c054-4533-4596-b26c-76515c28da01.png#averageHue=%23fbf6f6&clientId=udaf2058c-f549-4&id=YqH2n&originHeight=883&originWidth=368&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43569&status=done&style=none&taskId=u6f5e2cac-2d9a-4b67-baa6-965097413f0&title=" alt="image.png"><br>函数型接口可以使用lambda表达式；<br><strong>代码测试：</strong><blockquote><p>1、Function函数型接口</p></blockquote></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686474878625-10bab090-7c46-4766-8171-06fccc388663.png#averageHue=%233f352f&clientId=udaf2058c-f549-4&id=ZXqLh&originHeight=323&originWidth=650&originalType=binary&ratio=1&rotation=0&showTitle=false&size=194893&status=done&style=none&taskId=u2046f529-e083-488d-8cd9-52aabf2ce09&title=" alt="image.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function函数型接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Function&lt;String,String&gt; function = (str) -&gt;&#123;<span class="keyword">return</span> str;&#125;;</span><br><span class="line">        System.out.println(function.apply(<span class="string">&quot;starasdas&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2、Predicate断定型接口</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686474879209-57ad5c72-cf6d-4517-b08e-8737423364a5.png#averageHue=%2339322d&clientId=udaf2058c-f549-4&id=DSmQO&originHeight=574&originWidth=772&originalType=binary&ratio=1&rotation=0&showTitle=false&size=429281&status=done&style=none&taskId=u64a55449-e768-4de3-a0eb-0c2ac8c53d1&title=" alt="image.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 断定型接口：有一个输入参数，返回值只能是 布尔值！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//判断字符串是否为空</span></span><br><span class="line">        Predicate&lt;String&gt; predicate = (str)-&gt;&#123;<span class="keyword">return</span> str.isEmpty();&#125;;</span><br><span class="line">        System.out.println(predicate.test(<span class="string">&quot;11&quot;</span>));</span><br><span class="line">        System.out.println(predicate.test(<span class="string">&quot;&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>3、Consummer 消费型接口</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686474879306-a314a3cb-a98d-465f-84a6-803d37ea601b.png#averageHue=%233a322b&clientId=udaf2058c-f549-4&id=Uj5aH&originHeight=454&originWidth=882&originalType=binary&ratio=1&rotation=0&showTitle=false&size=381463&status=done&style=none&taskId=u51c7fa20-065a-4407-9cd4-19e874cdd7e&title=" alt="image.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费型接口 没有返回值！只有输入！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Consumer&lt;String&gt; consumer = (str)-&gt;&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;;</span><br><span class="line">        consumer.accept(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>4、Supplier供给型接口</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686474879459-381479b4-6242-4c2e-8d0c-a15636196286.png#averageHue=%233e362e&clientId=udaf2058c-f549-4&id=rp0Ma&originHeight=334&originWidth=680&originalType=binary&ratio=1&rotation=0&showTitle=false&size=197256&status=done&style=none&taskId=ube9aacf8-dce7-4748-898c-0adfd4c1ab8&title=" alt="image.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 供给型接口，只返回，不输入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Supplier&lt;String&gt; supplier = ()-&gt;&#123;<span class="keyword">return</span> <span class="string">&quot;1024&quot;</span>;&#125;;</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5、生产者和消费者【-】"><a href="#5、生产者和消费者【-】" class="headerlink" title="5、生产者和消费者【*】"></a>5、生产者和消费者【*】</h1><p><strong>Synchronized wait notify</strong>可以实现，该方法是传统版本；<br>我们这次使用lock版本</p><blockquote><p>1、Synchronized版本</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                data.increment();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                data.decrement();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>&#123;</span><br><span class="line">    <span class="comment">//数字  资源类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//+1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span>(number!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//等待操作</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;&quot;</span>+number);</span><br><span class="line">        <span class="comment">//通知其他线程 我+1完毕了</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//等待操作</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;&quot;</span>+number);</span><br><span class="line">        <span class="comment">//通知其他线程  我-1完毕了</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>问题存在，A线程B线程，现在如果我有四个线程A B C D！</strong></p></blockquote><p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727200107238.png#id=cMHFY&originHeight=798&originWidth=927&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>解决方案</strong>： <strong>if 改为while即可，防止虚假唤醒</strong><br>这样就不存在问题了：<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727200208118.png#id=nNsEc&originHeight=998&originWidth=1065&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><blockquote><p>2、<strong>JUC版本的生产者和消费者问题</strong></p></blockquote><p><strong>await、signal 替换 wait、notify</strong><br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727200241338.png#id=mBFNs&originHeight=290&originWidth=763&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>通过Lock找到Condition<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727200309313.png#id=StwyU&originHeight=645&originWidth=692&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data2</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data2</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            data.increment();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            data.decrement();</span><br><span class="line">        &#125;&#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            data.increment();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            data.decrement();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data2</span>&#123;</span><br><span class="line">    <span class="comment">//数字  资源类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//lock锁</span></span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//+1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span>  &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//业务</span></span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//等待操作</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;&quot;</span>+number);</span><br><span class="line">            <span class="comment">//通知其他线程 我+1完毕了</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span>  &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//业务</span></span><br><span class="line">            <span class="keyword">while</span> (number==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//等待操作</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;&quot;</span>+number);</span><br><span class="line">            <span class="comment">//通知其他线程 我+1完毕了</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>3、<strong>Condition的优势</strong>：精准的通知和唤醒的线程！</p></blockquote><p><strong>如果我们要指定通知的下一个进行顺序怎么办呢？ 我们可以使用Condition来指定通知进程~</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A 执行完 调用B</span></span><br><span class="line"><span class="comment"> * B 执行完 调用C</span></span><br><span class="line"><span class="comment"> * C 执行完 调用A</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data3</span> <span class="variable">data3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data3</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                data3.printA();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                data3.printB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                data3.printC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data3</span>&#123;</span><br><span class="line">    <span class="comment">//资源类</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//1A 2B 3C</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//业务 判断 -&gt; 执行 -&gt; 通知</span></span><br><span class="line">            <span class="keyword">while</span>(number!=<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//操作</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;,AAAAA&quot;</span>);</span><br><span class="line">            <span class="comment">//唤醒指定的线程</span></span><br><span class="line">            number=<span class="number">2</span>;</span><br><span class="line">            condition2.signal(); <span class="comment">// 唤醒2</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//业务 判断 -&gt; 执行 -&gt; 通知</span></span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">2</span>)&#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;,BBBBB&quot;</span>);</span><br><span class="line">            <span class="comment">//唤醒3</span></span><br><span class="line">            number=<span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printC</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//业务 判断 -&gt; 执行 -&gt; 通知</span></span><br><span class="line">            <span class="keyword">while</span>(number!=<span class="number">3</span>)&#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;,CCCCC&quot;</span>);</span><br><span class="line">            <span class="comment">//唤醒1</span></span><br><span class="line">            number=<span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727200424210.png#id=lLlA4&originHeight=571&originWidth=772&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h1 id="6、线程池【-】"><a href="#6、线程池【-】" class="headerlink" title="6、线程池【*】"></a>6、线程池【*】</h1><p>线程池：<strong>三大方法、7大参数、4种拒绝策略</strong></p><blockquote><p>1、池化技术</p></blockquote><p>程序的运行，本质：占用系统的资源！我们需要去优化资源的使用 &#x3D;&#x3D;&#x3D;&gt; 池化技术<br>线程池、JDBC的连接池、内存池、对象池 等等。。。。<br>资源的创建、销毁十分消耗资源<br><strong>池化技术</strong>：事先准备好一些资源，如果有人要用，就来我这里拿，用完之后还给我，以此来提高效率。<br><strong>线程池的好处：</strong><br>1、降低资源的消耗；<br>2、提高响应的速度；<br>3、方便管理；<br><strong>线程复用、可以控制最大并发数、管理线程；</strong></p><blockquote><p>2、线程池：三大方法</p></blockquote><ul><li><strong>ExecutorService threadPool &#x3D; Executors.newSingleThreadExecutor();&#x2F;&#x2F;单个线程</strong></li><li><strong>ExecutorService threadPool2 &#x3D; Executors.newFixedThreadPool(5); &#x2F;&#x2F;创建一个固定的线程池的大小</strong></li><li><strong>ExecutorService threadPool3 &#x3D; Executors.newCachedThreadPool(); &#x2F;&#x2F;可伸缩的</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//工具类 Executors 三大方法；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();<span class="comment">//单个线程</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool2</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>); <span class="comment">//创建一个固定的线程池的大小</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool3</span> <span class="operator">=</span> Executors.newCachedThreadPool(); <span class="comment">//可伸缩的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程池用完必须要关闭线程池</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">100</span> ; i++) &#123;</span><br><span class="line">                <span class="comment">//通过线程池创建线程</span></span><br><span class="line">                threadPool.execute(()-&gt;&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+ <span class="string">&quot; ok&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>3、7大参数</p></blockquote><p>源码分析</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质：三种方法都是开启的<strong>ThreadPoolExecutor</strong></p><table><thead><tr><th>参数名</th><th>参数解释</th></tr></thead><tbody><tr><td>int <strong>corePoolSize</strong></td><td>核心线程池大小</td></tr><tr><td>int <strong>maximumPoolSize</strong></td><td>最大的线程池大小</td></tr><tr><td>long <strong>keepAliveTime</strong></td><td>超时了没有人调用就会释放</td></tr><tr><td>TimeUnit <strong>unit</strong></td><td>超时单位</td></tr><tr><td>BlockingQueue <strong>workQueue</strong></td><td>阻塞队列</td></tr><tr><td>ThreadFactory <strong>threadFactory</strong></td><td>线程工厂 创建线程的 一般不用动</td></tr><tr><td>RejectedExecutionHandler <strong>handler</strong></td><td>拒绝策略</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,  //核心线程池大小</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize, //最大的线程池大小</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,  //超时了没有人调用就会释放</span></span><br><span class="line"><span class="params">                          TimeUnit unit, //超时单位</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue, //阻塞队列</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory, //线程工厂 创建线程的 一般不用动</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler //拒绝策略</span></span><br><span class="line"><span class="params">                         )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686475029099-68638ed8-1652-41ba-8b79-f50b54e18c6e.png#averageHue=%23f5f6f2&clientId=udaf2058c-f549-4&id=se32r&originHeight=276&originWidth=817&originalType=binary&ratio=1&rotation=0&showTitle=false&size=190948&status=done&style=none&taskId=u7cd9458a-45fd-4122-aced-75595e6b133&title=" alt="image.png"><br>阿里巴巴的Java操作手册中明确说明：对于Integer.MAX_VALUE初始值较大，所以一般情况我们要使用底层的<strong>ThreadPoolExecutor</strong>来创建线程池。</p><blockquote><p>4、业务图</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686475029084-98a6441f-9f57-475f-a19b-39f399df799a.png#averageHue=%23f8f8f5&clientId=udaf2058c-f549-4&id=MfniU&originHeight=502&originWidth=808&originalType=binary&ratio=1&rotation=0&showTitle=false&size=171268&status=done&style=none&taskId=ub983dc16-bc22-4ee7-a0fa-ead5f4d3c4e&title=" alt="image.png"></p><blockquote><p>手动创建线程池</p></blockquote><p><code>**// todo:P24**</code></p><blockquote><p>5、拒绝策略4种</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686475029626-070dc59b-5ff0-40ea-ad07-49dbf7b162f8.png#averageHue=%2339342f&clientId=udaf2058c-f549-4&id=wxZll&originHeight=560&originWidth=1239&originalType=binary&ratio=1&rotation=0&showTitle=false&size=500427&status=done&style=none&taskId=ube24affe-5581-4430-875c-6cc9d9fac9d&title=" alt="image.png"><br><strong>（1）new ThreadPoolExecutor.AbortPolicy()：</strong> &#x2F;&#x2F;该拒绝策略为：银行满了，还有人进来，不处理这个人的，并抛出异常<br>超出最大承载，就会抛出异常：队列容量大小+maxPoolSize<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686475030605-7dcd953f-8bc0-4886-abd9-12c1c869b24e.png#averageHue=%233d3732&clientId=udaf2058c-f549-4&id=Ex1vP&originHeight=955&originWidth=1891&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1496156&status=done&style=none&taskId=u0bb42443-4acb-4498-b03e-2a3e5143d1a&title=" alt="image.png"></p><p><strong>（2）new ThreadPoolExecutor.CallerRunsPolicy()：</strong> &#x2F;&#x2F;该拒绝策略为：哪来的去哪里 main线程进行处理<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686475032072-e7288218-05ef-451f-b33d-14ca650382a7.png#averageHue=%233d3732&clientId=udaf2058c-f549-4&id=AYe4n&originHeight=925&originWidth=1795&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1405455&status=done&style=none&taskId=uca01df48-af62-4f4e-aab3-24082da189a&title=" alt="image.png"></p><p><strong>（3）new ThreadPoolExecutor.DiscardPolicy():</strong> &#x2F;&#x2F;该拒绝策略为：队列满了,丢掉异常，不会抛出异常。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686475032476-3bfe7a9a-37e7-4669-895b-68cdc0a668fa.png#averageHue=%23403934&clientId=udaf2058c-f549-4&id=IFuZB&originHeight=952&originWidth=1573&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1299306&status=done&style=none&taskId=u26275dd3-c3ce-4e0d-9571-8702223e70b&title=" alt="image.png"></p><p><strong>（4）new ThreadPoolExecutor.DiscardOldestPolicy()：</strong> &#x2F;&#x2F;该拒绝策略为：队列满了，尝试去和最早的进程竞争，不会抛出异<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686475032835-38e439f4-68c0-43fb-b399-2718efdbb131.png#averageHue=%233e3832&clientId=udaf2058c-f549-4&id=JtBr9&originHeight=998&originWidth=1709&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1413894&status=done&style=none&taskId=u9d2f8a9b-dc70-4f22-b511-d83c1b545af&title=" alt="image.png"></p><blockquote><p>6、小结和拓展</p></blockquote><p>如何去设置线程池的最大大小如何去设置<br>CPU密集型和IO密集型！<br><strong>1、CPU密集型：电脑的核数是几核就选择几；选择maximunPoolSize的大小</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686475032119-03822b00-8386-4e77-9104-12f2abd7adbc.png#averageHue=%233b3530&clientId=udaf2058c-f549-4&id=dhsHH&originHeight=274&originWidth=1036&originalType=binary&ratio=1&rotation=0&showTitle=false&size=277251&status=done&style=none&taskId=u789238c2-927d-4cf4-b0e2-bcc51896c06&title=" alt="image.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们可以使用代码来来获取逻辑处理器数量。</span></span><br><span class="line">Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></table></figure><p>于是<strong>cpu密集型</strong>的写法如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686475033453-024dda41-95db-4cd6-9c17-941bf30e550c.png#averageHue=%233c3630&clientId=udaf2058c-f549-4&id=s6dJo&originHeight=321&originWidth=1123&originalType=binary&ratio=1&rotation=0&showTitle=false&size=349672&status=done&style=none&taskId=u49220ca9-37c5-4b27-a9c9-a82472918e9&title=" alt="image.png"></p><p><strong>2、I&#x2F;O密集型：</strong><br>在程序中有15个大型任务，io十分占用资源；I&#x2F;O密集型就是判断我们程序中十分耗I&#x2F;O的线程数量，大约是最大I&#x2F;O数的一倍到两倍之间。</p><h1 id="7、常见问题"><a href="#7、常见问题" class="headerlink" title="7、常见问题"></a>7、常见问题</h1><h2 id="7-1-8锁现象【-】"><a href="#7-1-8锁现象【-】" class="headerlink" title="7.1 8锁现象【*】"></a>7.1 8锁现象【*】</h2><blockquote><p>1、<strong>如何判断锁的是谁！锁到底锁的是谁？</strong></p></blockquote><p>锁会锁住：<strong>对象、Class</strong><br><strong>深刻理解我们的锁</strong></p><ol><li><strong>问题1：</strong></li></ol><p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727200505228.png#id=AwZiG&originHeight=752&originWidth=944&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>结果是：先发短信，如何再打电话！<br><strong>为什么？ 如果你认为是顺序在前？ 这个答案是错误的！</strong></p><ol start="2"><li><strong>问题2：</strong></li></ol><p><strong>我们再来看：我们让发短信 延迟4s</strong><br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727200541706.png#id=Hl47l&originHeight=727&originWidth=917&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>现在结果是什么呢？<br>结果：<strong>还是先发短信，然后再打电话！</strong><br><strong>why？</strong><br>原因：并不是顺序执行！是因为synchronized 锁的对象是方法的调用！对于两个方法用的是同一个锁，谁先拿到谁先执行！另外一个则等待！</p><ol start="3"><li><strong>问题3：</strong></li></ol><p><strong>如果我们添加一个普通方法，那么先执行哪一个呢？</strong><br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727200635437.png#id=vDHU6&originHeight=776&originWidth=751&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>答案是：<em><em>先执行hello，然后再执行发短信！</em>_原因是hello是一个</em>_普通方法<strong>，</strong>不受synchronized锁的影响**，但是我发现，如果我把发短信里面的延迟4秒去掉，那么就会顺序执行，先执行发短信然后再执行hello，原因应该是顺序执行的原因吧,不是太理解。</p><ol start="4"><li><strong>问题4：</strong></li></ol><p><strong>如果我们使用的是两个对象，一个调用发短信，一个调用打电话，那么整个顺序是怎么样的呢？</strong><br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727200753229.png#id=Zq2hy&originHeight=740&originWidth=756&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>答案是：先打电话，后发短信。原因：<strong>在发短信方法中延迟了4s，又因为synchronized锁的是对象，但是我们这使用的是两个对象，所以每个对象都有一把锁，所以不会造成锁的等待。正常执行</strong></p><ol start="5"><li><strong>问题5，6：</strong></li></ol><p><strong>如果我们把synchronized的方法加上static变成静态方法！那么顺序又是怎么样的呢？</strong><br>（1）我们先来使用一个对象调用两个方法！<br>答案是：<strong>先发短信,后打电话</strong><br>（2）如果我们使用两个对象调用两个方法！<br>答案是：<strong>还是先发短信，后打电话</strong><br>原因是什么呢？ <strong>为什么加了static就始终前面一个对象先执行呢！为什么后面会等待呢？</strong><br>原因是：<strong>对于static静态方法来说，对于整个类Class来说只有一份，对于不同的对象使用的是同一份方法，相当于这个方法是属于这个类的，如果静态static方法使用synchronized锁定，那么这个synchronized锁会锁住整个对象！不管多少个对象，对于静态的锁都只有一把锁，谁先拿到这个锁就先执行，其他的进程都需要等待！</strong></p><ol start="6"><li><strong>问题7：</strong></li></ol><p><strong>如果我们使用一个静态同步方法、一个同步方法、一个对象调用顺序是什么？</strong><br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727200947247.png#id=lSCWH&originHeight=624&originWidth=925&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>明显答案是：先打电话，后发短信了。<br><strong>因为一个锁的是Class类模板，一个锁的是对象调用者。后面那个打电话不需要等待发短信，直接运行就可以了。</strong></p><ol start="7"><li><strong>问题8：</strong></li></ol><p>如果我们使用一个静态同步方法、一个同步方法、两个对象调用顺序是什么呢？<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727201304983.png#id=MOkKT&originHeight=628&originWidth=868&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>当然答案是：先打电话、后发短信！<br>因为两个对象，一样的原因：<strong>两把锁锁的不是同一个东西，所以后面的第二个对象不需要等待第一个对象的执行。</strong></p><blockquote><p>2、小结</p></blockquote><p><strong>new</strong> 出来的 this 是具体的一个对象<br><strong>static Class</strong> 是唯一的一个模板</p><h2 id="7-2-集合类不安全"><a href="#7-2-集合类不安全" class="headerlink" title="7.2 集合类不安全"></a>7.2 集合类不安全</h2><blockquote><p>1、List不安全</p></blockquote><p>我们来看一下List这个集合类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java.util.ConcurrentModificationException 并发修改异常！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Object&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                arrayList.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(arrayList);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会造成：<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727201349859.png#id=Kd5lF&originHeight=374&originWidth=855&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>ArrayList 在并发情况下是不安全的！</strong></p><ul><li>解决方案：</li></ul><p><strong>1、切换成Vector就是线程安全的啦！</strong><br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727201419457.png#id=baEHd&originHeight=857&originWidth=1272&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>2、使用Collections.synchronizedList(new ArrayList&lt;&gt;());</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Object&gt; arrayList = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                arrayList.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(arrayList);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、使用JUC中的包：List arrayList &#x3D; new CopyOnWriteArrayList&lt;&gt;();</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Object&gt; arrayList = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                arrayList.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(arrayList);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CopyOnWriteArrayList</strong>：写入时复制！ <strong>COW 计算机程序设计领域的一种优化策略</strong><br>多个线程调用的时候，list，读取的时候，固定的，写入（存在覆盖操作）；在写入的时候避免覆盖，造成数据错乱的问题；</p><blockquote><p>2、<strong>CopyOnWriteArrayList</strong>比<strong>Vector</strong>厉害在哪里？</p></blockquote><p><strong>Vector</strong>底层是使用<strong>synchronized</strong>关键字来实现的：效率特别低下。<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727201526105.png#id=adQwB&originHeight=557&originWidth=1279&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>CopyOnWriteArrayList</strong>使用的是Lock锁，效率会更加高效！<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727201546295.png#id=bnRJl&originHeight=456&originWidth=1014&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><blockquote><p>3、Set不安全</p></blockquote><p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727201604399.png#id=JMm7g&originHeight=384&originWidth=597&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>和List、Set同级的还有一个BlockingQueue 阻塞队列；<br><strong>Set和List同理可得:</strong> 多线程情况下，普通的Set集合是线程不安全的；<br>解决方案还是两种：</p><ul><li>使用Collections工具类的<strong>synchronized</strong>包装的Set类</li><li>使用CopyOnWriteArraySet 写入复制的<strong>JUC</strong>解决方案<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同理：java.util.ConcurrentModificationException</span></span><br><span class="line"><span class="comment">// 解决方案：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Set&lt;String&gt; hashSet = Collections.synchronizedSet(new HashSet&lt;&gt;()); //解决方案1</span></span><br><span class="line">        Set&lt;String&gt; hashSet = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();<span class="comment">//解决方案2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                hashSet.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(hashSet);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>HashSet底层是什么？</strong><br>hashSet底层就是一个<strong>HashMap</strong>；<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//add 本质其实就是一个map的key，map的key是无法重复的，所以使用的就是map存储</span></span><br><span class="line"><span class="comment">//hashSet就是使用了hashmap key不能重复的原理</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//PRESENT是什么？ 是一个常量  不会改变的常量  无用的占位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>4、Map不安全</p></blockquote><p>回顾map的基本操作：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//map 是这样用的吗？  不是，工作中不使用这个</span><br><span class="line">//默认等价什么？ new HashMap&lt;&gt;(16,0.75);</span><br><span class="line">Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">//加载因子、初始化容量</span><br></pre></td></tr></table></figure><p>默认<strong>加载因子是0.75</strong>,默认的<strong>初始容量是16</strong><br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727201710950.png#id=NQtfi&originHeight=544&originWidth=904&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>同样的HashMap基础类也存在<strong>并发修改异常</strong>！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//map 是这样用的吗？  不是，工作中不使用这个</span></span><br><span class="line">        <span class="comment">//默认等价什么？ new HashMap&lt;&gt;(16,0.75);</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//加载因子、初始化容量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                map.put(Thread.currentThread().getName(),UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果同样的出现了：<strong>异常java.util.ConcurrentModificationException 并发修改异常</strong><br><strong>解决方案：</strong></p><ul><li><strong>使用Collections.synchronizedMap(new HashMap&lt;&gt;());处理</strong>；</li><li><strong>使用ConcurrentHashMap进行并发处理</strong></li></ul><p>TODO:研究ConcurrentHashMap底层原理：<br>这里我们可以直接去研究一下，这个也是相当重要的。</p><h2 id="7-3-Callable-简单"><a href="#7-3-Callable-简单" class="headerlink" title="7.3 Callable(简单)"></a>7.3 Callable(简单)</h2><p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727201823382.png#id=fHqV5&originHeight=599&originWidth=1225&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>1、可以有返回值；</strong><br><strong>2、可以抛出异常；</strong><br><strong>3、方法不同，run()&#x2F;call()</strong></p><blockquote><p>1、代码测试</p></blockquote><p>传统使用线程方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>()).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<strong>Callable</strong>进行多线程操作：<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727201858566.png#id=vcgHa&originHeight=433&originWidth=847&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>Calleable 泛型T就是<strong>call运行方法的返回值类型</strong>；<br>但是<strong>如何使用</strong>呢？<br><strong>Callable怎么放入到Thread里面呢？</strong><br>源码分析：<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727201934861.png#id=egkRP&originHeight=796&originWidth=1120&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>对于Thread运行，只能传入Runnable类型的参数；<br>我们这是Callable 怎么办呢？<br>看JDK api文档：<br>在Runnable里面有一个叫做FutureTask的实现类，我们进去看一下。<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727202005417.png#id=Huec4&originHeight=845&originWidth=972&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>FutureTask中可以接受Callable参数；<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727202022160.png#id=mji8H&originHeight=484&originWidth=632&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>这样我们就可以先把Callable 放入到FutureTask中， 如何再把FutureTask 放入到Thread就可以了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="comment">//            new Thread(new Runnable()).start();</span></span><br><span class="line"><span class="comment">//            new Thread(new FutureTask&lt;&gt;( Callable)).start();</span></span><br><span class="line">            MyThread thread= <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">            <span class="comment">//适配类：FutureTask</span></span><br><span class="line">            FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(thread);</span><br><span class="line">            <span class="comment">//放入Thread使用</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask,String.valueOf(i)).start();</span><br><span class="line">            <span class="comment">//获取返回值</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;返回值：&quot;</span>+ s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Call:&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;String&quot;</span>+Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以使用Callable来进行多线程编程了，并且我们发现可以有返回值，并且可以抛出异常。<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727202113698.png#id=ygC4v&originHeight=507&originWidth=1023&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>注意两个重点：<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727202135656.png#id=G1nkM&originHeight=560&originWidth=1202&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="7-4-阻塞队列"><a href="#7-4-阻塞队列" class="headerlink" title="7.4 阻塞队列"></a>7.4 阻塞队列</h2><ul><li>阻塞队列</li></ul><p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727202624665.png#id=kd4ld&originHeight=394&originWidth=766&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>阻塞队列jdk1.8文档解释：<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727202645162.png#id=LiCSl&originHeight=302&originWidth=781&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><blockquote><p><strong>1、BlockingQueue</strong></p></blockquote><p>blockingQueue 是Collection的一个子类；<br>什么情况我们会使用 阻塞队列呢？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">多线程并发处理、线程池！</span><br></pre></td></tr></table></figure><p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727202709411.png#id=MnwFt&originHeight=486&originWidth=577&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>整个阻塞队列的家族如下：Queue以下实现的有Deque、AbstaractQueue、BlockingQueue；<br>BlockingQueue以下有Link链表实现的阻塞队列、也有Array数组实现的阻塞队列</p><blockquote><p><strong>2、如何使用阻塞队列呢？【*】</strong></p></blockquote><p>操作：添加、移除<br>但是实际我们要学的有：<br><strong>四组API</strong></p><table><thead><tr><th>方式</th><th>抛出异常</th><th>不会抛出异常，有返回值</th><th>阻塞 等待</th><th>超时 等待</th></tr></thead><tbody><tr><td>添加</td><td>add</td><td>offer</td><td>put</td><td>offer(timenum，timeUnit)</td></tr><tr><td>移除</td><td>remove</td><td>poll</td><td>take</td><td>poll(timenum，timeUnit)</td></tr><tr><td>判断队列首</td><td>element</td><td>peek</td><td>-</td><td>-</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//需要初始化队列的大小</span></span><br><span class="line">        <span class="type">ArrayBlockingQueue</span> <span class="variable">blockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">&quot;c&quot;</span>));</span><br><span class="line">        <span class="comment">//抛出异常：java.lang.IllegalStateException: Queue full</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.add(&quot;d&quot;));</span></span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">        <span class="comment">//如果多移除一个</span></span><br><span class="line">        <span class="comment">//这也会造成 java.util.NoSuchElementException 抛出异常</span></span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">    &#125;</span><br><span class="line">=======================================================================================</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不抛出异常，有返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ArrayBlockingQueue</span> <span class="variable">blockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">&quot;c&quot;</span>));</span><br><span class="line">        <span class="comment">//添加 一个不能添加的元素 使用offer只会返回false 不会抛出异常</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">&quot;d&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        <span class="comment">//弹出 如果没有元素 只会返回null 不会抛出异常</span></span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">    &#125;</span><br><span class="line">=======================================================================================</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待 一直阻塞</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ArrayBlockingQueue</span> <span class="variable">blockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一直阻塞 不会返回</span></span><br><span class="line">        blockingQueue.put(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        blockingQueue.put(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        blockingQueue.put(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果队列已经满了， 再进去一个元素  这种情况会一直等待这个队列 什么时候有了位置再进去，程序不会停止</span></span><br><span class="line"><span class="comment">//        blockingQueue.put(&quot;d&quot;);</span></span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        <span class="comment">//如果我们再来一个  这种情况也会等待，程序会一直运行 阻塞</span></span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">    &#125;</span><br><span class="line">=======================================================================================</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待 超时阻塞</span></span><br><span class="line"><span class="comment">     *  这种情况也会等待队列有位置 或者有产品 但是会超时结束</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ArrayBlockingQueue</span> <span class="variable">blockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        blockingQueue.offer(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        blockingQueue.offer(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        blockingQueue.offer(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;开始等待&quot;</span>);</span><br><span class="line">        blockingQueue.offer(<span class="string">&quot;d&quot;</span>,<span class="number">2</span>, TimeUnit.SECONDS);  <span class="comment">//超时时间2s 等待如果超过2s就结束等待</span></span><br><span class="line">        System.out.println(<span class="string">&quot;结束等待&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;===========取值==================&quot;</span>);</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;开始等待&quot;</span>);</span><br><span class="line">        blockingQueue.poll(<span class="number">2</span>,TimeUnit.SECONDS); <span class="comment">//超过两秒 我们就不要等待了</span></span><br><span class="line">        System.out.println(<span class="string">&quot;结束等待&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>3、同步队列SynchronousQueue</strong></p></blockquote><p>同步队列 没有容量，也可以视为<strong>容量为1的队列</strong>；<br>进去一个元素，必须等待取出来之后，才能再往里面放入一个元素；<br><strong>put</strong>方法 和 <strong>take</strong>方法；<br><strong>Synchronized</strong> 和 其他的<strong>BlockingQueue</strong> 不一样 它不存储元素；<br>put了一个元素，就必须从里面先take出来，否则不能再put进去值！<br>并且SynchronousQueue 的take是使用了<strong>lock锁保证线程安全</strong>的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronousQueueDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; synchronousQueue = <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//研究一下 如果判断这是一个同步队列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用两个进程</span></span><br><span class="line">        <span class="comment">// 一个进程 放进去</span></span><br><span class="line">        <span class="comment">// 一个进程 拿出来</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; Put 1&quot;</span>);</span><br><span class="line">                synchronousQueue.put(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; Put 2&quot;</span>);</span><br><span class="line">                synchronousQueue.put(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; Put 3&quot;</span>);</span><br><span class="line">                synchronousQueue.put(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; Take &quot;</span>+synchronousQueue.take());</span><br><span class="line"><span class="comment">//                TimeUnit.SECONDS.sleep(3);</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; Take &quot;</span>+synchronousQueue.take());</span><br><span class="line"><span class="comment">//                TimeUnit.SECONDS.sleep(3);</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; Take &quot;</span>+synchronousQueue.take());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727202913340.png#id=y6u7y&originHeight=289&originWidth=623&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="7-6-异步回调"><a href="#7-6-异步回调" class="headerlink" title="7.6 异步回调"></a>7.6 异步回调</h2><blockquote><p>1、Future 设计的初衷：对将来的某个事件结果进行建模！</p></blockquote><p>其实就是前端 –&gt; 发送ajax异步请求给后端<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727204140269.png#id=ICghW&originHeight=299&originWidth=1042&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>但是我们平时都使用<strong>CompletableFuture</strong></p><blockquote><p>2、没有返回值的runAsync异步回调</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 发起 一个 请求</span></span><br><span class="line"></span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//发起一个异步任务</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;.....&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//输出执行结果</span></span><br><span class="line">        System.out.println(future.get());  <span class="comment">//获取执行结果</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>3、有返回值的异步回调supplyAsync</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有返回值的异步回调</span></span><br><span class="line">CompletableFuture&lt;Integer&gt; completableFuture=CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> i=<span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(completableFuture.whenComplete((t, u) -&gt; &#123;</span><br><span class="line">    <span class="comment">//success 回调</span></span><br><span class="line">    System.out.println(<span class="string">&quot;t=&gt;&quot;</span> + t); <span class="comment">//正常的返回结果</span></span><br><span class="line">    System.out.println(<span class="string">&quot;u=&gt;&quot;</span> + u); <span class="comment">//抛出异常的 错误信息</span></span><br><span class="line">&#125;).exceptionally((e) -&gt; &#123;</span><br><span class="line">    <span class="comment">//error回调</span></span><br><span class="line">    System.out.println(e.getMessage());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">404</span>;</span><br><span class="line">&#125;).get());</span><br></pre></td></tr></table></figure><p><strong>whenComplete</strong>: 有两个参数，一个是t 一个是u<br>T：是代表的 <strong>正常返回的结果</strong>；<br>U：是代表的 <strong>抛出异常的错误信息</strong>；<br>如果发生了异常，get可以获取到<strong>exceptionally</strong>返回的值；</p><h2 id="7-7-JMM"><a href="#7-7-JMM" class="headerlink" title="7.7 JMM"></a>7.7 JMM</h2><blockquote><p>1、请你谈谈你对Volatile 的理解</p></blockquote><p><strong>Volatile</strong> 是 Java 虚拟机提供 <strong>轻量级的同步机制</strong></p><ol><li>保证可见性</li><li>不保证原子性</li><li>禁止指令重排</li></ol><blockquote><p>2、什么是JMM？</p></blockquote><p>JMM：JAVA内存模型，不存在的东西，是一个概念，也是一个约定！<br><strong>关于JMM的一些同步的约定：</strong><br>1、线程解锁前，必须把共享变量<strong>立刻</strong>刷回主存；<br>2、线程加锁前，必须<strong>读取主存</strong>中的最新值到工作内存中；<br>3、加锁和解锁是同一把锁；<br>线程中分为 <strong>工作内存、主内存</strong></p><p><strong>8种操作</strong>:</p><ul><li><strong>Read（读取）</strong>：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用；</li><li><strong>load（载入）</strong>：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中；</li><li><strong>Use（使用）</strong>：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令；</li><li><strong>assign（赋值）</strong>：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中；</li><li><strong>store（存储）</strong>：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用；</li><li><strong>write（写入）</strong>：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中；</li><li><strong>lock（锁定）</strong>：作用于主内存的变量，把一个变量标识为线程独占状态；</li><li><strong>unlock（解锁）</strong>：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定；</li></ul><p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727204419162.png#id=R0IPX&originHeight=355&originWidth=575&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/2020072720445830.png#id=UU8JP&originHeight=386&originWidth=698&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><strong>JMM对这8种操作给了相应的规定</strong>：</p><ul><li>不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write</li><li>不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存</li><li>不允许一个线程将没有assign的数据从工作内存同步回主内存</li><li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过assign和load操作</li><li>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁</li><li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值</li><li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量</li><li>对一个变量进行unlock操作之前，必须把此变量同步回主内存</li></ul><p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/2020072720445830.png#id=Vgu7l&originHeight=386&originWidth=698&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>遇到问题：<strong>程序不知道主存中的值已经被修改过了！；</strong></p><h2 id="7-8-Volatile"><a href="#7-8-Volatile" class="headerlink" title="7.8 Volatile"></a>7.8 Volatile</h2><blockquote><p>1、保证可见性</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JMMDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不加volatile 程序会死循环</span></span><br><span class="line">    <span class="comment">// 加了volatile是可以保证可见性的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//main线程</span></span><br><span class="line">        <span class="comment">//子线程1</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (number==<span class="number">0</span>)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//子线程2</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (number==<span class="number">0</span>)&#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        number=<span class="number">1</span>;</span><br><span class="line">        System.out.println(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2、不保证原子性</p></blockquote><p>原子性：不可分割；<br>线程A在执行任务的时候，不能被打扰的，也不能被分割的，要么同时成功，要么同时失败。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不保证原子性</span></span><br><span class="line"><span class="comment"> * number &lt;=2w</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VDemo02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        number++; </span><br><span class="line">        <span class="comment">//++ 不是一个原子性操作，是两个~3个操作</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//理论上number  === 20000</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">1000</span> ; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//main  gc</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;,num=&quot;</span>+number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果不加lock和synchronized ，怎么样保证原子性？</strong><br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727204535517.png#id=fTxT1&originHeight=616&originWidth=999&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>解决方法：使用JUC下的原子包下的class；<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727204554558.png#id=XRD3j&originHeight=623&originWidth=360&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VDemo02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">AtomicInteger</span> <span class="variable">number</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//        number++;</span></span><br><span class="line">        number.incrementAndGet();  <span class="comment">//底层是CAS保证的原子性</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//理论上number  === 20000</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">1000</span> ; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//main  gc</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;,num=&quot;</span>+number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些类的底层都直接和操作系统挂钩！是在内存中修改值。<br>Unsafe类是一个很特殊的存在；</p><blockquote><p>3、禁止指令重排</p></blockquote><p><strong>什么是指令重排？</strong><br>我们写的程序，计算机并不是按照我们自己写的那样去执行的<br>源代码–&gt;编译器优化重排–&gt;指令并行也可能会重排–&gt;内存系统也会重排–&gt;执行<br><strong>处理器在进行指令重排的时候，会考虑数据之间的依赖性！</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">1</span>; <span class="comment">//1</span></span><br><span class="line"><span class="type">int</span> y=<span class="number">2</span>; <span class="comment">//2</span></span><br><span class="line">x=x+<span class="number">5</span>;   <span class="comment">//3</span></span><br><span class="line">y=x*x;   <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们期望的执行顺序是 1_2_3_4  可能执行的顺序会变成2134 1324</span></span><br><span class="line"><span class="comment">//可不可能是 4123？ 不可能的</span></span><br></pre></td></tr></table></figure><p>可能造成的影响结果：前提：a b x y这四个值 默认都是0</p><table><thead><tr><th>线程A</th><th>线程B</th></tr></thead><tbody><tr><td>x&#x3D;a</td><td>y&#x3D;b</td></tr><tr><td>b&#x3D;1</td><td>a&#x3D;2</td></tr></tbody></table><p>正常的结果： x &#x3D; 0; y &#x3D;0;</p><table><thead><tr><th>线程A</th><th>线程B</th></tr></thead><tbody><tr><td>x&#x3D;a</td><td>y&#x3D;b</td></tr><tr><td>b&#x3D;1</td><td>a&#x3D;2</td></tr></tbody></table><p>可能在线程A中会出现，先执行b&#x3D;1,然后再执行x&#x3D;a；<br>在B线程中可能会出现，先执行a&#x3D;2，然后执行y&#x3D;b；<br>那么就有可能结果如下：x&#x3D;2; y&#x3D;1.<br><strong>volatile可以避免指令重排：</strong><br><strong>volatile中会加一道内存的屏障，这个内存屏障可以保证在这个屏障中的指令顺序。</strong><br>内存屏障：CPU指令。作用：<br>1、保证特定的操作的执行顺序；<br>2、可以保证某些变量的内存可见性（利用这些特性，就可以保证volatile实现的可见性）<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727204653125.png#id=uJUZ5&originHeight=361&originWidth=251&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><blockquote><p>总结</p></blockquote><ul><li><strong>volatile可以保证可见性；</strong></li><li><strong>不能保证原子性</strong></li><li><strong>由于内存屏障，可以保证避免指令重排的现象产生</strong></li></ul><p>面试官：那么你知道在哪里用这个内存屏障用得最多呢？<strong>单例模式</strong></p><h2 id="7-9-玩转单例模式"><a href="#7-9-玩转单例模式" class="headerlink" title="7.9 玩转单例模式"></a>7.9 玩转单例模式</h2><p>饿汉式、DCL懒汉式</p><blockquote><p>1、饿汉式</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hungry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可能会浪费空间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] data1=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] data2=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] data3=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] data4=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Hungry</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Hungry</span> <span class="variable">hungry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hungry</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2、懒汉式</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉式单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyMan</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">key</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazyMan</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LazyMan.class)&#123;</span><br><span class="line">            <span class="keyword">if</span> (key==<span class="literal">false</span>)&#123;</span><br><span class="line">                key=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;不要试图使用反射破坏异常&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyMan lazyMan;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//双重检测锁模式 简称DCL懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazyMan <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//需要加锁</span></span><br><span class="line">        <span class="keyword">if</span>(lazyMan==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyMan.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(lazyMan==<span class="literal">null</span>)&#123;</span><br><span class="line">                    lazyMan=<span class="keyword">new</span> <span class="title class_">LazyMan</span>();</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 1、分配内存空间</span></span><br><span class="line"><span class="comment">                     * 2、执行构造方法，初始化对象</span></span><br><span class="line"><span class="comment">                     * 3、把这个对象指向这个空间</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     *  就有可能出现指令重排问题</span></span><br><span class="line"><span class="comment">                     *  比如执行的顺序是1 3 2 等</span></span><br><span class="line"><span class="comment">                     *  我们就可以添加volatile保证指令重排问题</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyMan;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//单线程下 是ok的</span></span><br><span class="line">    <span class="comment">//但是如果是并发的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="comment">//Java中有反射</span></span><br><span class="line"><span class="comment">//        LazyMan instance = LazyMan.getInstance();</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">key</span> <span class="operator">=</span> LazyMan.class.getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        key.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        Constructor&lt;LazyMan&gt; declaredConstructor = LazyMan.class.getDeclaredConstructor(<span class="literal">null</span>);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>); <span class="comment">//无视了私有的构造器</span></span><br><span class="line">        <span class="type">LazyMan</span> <span class="variable">lazyMan1</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line">        key.set(lazyMan1,<span class="literal">false</span>);</span><br><span class="line">        <span class="type">LazyMan</span> <span class="variable">instance</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(instance);</span><br><span class="line">        System.out.println(lazyMan1);</span><br><span class="line">        System.out.println(instance == lazyMan1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>3、静态内部类</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Holder</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Holder <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.holder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Holder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Holder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>单例不安全, 因为反射</li></ul><blockquote><p>4、枚举</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//enum 是什么？ enum本身就是一个Class 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingle</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> EnumSingle <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        <span class="type">EnumSingle</span> <span class="variable">instance1</span> <span class="operator">=</span> EnumSingle.INSTANCE;</span><br><span class="line">        Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class,<span class="type">int</span>.class);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//java.lang.NoSuchMethodException: com.ogj.single.EnumSingle.&lt;init&gt;()</span></span><br><span class="line"></span><br><span class="line">        <span class="type">EnumSingle</span> <span class="variable">instance2</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line">        System.out.println(instance1);</span><br><span class="line">        System.out.println(instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用枚举，我们就可以防止反射破坏了。<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727204727492.png#id=vR1kn&originHeight=163&originWidth=1112&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>枚举类型使用JAD最终反编译后源码：<br>如果我们看idea 的文件：会发现idea骗了我们，居然告诉我们是有有参构造的，我们使用jad进行反编译。<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727204751957.png#id=QlIu2&originHeight=621&originWidth=1416&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/2020072720480950.png#id=wLHfc&originHeight=872&originWidth=1739&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">EnumSingle</span> <span class="keyword">extends</span> <span class="title class_">Enum</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EnumSingle[] values()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (EnumSingle[])$VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EnumSingle <span class="title function_">valueOf</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (EnumSingle)Enum.valueOf(com/ogj/single/EnumSingle, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">EnumSingle</span><span class="params">(String s, <span class="type">int</span> i)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EnumSingle <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EnumSingle INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EnumSingle $VALUES[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> <span class="title class_">EnumSingle</span>(<span class="string">&quot;INSTANCE&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        $VALUES = (<span class="keyword">new</span> <span class="title class_">EnumSingle</span>[] &#123;</span><br><span class="line">            INSTANCE</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-11-深入理解CAS"><a href="#7-11-深入理解CAS" class="headerlink" title="7.11 深入理解CAS"></a>7.11 深入理解CAS</h2><blockquote><p>1、什么是CAS？</p></blockquote><p>大厂必须深入研究底层！！！！<strong>修内功！操作系统、计算机网络原理、组成原理、数据结构</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">casDemo</span> &#123;</span><br><span class="line">    <span class="comment">//CAS : compareAndSet 比较并交换</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">2020</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//boolean compareAndSet(int expect, int update)</span></span><br><span class="line">        <span class="comment">//期望值、更新值</span></span><br><span class="line">        <span class="comment">//如果实际值 和 我的期望值相同，那么就更新</span></span><br><span class="line">        <span class="comment">//如果实际值 和 我的期望值不同，那么就不更新</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2020</span>, <span class="number">2021</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为期望值是2020  实际值却变成了2021  所以会修改失败</span></span><br><span class="line">        <span class="comment">//CAS 是CPU的并发原语</span></span><br><span class="line">        atomicInteger.getAndIncrement(); <span class="comment">//++操作</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2020</span>, <span class="number">2021</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727214229852.png#id=hDCKc&originHeight=236&originWidth=763&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><blockquote><p>2、Unsafe类</p></blockquote><p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727214247117.png#id=MGPCU&originHeight=279&originWidth=658&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727214300255.png#id=pt7BL&originHeight=308&originWidth=564&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>总结：</strong><br>CAS：比较当前工作内存中的值 和 主内存中的值，如果这个值是期望的，那么则执行操作！如果不是就一直循环，使用的是自旋锁。<br><strong>缺点：</strong></p><ul><li>循环会耗时；</li><li>一次性只能保证一个共享变量的原子性；</li><li>它会存在ABA问题</li></ul><blockquote><p>3、CAS：ABA问题？(狸猫换太子)</p></blockquote><p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727214320203.png#id=XGlzW&originHeight=241&originWidth=456&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>线程1：期望值是1，要变成2；<br>线程2：两个操作：</p><ul><li>1、期望值是1，变成3</li><li>2、期望是3，变成1</li></ul><p>所以对于线程1来说，A的值还是1，所以就出现了问题，骗过了线程1；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">casDemo</span> &#123;</span><br><span class="line">    <span class="comment">//CAS : compareAndSet 比较并交换</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">2020</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2020</span>, <span class="number">2021</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//boolean compareAndSet(int expect, int update)</span></span><br><span class="line">        <span class="comment">//期望值、更新值</span></span><br><span class="line">        <span class="comment">//如果实际值 和 我的期望值相同，那么就更新</span></span><br><span class="line">        <span class="comment">//如果实际值 和 我的期望值不同，那么就不更新</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2021</span>, <span class="number">2020</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为期望值是2020  实际值却变成了2021  所以会修改失败</span></span><br><span class="line">        <span class="comment">//CAS 是CPU的并发原语</span></span><br><span class="line"><span class="comment">//        atomicInteger.getAndIncrement(); //++操作</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2020</span>, <span class="number">2021</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-12-原子引用"><a href="#7-12-原子引用" class="headerlink" title="7.12 原子引用"></a>7.12 原子引用</h2><blockquote><p>1、解决ABA问题，对应的思想：就是使用了<strong>乐观锁~</strong></p></blockquote><p>带版本号的 原子操作！<br><strong>Integer 使用了对象缓存机制，默认范围是-128~127，推荐使用静态工厂方法valueOf获取对象实例，而不是new，因为valueOf使用缓存，而new一定会创建新的对象分配新的内存空间。</strong><br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727214340236.png#id=P0rSr&originHeight=157&originWidth=713&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>所以如果遇到，使用大于128的时候，<strong>使用原子引用的时候，如果超过了这个值，那么就不会进行版本上升！</strong><br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727214355541.png#id=GCd4O&originHeight=848&originWidth=1722&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>那么如果我们使用小于128的时候：<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/2020072721441445.png#id=FqTsM&originHeight=867&originWidth=1695&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>正常业务操作中，我们一般使用的是一个个对象，一般情况不会遇到这种情况。</p><h1 id="【拓展】"><a href="#【拓展】" class="headerlink" title="【拓展】"></a>【拓展】</h1><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1698075772940-56fcfcbd-06de-4cd8-95cd-d80605fe861c.png#averageHue=%23f7f6f6&clientId=ue1746809-e584-4&from=paste&height=326&id=u659424f2&originHeight=407&originWidth=681&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=100199&status=done&style=none&taskId=u78a0cfee-16e4-4427-bd73-273fcc15ffb&title=&width=544.8" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;面试题：&lt;a href=&quot;https://blog.csdn.net/qq_30999361/article/details/124545403&quot;&gt;Java并发编程面试题（123道含答案）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://p</summary>
      
    
    
    
    
    <category term="JUC" scheme="http://example.com/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JVM虚拟机</title>
    <link href="http://example.com/2024/01/18/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>http://example.com/2024/01/18/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/</id>
    <published>2024-01-18T03:00:28.866Z</published>
    <updated>2024-01-18T03:26:27.050Z</updated>
    
    <content type="html"><![CDATA[<ul><li>面试题：<a href="https://zhuanlan.zhihu.com/p/96756501">Java面试题|JVM必看15道面试题</a>、<a href="https://blog.csdn.net/qq_30999361/article/details/124532763">Java虚拟机（JVM）面试题（51道含答案）</a></li><li><strong>参数调优常用命令：</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xms1024m -Xmx1024m -XX:+printGCDetails</span><br><span class="line">-XX:+PrintGCDetails 打印GC垃圾回收信息</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError oom DUMP</span><br><span class="line">-Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError</span><br></pre></td></tr></table></figure><ul><li><strong>架构图：</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1694176140754-8081b021-2546-49f6-b3fe-91373acb6243.png#averageHue=%235f635f&clientId=ubb80744e-536d-4&from=drop&id=u7e29e382&originHeight=455&originWidth=839&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=99391&status=done&style=none&taskId=ucf2615d3-a337-4dd1-afb8-77f7a5561f7&title=" alt="45055573dd1200d7dc077dc4dda6b006.png"></p><ul><li><p>紫色区域：代表线程私有</p></li><li><p>黄色区域：代表线程共享</p></li><li><p><strong>常用的JDK的JVM参数</strong><a href="https://developer.aliyun.com/article/841137#:~:text=4%E3%80%81JVM%E8%B0%83%E4%BC%98%E7%9A%84%E6%AD%A5%E9%AA%A4%201%20%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5%EF%BC%9A%E5%88%86%E6%9E%90GC%E6%97%A5%E5%BF%97%E5%8F%8Adump%E6%96%87%E4%BB%B6%EF%BC%8C%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E4%BC%98%E5%8C%96%EF%BC%8C%E7%A1%AE%E5%AE%9A%E7%93%B6%E9%A2%88%E9%97%AE%E9%A2%98%E7%82%B9%EF%BC%9B%202%20%E7%A1%AE%E5%AE%9AJVM%E8%B0%83%E4%BC%98%E9%87%8F%E5%8C%96%E7%9B%AE%E6%A0%87%EF%BC%9B%203%20%E7%A1%AE%E5%AE%9AJVM%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0%EF%BC%88%E6%A0%B9%E6%8D%AE%E5%8E%86%E5%8F%B2JVM%E5%8F%82%E6%95%B0%E6%9D%A5%E8%B0%83%E6%95%B4%EF%BC%89%EF%BC%9B,4%20%E4%BE%9D%E6%AC%A1%E7%A1%AE%E5%AE%9A%E8%B0%83%E4%BC%98%E5%86%85%E5%AD%98%E3%80%81%E5%BB%B6%E8%BF%9F%E3%80%81%E5%90%9E%E5%90%90%E9%87%8F%E7%AD%89%E6%8C%87%E6%A0%87%EF%BC%9B%205%20%E5%AF%B9%E6%AF%94%E8%A7%82%E5%AF%9F%E8%B0%83%E4%BC%98%E5%89%8D%E5%90%8E%E7%9A%84%E5%B7%AE%E5%BC%82%EF%BC%9B%206%20%E4%B8%8D%E6%96%AD%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E8%B0%83%E6%95%B4%EF%BC%8C%E7%9B%B4%E5%88%B0%E6%89%BE%E5%88%B0%E5%90%88%E9%80%82%E7%9A%84JVM%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%EF%BC%9B%207%20%E6%89%BE%E5%88%B0%E6%9C%80%E5%90%88%E9%80%82%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%8C%E5%B0%86%E8%BF%99%E4%BA%9B%E5%8F%82%E6%95%B0%E5%BA%94%E7%94%A8%E5%88%B0%E6%89%80%E6%9C%89%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E5%B9%B6%E8%BF%9B%E8%A1%8C%E5%90%8E%E7%BB%AD%E8%B7%9F%E8%B8%AA%E3%80%82">JVM调优总结</a></p><table><thead><tr><th><strong>参数名称</strong></th><th><strong>含义</strong></th><th><strong>默认值</strong></th></tr></thead><tbody><tr><td>-Xms</td><td>初始堆大小</td><td>内存的1&#x2F;64</td></tr><tr><td>-Xmx</td><td>最大堆大小</td><td>内存的1&#x2F;4</td></tr><tr><td>-Xss</td><td>每个线程的堆栈大小</td><td></td></tr><tr><td>-Xmn</td><td>年轻代大小</td><td></td></tr><tr><td>-XX:NewSize</td><td>设置年轻代大小</td><td></td></tr><tr><td>-XX:PermSize</td><td>设置持久代初始值</td><td>内存的1&#x2F;64</td></tr><tr><td>-XX:MetaspaceSize</td><td>元空间大小</td><td></td></tr><tr><td>-XX:MaxMetaspaceSize</td><td>最大元空间</td><td></td></tr></tbody></table></li><li><p><strong>Java编译流程</strong></p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1690250016454-9157a16f-fe3a-4736-b1f8-dcf5f67bf748.png#averageHue=%23f6f6f3&clientId=u1129b39d-e584-4&from=drop&id=u752f6609&originHeight=390&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=113681&status=done&style=none&taskId=udc3a1441-e6c7-4aea-8aeb-84409c4a92a&title=" alt="20190622154747801.png"></p><h1 id="1、JVM体系结构"><a href="#1、JVM体系结构" class="headerlink" title="1、JVM体系结构"></a>1、JVM体系结构</h1><h2 id="1-1-JVM-常问面试题"><a href="#1-1-JVM-常问面试题" class="headerlink" title="1.1 JVM 常问面试题"></a>1.1 JVM 常问面试题</h2><ul><li>请你谈谈你对JVM的理解？Java8虚拟机和之前的变化更新？java—&gt;class—-&gt;jvm</li><li>什么是OOM 内存溢出？什么是栈溢出StackOverFlowError？ 怎么分析？</li><li>JVM 的常用调优参数有哪些？</li><li>内存快照如何抓取，怎么分析Dump文件？</li><li>谈谈JVM中，类加载器你的认识？</li></ul><h2 id="待定"><a href="#待定" class="headerlink" title="待定"></a>待定</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1690249994483-38938d08-00e0-44dd-a927-7feb18ad45ab.png#averageHue=%23f6f6f3&clientId=u94d46e59-58c2-4&from=drop&id=u8f1514c6&originHeight=390&originWidth=500&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=113681&status=done&style=none&taskId=ucf9b4ece-0d10-4ce9-b6d3-b9f7719688f&title=Java%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%E5%9B%BE" alt="Java代码编译流程图" title="Java代码编译流程图"></p><blockquote><p><strong>1、JVM的参数调优</strong></p></blockquote><ol><li><strong>参数调优的目的：</strong>使用较小的内存占用来获得较高的吞吐量或者较低的延迟。JVM内存调优主要的目的是<strong>减少GC的频率</strong>和<strong>Full GC的次数</strong></li><li><strong>JVM参数调优步骤</strong></li></ol><ul><li><strong>CPU指标：</strong>【JProfiler、Arthas】<ul><li>查看占用CPU最多的进程&#x2F;线程：top &#x2F; top -Hp pid</li><li>查看哪个代码、方法占用CPU执行时间最长</li></ul></li><li><strong>JVM内存指标：【</strong>Eclipse MAT、JConsole<strong>】</strong><ul><li>查看当前 JVM 堆内存参数配置：ps -ef | grep java</li><li>输出 Java 进程当前的 gc 情况：jstat -gc pid</li></ul></li><li><strong>JVM GC指标</strong>：JVM 的 GC指标一般是从 GC 日志里面查看，默认的 GC 日志可能比较少，我们可以添加以下参数，来丰富我们的GC日志输出，方便我们定位问题。</li></ul><ol start="3"><li><strong>参数调优指令：</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常用的JDK的JVM参数形式</span></span><br><span class="line"> -Xms1024m -Xmx1024m -XX:+printGCDetails  <span class="comment">//打印GC垃圾回收信息</span></span><br><span class="line"> -Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError  <span class="comment">//打印oom DUMP</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><p><strong>堆内存相关参数</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xmx：设置Java堆的最大内存大小。</span><br><span class="line">-Xms：设置Java堆的初始内存大小。</span><br><span class="line">-XX:NewSize：设置新生代的初始大小。</span><br><span class="line">-XX:MaxNewSize：设置新生代的最大大小。</span><br><span class="line">-XX:NewRatio：设置新生代与老年代的比例。</span><br></pre></td></tr></table></figure></li><li><p><strong>GC相关参数</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+UseSerialGC：启用串行垃圾回收器。</span><br><span class="line">-XX:+UseParallelGC：启用并行垃圾回收器。</span><br><span class="line">-XX:+UseConcMarkSweepGC：启用并发标记清除垃圾回收器。</span><br><span class="line">-XX:+UseG1GC：启用G1（Garbage First）垃圾回收器。</span><br><span class="line">-XX:MaxGCPauseMillis：设置最大垃圾回收停顿时间。</span><br><span class="line">-XX:GCTimeRatio：设置垃圾回收时间占总时间的比率。</span><br></pre></td></tr></table></figure></li><li><p><strong>注：GC相关参数打印</strong></p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">-XX</span>:<span class="string">+PrintGCDetails // 打印GC的详细信息</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">+PrintGCDateStamps // 打印GC的时间戳</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">+PrintHeapAtGC // 在GC前后打印堆信息</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">+PrintTenuringDistribution // 打印Survivor区中各个年龄段的对象的分布信息</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">+PrintFlagsFinal // JVM启动时输出所有参数值，方便查看参数是否被覆盖</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">+PrintGCApplicationStoppedTime // 打印GC时应用程序的停止时间</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">+PrintReferenceGC // 打印在GC期间处理引用对象的时间（仅在PrintGCDetails时启用）</span></span><br></pre></td></tr></table></figure></li><li><p><strong>线程相关参数</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xss：设置线程栈的大小。</span><br><span class="line">-XX:ThreadStackSize：设置线程栈的大小。</span><br><span class="line">-XX:ParallelGCThreads：设置并行垃圾回收期间的线程数。</span><br><span class="line">-XX:ConcGCThreads：设置并发垃圾回收期间的线程数。</span><br></pre></td></tr></table></figure></li><li><p><strong>JIT（即时编译器）相关参数</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+TieredCompilation：启用分层编译。</span><br><span class="line">-XX:+UseFastAccessorMethods：启用快速访问器方法。</span><br></pre></td></tr></table></figure></li><li><p><strong>内存区域相关参数</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:MaxDirectMemorySize：设置直接内存的最大大小。</span><br><span class="line">-XX:PermSize（在Java <span class="number">8</span>以前）/ -XX:MetaspaceSize（在Java <span class="number">8</span>及以后）：设置永久代（Java <span class="number">8</span>之前）/元空间（Java <span class="number">8</span>及以后）的初始大小。</span><br><span class="line">-XX:MaxPermSize（在Java <span class="number">8</span>以前）/ -XX:MaxMetaspaceSize（在Java <span class="number">8</span>及以后）：设置永久代（Java <span class="number">8</span>之前）/元空间（Java <span class="number">8</span>及以后）的最大大小。</span><br></pre></td></tr></table></figure></li></ul><h2 id="1-2-JVM-概念"><a href="#1-2-JVM-概念" class="headerlink" title="1.2 JVM 概念"></a>1.2 JVM 概念</h2><p>JVM是<strong>Java Virtual Machine</strong>（Java虚拟机）的缩写。<br>虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。</p><ol><li><strong>JVM体系结构（重要）</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471088771-1d24840f-0fef-43fd-83c6-256dfb1aa05a.png#averageHue=%23f8f6f6&clientId=u8523fb37-6ea0-4&from=paste&id=uea27ac44&originHeight=838&originWidth=1198&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=220474&status=done&style=none&taskId=ue7447db7-279b-4c94-a456-c4d05f6e15a&title=" alt="image.png"><br><strong>JVM调优：99%都是在方法区和堆，大部分时间调堆。</strong> JNI（java native interface）本地方法接口<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471088911-6c75854d-695f-4d74-aaf3-9b5e35cccb5a.png#averageHue=%23e8e7e6&clientId=u8523fb37-6ea0-4&from=paste&id=u145cbd4a&originHeight=862&originWidth=868&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=328323&status=done&style=none&taskId=u4534fd04-c4d2-4d75-afa2-88e28535163&title=" alt="image.png"><br>作用：加载Class文件~ 如果new Student();（具体实例在堆里，引用变量名放栈里）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471088919-226b3527-bbb6-4484-b76c-8bc66880e61d.png#averageHue=%23f6f6f6&clientId=u8523fb37-6ea0-4&from=paste&id=u21c69a84&originHeight=636&originWidth=847&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=96263&status=done&style=none&taskId=u3644700f-1a57-4a1c-b278-8c2a300c89c&title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471089210-00613a8e-787f-418c-aade-ed3078aec2ca.png#averageHue=%23f5f5f5&clientId=u8523fb37-6ea0-4&from=paste&id=ua6ae1437&originHeight=572&originWidth=876&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=67274&status=done&style=none&taskId=ua0ed8c74-df83-41c1-a77b-f79c3c6747b&title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471089866-bb2f8480-858a-4631-8d92-6ad64c479a1f.png#averageHue=%23ccc9c8&clientId=u8523fb37-6ea0-4&from=paste&id=u38700189&originHeight=474&originWidth=1183&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=293114&status=done&style=none&taskId=u441874e5-d16a-4a4c-80d1-16944ff0b42&title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471090440-91243b73-35e5-474f-82a3-1d4202381b5d.png#averageHue=%23fafaf9&clientId=u8523fb37-6ea0-4&from=paste&id=u3bc0500e&originHeight=644&originWidth=1327&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=345211&status=done&style=none&taskId=u70c075f2-cdbf-491a-8fa2-2d0100f9d05&title=" alt="image.png"></p><ol><li>虚拟机自带的加载器</li><li>启动类（根）加载器</li><li>扩展类加载器</li><li>应用程序加载器</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471091204-3c9b10b3-a59a-4515-bbe5-4f53f2de885c.png#averageHue=%23c5c8ab&clientId=u8523fb37-6ea0-4&from=paste&id=u3a235ec3&originHeight=819&originWidth=1624&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=721100&status=done&style=none&taskId=u39bbcd77-f8ac-4ee1-8d69-e4159566389&title=" alt="image.png"></p><h1 id="2、双亲委派机制"><a href="#2、双亲委派机制" class="headerlink" title="2、双亲委派机制"></a>2、双亲委派机制</h1><p>第一步：类加载器收到类加载的请求<br>第二步：将这个请求向上委托给父类加载器去完成 ，一直向上委托，直到启动类加载器（Boot）<br>第三步：启动类加载器检查是否能够加载当前和这个类 ，能加载就结束，使用当前的加载器，否则，抛出异常，通知子加载器进行加载。<br>概念：当某个类加载器需要加载某个.class文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。<br>例子：当一个Hello.class这样的文件要被加载时。不考虑我们自定义类加载器，首先会在AppClassLoader中检查是否加载过，如果有那就无需再加载了。如果没有，那么会拿到父加载器，然后调用父加载器的loadClass方法。父类中同理也会先检查自己是否已经加载过，如果没有再往上。注意这个类似递归的过程，直到到达Bootstrap classLoader之前，都是在检查是否加载过，并不会选择自己去加载。直到BootstrapClassLoader，已经没有父加载器了，这时候开始考虑自己是否能加载了，如果自己无法加载，会下沉到子加载器去加载，一直到最底层，如果没有任何加载器能加载，就会抛出ClassNotFoundException。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471090857-deba665b-8aca-4a65-a177-286bb2d7aede.png#averageHue=%23f8f7f7&clientId=u8523fb37-6ea0-4&from=paste&id=u0f19dd35&originHeight=690&originWidth=830&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=203843&status=done&style=none&taskId=uffaf7500-1e14-4878-94e6-dc16714a669&title=" alt="image.png"><br><strong>作用：</strong></p><ol><li>防止重复加载同一个.class。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。</li><li>保证核心.class不能被篡改。通过委托方式，不会去篡改核心.class，即使篡改也不会去加载，即使加载也不会是同一个.class对象了。不同的加载器加载同一个.class也不是同一个Class对象。这样保证了Class执行安全。</li></ol><p>比如：如果有人想替换系统级别的类：String.java。篡改它的实现，在这种机制下这些系统的类已经被Bootstrap classLoader加载过了（为什么？因为当一个类需要加载的时候，最先去尝试加载的就是BootstrapClassLoader），所以其他类加载器并没有机会再去加载，从一定程度上防止了危险代码的植入。<br><strong>总结：</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471090769-e7d5e2d0-08bf-404f-869b-b0577c288c33.png#averageHue=%23c2dcb4&clientId=u8523fb37-6ea0-4&from=paste&id=u7f780647&originHeight=195&originWidth=980&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=118016&status=done&style=none&taskId=udb3f4fe3-46a8-4f50-a164-228f8ae34a7&title=" alt="image.png"></p><h1 id="3、沙箱安全机制"><a href="#3、沙箱安全机制" class="headerlink" title="3、沙箱安全机制"></a>3、沙箱安全机制</h1><p>1、概述<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471091780-72b9f483-da2a-43fe-af07-2d9c8574f09c.png#averageHue=%23f7f7f6&clientId=u8523fb37-6ea0-4&from=paste&id=u7c25cd88&originHeight=697&originWidth=1210&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=635348&status=done&style=none&taskId=u2e44754a-806c-418f-afbf-d7eae3b1c8b&title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471092305-dabe8c88-d984-40cf-8052-de7837e58a88.png#averageHue=%23f7f6f6&clientId=u8523fb37-6ea0-4&from=paste&id=u23aa90b0&originHeight=485&originWidth=1169&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=283705&status=done&style=none&taskId=uc6f05d11-6da6-4341-addd-19f93b65415&title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471092810-7f3bc0f6-17af-491e-8cd4-fbea00a7c953.png#averageHue=%23f7f7f6&clientId=u8523fb37-6ea0-4&from=paste&id=u0917f13c&originHeight=637&originWidth=1193&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=328530&status=done&style=none&taskId=u8b415b55-ff9a-43a2-b5b6-81f5d49d66c&title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471092873-90579a0a-455f-4a12-b5ea-feeb172dcceb.png#averageHue=%23f5f4f4&clientId=u8523fb37-6ea0-4&from=paste&id=uc4890f33&originHeight=495&originWidth=1185&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=414680&status=done&style=none&taskId=ua302640c-7900-4017-9b0a-4f2fd5d28eb&title=" alt="image.png"><br>2、组成沙箱的基本组件：</p><ul><li><strong>字节码校验器</strong>（bytecode verifier）：确保Java类文件.Class遵循Java语言规范。这样可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。</li><li>类装载器（class loader）：其中类装载器在3个方面对Java沙箱起作用<ul><li>它防止恶意代码去干涉善意的代码；</li><li>它守护了被信任的类库边界；</li><li>它将代码归入保护域，确定了代码可以进行哪些操作。</li></ul></li></ul><p>虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每一个被装载的类将有一个名字，这个命名空间是由Java虚拟机为每一个类装载器维护的，它们互相之间甚至不可见。<br>类装载器采用的机制是<strong>双亲委派模式</strong>。</p><ol><li>从最内层JVM自带类加载器开始加载，外层恶意同名类得不到加载从而无法使用；</li><li>由于严格通过包来区分了访问域，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。</li></ol><ul><li><strong>存取控制器</strong>（access controller）：存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定，可以由用户指定。</li><li><strong>安全管理器</strong>（security manager）：是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。</li><li><strong>安全软件包</strong>（security package）：java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括：</li></ul><ol><li>安全提供者</li><li>消息摘要</li><li>数字签名 keytools https(需要证书)</li><li>加密</li><li>鉴别</li></ol><h1 id="4、Native【-】"><a href="#4、Native【-】" class="headerlink" title="4、Native【*】"></a>4、Native【*】</h1><ul><li>Native是核心，能把面试官唬住的东西。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471093056-1b8d9198-06c5-4a05-b39f-0576882eb1cb.png#averageHue=%23fbfaf4&clientId=u8523fb37-6ea0-4&from=paste&id=u8eac4a11&originHeight=500&originWidth=907&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=290114&status=done&style=none&taskId=u2eb1ccb8-382e-45dc-ab17-ff6aa4dbaad&title=" alt="image.png"><br>凡是带了native 关键字的，说明java的作用范围达不到了，得回去调用底层C语言的库！<br>凡是带了native 关键字的方法会进入<strong>本地方法栈</strong>，其它的是java栈</p><ul><li><strong>JNI：Java Native Interface（本地方法接口）</strong><ul><li>调用本地方法接口（JNI）作用：扩展java的使用，融合不同的编程语言为java所用java诞生的初衷是<strong>融合C&#x2F;C++程序</strong>，C、C++横行，想要立足，必须要有调用C、C++的程序~它在内存区城中专门开辟了块标记区城:<strong>Native Method Stack</strong></li></ul></li><li><strong>Native Method Stack（本地方法栈）</strong>：</li></ul><p>登记native 方法，在执行引擎（Execution Engine）执行的时候。通过JNI 加载**本地方法库(Native Libraies)**中的方法。<br>在企业级应用中少见，与硬件有关应用：java程序驱动打印机，系统管理生产设备等，掌握即可</p><h1 id="5、PC寄存器"><a href="#5、PC寄存器" class="headerlink" title="5、PC寄存器"></a>5、PC寄存器</h1><ul><li><strong>程序计数器: Program Counter Register</strong>：</li></ul><p>每个线程都有一个程序计数器，是线程私有的，就是一个指针， 指向方法区中的方法字节码 ( 用来存储指向下一条指令的地址， 也即将要执行的指令代码 )， 在执行引擎读取下一条指令,是一个非常小的内存空间，几乎可以忽略不计。</p><h1 id="6、方法区"><a href="#6、方法区" class="headerlink" title="6、方法区"></a>6、方法区</h1><ul><li><strong>Method Area方法区：</strong></li></ul><p>方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义,简单说，所有定义的方法的信息都保存在该区域，此区域属于共享区间；<br><strong>静态变量、常量、类信息(构造方法、接口定义)、运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关</strong>。<br>如：static，final，Class（类模板）, 常量池<br><strong>面试题：</strong>一张白纸，画出对象实例化过程的内存图。（主要是考你对JVM的理解）<img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471093156-afc3dab1-fafb-43c0-92d2-d95beef44b12.png#averageHue=%23f6f6f6&clientId=u8523fb37-6ea0-4&from=paste&id=u78a49b0e&originHeight=406&originWidth=578&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=52015&status=done&style=none&taskId=uf0ebfc88-20dd-4a06-a42d-b92c87dcf98&title=" alt="image.png"><br>类模板，常量池，引用的话进入左边，去引入真实的对象</p><h1 id="7、栈"><a href="#7、栈" class="headerlink" title="7、栈"></a>7、栈</h1><ol><li>栈：数据结构程序&#x3D;数据结构+算法：持续学习<del>程序&#x3D;框架+业务逻辑：吃饭</del></li><li>栈：<strong>先进后出、后进先出</strong>：桶队列：先进先出 ( FIFO )：管喝多了吐就是栈，吃多了拉就是队列为什么main() 先执行，最后结束? （因为一开始<strong>mian()先压入栈</strong>）</li><li>栈：栈内存，主管程序的运行，生命周期和线程同步;线程结束，栈内存也就是释放，<strong>对于栈来说，不存在垃圾回收问题</strong>一旦线程结束，栈就Over!</li><li>栈存放：8大基本类型+对象引用+实例的方法栈运行原理：栈帧（局部变量表+操作数栈）<strong>每调用一个方法都有一个栈帧</strong>栈满了 main()无法结束，会抛出错误：<strong>栈溢出 StackOverflowError</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471093654-23e38158-9b74-48c9-a4ae-44d2276ae0ef.png#averageHue=%23d9d8d7&clientId=u8523fb37-6ea0-4&from=paste&id=u6f72fc57&originHeight=447&originWidth=435&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=51658&status=done&style=none&taskId=u10e17da8-7484-42a9-9463-baeb76dc7d4&title=" alt="image.png"><br><strong>栈帧图：</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471094236-3c801450-244c-44a0-b088-144052f9850c.png#averageHue=%23ebeae0&clientId=u8523fb37-6ea0-4&from=paste&id=u0ae419e7&originHeight=762&originWidth=947&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=212316&status=done&style=none&taskId=u4c58f5b8-7144-4675-b322-4ea7519c547&title=" alt="image.png"><br>栈 + 堆 + 方法区：交互关系<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471094683-8567cc62-ddd1-4bf5-9d29-da922c17fe04.png#averageHue=%23d0d1ce&clientId=u8523fb37-6ea0-4&from=paste&id=u28fdb859&originHeight=622&originWidth=1010&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=174389&status=done&style=none&taskId=u4d78fdb7-9f11-4baf-9219-4978824ba43&title=" alt="image.png"></p><h1 id="8、堆【-】"><a href="#8、堆【-】" class="headerlink" title="8、堆【*】"></a>8、堆【*】</h1><p>Heap：一个JVM只有一个堆内存，堆的大小是可以调节的。<br>类加载器读取了类文件后，一般会把什么东西放到堆中？<br>类，方法，常量，变量~，保存所有引用类型的真实对象</p><ul><li>堆内存细分3个区域：<ul><li>新生区（伊甸园区） Young&#x2F;new</li><li>养老区 old</li><li>永久区 Perm</li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471094705-d27052f6-5750-42c7-b615-7673b456a70f.png#averageHue=%23f8f8f8&clientId=u8523fb37-6ea0-4&from=paste&id=u29dc4e99&originHeight=657&originWidth=896&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=107806&status=done&style=none&taskId=ud46b7fde-5f23-4089-a155-f2a760cedb6&title=" alt="image.png"><br><strong>GC垃圾回收，主要是在伊甸园区和养老区~</strong><br><strong>假设内存满了，报错OOM，堆内存不够！</strong>OutOfMemoryError:Java heap space<br><strong>在JDK8以后，永久存储区改了个名字(元空间)</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471094973-9e19a358-b8ac-4e46-b6d7-bd198e854499.png#averageHue=%23f2ecde&clientId=u8523fb37-6ea0-4&from=paste&id=u7b2e556d&originHeight=704&originWidth=1451&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=449152&status=done&style=none&taskId=u989a1e83-94f2-422c-a18f-86e5b347279&title=" alt="image.png"></p><h2 id="8-1-概念"><a href="#8-1-概念" class="headerlink" title="8.1 概念"></a>8.1 概念</h2><blockquote><p>1、新生区、老年区、永久区</p></blockquote><p><strong>新生区</strong>（伊甸园+幸存者区*2）</p><ul><li>类诞生和成长甚至死亡的地方；</li><li>伊甸园，所有对象都是在伊甸园区new出来的！</li><li>幸存者区（0, 1），<strong>轻GC</strong>定期清理伊甸园，活下来的放入幸 存者区，幸存者区满了之后<strong>重GC</strong>清理 伊甸园+幸存者区，活下来的放入养老区。都满了就报OOM。</li></ul><p>真理：经过研究，99%的对象都是临时对象！直接被清理了<br><strong>老年区：</strong> 新生区剩下来的，轻GC杀不死了。<br><strong>永久区：</strong><br>这个区域常驻内存，用来存放JDK自身携带的Class对象，Interface元数据，存储的是java运行时的一些环境或类信息，<strong>该区域不存在垃圾回收GC</strong>。<strong>关闭虚拟机就会释放这个内存。</strong></p><ul><li>jdk1.6之前：永久代，常量池在方法区</li><li>jdk1.7：永久代，但是慢慢退化了（去永久代）常量池在堆中</li><li>jdk1.8之后：无永久代，常量池在元空间</li></ul><p>一个启动类,加载了大量的第三方jar包。Tomcat部署了太多的应用，大量动态生成的反射类。不断的被加载。直到内存满，就会出现OOM。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471094733-789f7291-db4f-4163-9b18-7d330bb53515.png#averageHue=%2393edf1&clientId=u8523fb37-6ea0-4&from=paste&id=u82142d40&originHeight=313&originWidth=1021&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=79179&status=done&style=none&taskId=ua03747a9-6bbf-4db1-a148-9491740701b&title=" alt="image.png"><br>方法区又称非堆(non-heap)，本质还是堆，只是为了区分概念。<br><strong>元空间逻辑上存在，物理上并不存在。</strong></p><ul><li>测试JVM分配的堆内存</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471095883-9fa9a1b9-8949-4084-890a-37023e7f7a0c.png#averageHue=%23f4f2e7&clientId=u8523fb37-6ea0-4&from=paste&id=ub7cf62e2&originHeight=517&originWidth=1144&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=330106&status=done&style=none&taskId=uce44af22-2069-404d-a365-bbd280165bd&title=" alt="image.png"></p><ul><li>堆内存分配结论：</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471095750-bfa118d7-171e-4b57-9691-e51e0efcd951.png#averageHue=%23fefefb&clientId=u8523fb37-6ea0-4&from=paste&id=u17f4ff77&originHeight=130&originWidth=684&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=40429&status=done&style=none&taskId=u6a7cd05f-ccc4-45ee-ba11-35c088804a8&title=" alt="image.png"></p><ul><li><strong>参数调优</strong></li></ul><p> -Xms1024m -Xmx1024m -XX:+printGCDetails<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471095951-f07249db-3ad1-4f74-aba4-74af4da71d89.png#averageHue=%23f3f0ef&clientId=u8523fb37-6ea0-4&from=paste&id=u09cbb12f&originHeight=477&originWidth=707&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=135601&status=done&style=none&taskId=ua78a9580-4a91-466d-ab12-1e3c2ff6222&title=" alt="image.png"></p><ul><li>参数调优结果</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471096464-d02dccff-b779-44a1-adb0-adda7b2c77d4.png#averageHue=%23e7e5dd&clientId=u8523fb37-6ea0-4&from=paste&id=u1d28a805&originHeight=518&originWidth=941&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=435106&status=done&style=none&taskId=u89c0b09a-4884-4b1d-8751-063f8d9049a&title=" alt="image.png"><br><strong>扩展：</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471096793-d3cc4e48-9586-435b-97a0-e245a709b251.png#averageHue=%23f3f0ed&clientId=u8523fb37-6ea0-4&from=paste&id=u115fe0ed&originHeight=256&originWidth=841&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=36698&status=done&style=none&taskId=u0d302ec5-80d5-4ce6-ac93-96a999b9bc5&title=" alt="image.png"><br>一句话：常量池一直在方法区，其中的字符串池 JDK1.7之后保存到了堆中。</p><h2 id="8-2-堆内存调优"><a href="#8-2-堆内存调优" class="headerlink" title="8.2 堆内存调优"></a>8.2 堆内存调优</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//返回虚拟机试图使用的最大内存</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">max</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory(); <span class="comment">//字节 1024*1024</span></span><br><span class="line">    <span class="comment">//返回jvm初始化的总内存</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;max=&quot;</span>+max+<span class="string">&quot;字节\t&quot;</span>+(max/(<span class="type">double</span>)<span class="number">1024</span>/<span class="number">1024</span>+<span class="string">&quot;MB&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;total=&quot;</span>+total+<span class="string">&quot;字节\t&quot;</span>+(total/(<span class="type">double</span>)<span class="number">1024</span>/<span class="number">1024</span>+<span class="string">&quot;MB&quot;</span>));</span><br><span class="line">    <span class="comment">/* 运行后：</span></span><br><span class="line"><span class="comment">max=1866465280字节   1780.0MB</span></span><br><span class="line"><span class="comment">total=126877696字节  121.0MB</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">//默认情况下，分配的总内存占电脑内存1/4 初始化1/64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>面试题：报OOM怎么办？<ul><li>尝试扩大堆内存，如果还报错，说明有死循环代码 或垃圾代码</li><li>分析内存，看一下哪个地方有问题（专业工具）</li></ul></li><li>扩大内存方法：<ul><li>Edit Configration&gt;add VM option&gt;</li><li>输入：-Xms1024m -Xmx1024m -XX:+PrintGCDetails</li></ul></li></ul><p>再次运行：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471097498-fee8da77-17f9-41c8-bb64-82f260f07ee7.png#averageHue=%23f0ebe8&clientId=u8523fb37-6ea0-4&from=paste&id=u18201505&originHeight=392&originWidth=1272&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=63558&status=done&style=none&taskId=u9ca2fd85-e6fa-45d9-a083-881c194208f&title=" alt="image.png"><br><strong>新生区+养老区</strong>：305664K+699392K&#x3D;1005056K &#x3D; <strong>981.5M</strong><br>说明元空间物理并不存在。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-Xms8m -Xmx8m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;kuangshensayjava&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        str += str + <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">888888888</span>)+ <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">21_0000_0000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471097578-f8854311-f26e-4775-a686-a31008af7577.png#averageHue=%23e9e5e1&clientId=u8523fb37-6ea0-4&from=paste&id=u43ac0ef9&originHeight=701&originWidth=1239&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=147718&status=done&style=none&taskId=u4b3027de-b8e0-49d3-8aa7-d7e0c618e95&title=" alt="image.png"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="8-3-Jprofiler"><a href="#8-3-Jprofiler" class="headerlink" title="8.3 Jprofiler"></a>8.3 Jprofiler</h2><p>在一个项目中，突然出现了OOM故障，该如何排除，研究为什么出错~</p><ul><li>能够看到代码第几行出错：内存快照分析工具，MAT，Jprofiler</li><li>Debug，一行行分析代码！</li></ul><p>MAT，Jprofiler作用：</p><ul><li>分析Dump内存文件，快速定位内存泄漏；</li><li>获得堆中的数据</li><li>获得大的对象<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-Xms 设置初始化内存分配大小 默认1/64</span></span><br><span class="line"><span class="comment">//-Xmx 设置最大分配内存，默认1/4</span></span><br><span class="line"><span class="comment">//-XX:+PrintGCDetails 打印GC垃圾回收信息</span></span><br><span class="line"><span class="comment">//-XX:+HeapDumpOnOutOfMemoryError oom DUMP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] array = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span>*<span class="number">1024</span>*<span class="number">1024</span>]; <span class="comment">//1m</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Demo03&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">Demo03</span>()); <span class="comment">//不停地把创建对象放进列表</span></span><br><span class="line">                count = count + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;count: &quot;</span>+count);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471097564-643b2c40-7199-4e4c-857a-72c315b0989c.png#averageHue=%23f5f3f1&clientId=u8523fb37-6ea0-4&from=paste&id=u44e8e7de&originHeight=448&originWidth=1037&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=76680&status=done&style=none&taskId=uc8f515f5-9268-4cae-994d-440493d085a&title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471098524-cea360a8-8b25-46f4-a393-977fcbe6c6b1.png#averageHue=%23f5f3f2&clientId=u8523fb37-6ea0-4&from=paste&id=u5e0097c1&originHeight=1021&originWidth=1482&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=447781&status=done&style=none&taskId=uce471880-269d-4c22-a0b0-b6e37ee5574&title=" alt="image.png"></li></ul><h1 id="9、GC：垃圾回收【-】"><a href="#9、GC：垃圾回收【-】" class="headerlink" title="9、GC：垃圾回收【*】"></a>9、GC：垃圾回收【*】</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471098260-36a7cfbb-fc3c-4ec9-904c-fba2f8e366c8.png#averageHue=%23f5f2f2&clientId=u8523fb37-6ea0-4&from=paste&id=uaa600c95&originHeight=642&originWidth=1002&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=61238&status=done&style=none&taskId=u8c7d27a8-f5dd-4fc5-948a-2e822fc2704&title=" alt="image.png"><br>JVM在进行GC时，并不是对这三个区域统一回收。大部分时候回收的是新生代</p><ul><li>新生代</li><li>幸存区</li><li>老年区</li></ul><p>GC两种：轻GC，重GC (Full GC，全局GC)<br>关于GC面试题：</p><ul><li>JVM的内存模型和分区~详细到每个分区放什么？</li><li>堆里面的分区有哪些？Eden, from, to, 老年区，说说它们的特点！</li><li>GC算法有哪些？怎么用的？<ul><li><strong>标记清除法</strong>，标记整理，<strong>复制算法</strong>，分代收集法。</li><li>引用计数法。</li></ul></li><li>轻GC与重GC分别在什么时候发生？</li></ul><p><strong>引用计数法</strong>：一般JVM不用，大型项目对象太多了<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471098723-1b57de91-52f2-49ed-8a0f-fd849f467ac0.png#averageHue=%23f1f1f1&clientId=u8523fb37-6ea0-4&from=paste&id=ua028a3a3&originHeight=336&originWidth=811&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=53578&status=done&style=none&taskId=u779ed00e-1039-4b99-bd56-3837c878095&title=" alt="image.png"></p><h2 id="9-1-复制算法"><a href="#9-1-复制算法" class="headerlink" title="9.1 复制算法"></a>9.1 复制算法</h2><ul><li>-XX:MaxTenuringThreshold&#x3D;15 设置进入老年代的存活次数条件</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471099207-ef281c2f-8ffd-4f65-a801-69a162c0ae7d.png#averageHue=%23f7f4da&clientId=u8523fb37-6ea0-4&from=paste&id=u56b6f573&originHeight=731&originWidth=825&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=223680&status=done&style=none&taskId=u402d0fb9-a9d2-4378-8fd9-2666f2082f8&title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471099596-41a3b326-56d9-4d97-b17c-91d7c86dc183.png#averageHue=%23d4e867&clientId=u8523fb37-6ea0-4&from=paste&id=u3114a0c6&originHeight=559&originWidth=1206&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=181152&status=done&style=none&taskId=ua26b4b9c-f9ff-4f51-ad94-53de847e047&title=" alt="image.png"></p><ul><li>好处：没有内存的碎片，内存效率高</li><li>坏处：浪费了内存空间（一个幸存区永远是空的）；假设对象100%存活，复制成本很高。</li></ul><p>复制算法最佳使用场景：对象存活度较低 的时候，<strong>新生区</strong>~。</p><h2 id="9-2-标记清除算法"><a href="#9-2-标记清除算法" class="headerlink" title="9.2 标记清除算法"></a>9.2 标记清除算法</h2><ul><li>标记清除</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471099787-7d7bb468-6819-475c-97b5-4157f23cec2f.png#averageHue=%23f6f4d6&clientId=u8523fb37-6ea0-4&from=paste&id=uf96f152f&originHeight=495&originWidth=757&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=110011&status=done&style=none&taskId=ue88f3b21-42d5-4085-8680-b3914417a14&title=" alt="image.png"></p><ul><li>优点：不需要额外空间，优化了复制算法。</li><li>缺点：两次扫描，严重浪费时间，会产生内存碎片。</li></ul><p>标记压缩（标记整理）<strong>：再优化</strong></p><ul><li>三部曲：标记–清除–压缩</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471100863-f2fb021f-75d2-473e-b1af-3e3ad783321b.png#averageHue=%23f9f8ea&clientId=u8523fb37-6ea0-4&from=paste&id=u8fd2e1c6&originHeight=768&originWidth=1427&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=309419&status=done&style=none&taskId=uaf93fb83-6d1b-49c5-8fd6-455f9cb66db&title=" alt="image.png"><br>标记清除压缩：再优化</p><ul><li>每标记清除几次就压缩一次，或者内存碎片积累到一定程度就压缩。</li></ul><h2 id="9-3-总结"><a href="#9-3-总结" class="headerlink" title="9.3 总结"></a>9.3 总结</h2><p>内存效率：复制算法&gt;标记清除算法&gt;标记压缩算法（时间复杂度）<br>内存整齐度：复制算法&#x3D;标记压缩算法&gt;标记清除算法<br>内存利用率：标记压缩算法&#x3D;标记清除算法&gt;复制算法<br>难道没有最优算法吗？<br>答案：无，没有最好的算法，只有合适的算法（GC也被称为<strong>分代收集算法</strong>）。</p><ul><li>年轻代：存活率低，用<strong>复制算法</strong>。</li><li>老年代：存活率高，区域大，用<strong>标记-清除-压缩</strong>。</li></ul><p>参考和研究：《深入理解Java虚拟机》</p><h1 id="10、-JMM"><a href="#10、-JMM" class="headerlink" title="10、 JMM"></a>10、 JMM</h1><ol><li>什么是JMM? ：百度java内存模型 Java Memory Model</li><li>它干嘛的？ 学习途径：官方，其他人的博客，教学视频<a href="https://www.sohu.com/a/420276955_612370">https://www.sohu.com/a/420276955_612370</a>作用：缓存一致性协议，用于定义数据读写的规则。JMM定义了线程工作内存和主内存之间的抽象关系：线程之间的私有变量存储在主内存中， 每个线程都有一个私有的本地变量。<img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686471100923-a7709547-de53-400b-8f9f-5c1232a1a0b2.png#averageHue=%23efefef&clientId=u8523fb37-6ea0-4&from=paste&id=u3b6d2212&originHeight=290&originWidth=650&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=46621&status=done&style=none&taskId=u7b069c0a-e124-4f64-8af5-8963313e7dd&title=" alt="image.png">解决共享对象可见性这个问题:volilate</li><li>如何学会它？</li></ol><ul><li>lock(锁定)，作用于<strong>主内存</strong>中的变量，把变量标识为线程独占的状态。</li><li>read(读取)，作用于<strong>主内存</strong>的变量，把变量的值从主内存传输到线程的工作内存中，以便下一步的load操作使用。</li><li>load(加载)，作用于<strong>工作内存</strong>的变量，把read操作主存的变量放入到工作内存的变量副本中。</li><li>use(使用)，作用于<strong>工作内存</strong>的变量，把工作内存中的变量传输到执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li><li>assign(赋值)，作用于<strong>工作内存</strong>的变量，它把一个从执行引擎中接受到的值赋值给工作内存的变量副本中，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作。</li><li>store(存储)，作用于<strong>工作内存</strong>的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用。</li><li>write(写入)：作用于<strong>主内存</strong>中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li><li>unlock(解锁)：作用于<strong>主内存</strong>的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li></ul><p>我再补充一下JMM对8种内存交互操作制定的规则吧：</p><ul><li>不允许read、load、store、write操作之一单独出现，也就是read操作后必须load，store操作后必须write。</li><li>不允许线程丢弃他最近的assign操作，即工作内存中的变量数据改变了之后，必须告知主存。</li><li>不允许线程将没有assign的数据从工作内存同步到主内存。</li><li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过load和assign操作。</li><li>一个变量同一时间只能有一个线程对其进行lock操作。多次lock之后，必须执行相同次数unlock才可以解锁。</li><li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值。在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值。</li><li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量。</li><li>一个线程对一个变量进行unlock操作之前，必须先把此变量同步回主内存。再补充一下JMM对8种内存交互操作制定的规则吧：</li><li>不允许read、load、store、write操作之一单独出现，也就是read操作后必须load，store操作后必须write。</li><li>不允许线程丢弃他最近的assign操作，即工作内存中的变量数据改变了之后，必须告知主存。</li><li>不允许线程将没有assign的数据从工作内存同步到主内存。</li><li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过load和assign操作。</li><li>一个变量同一时间只能有一个线程对其进行lock操作。多次lock之后，必须执行相同次数unlock才可以解锁。</li><li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值。在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值。</li><li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量。</li><li>一个线程对一个变量进行unlock操作之前，必须先把此变量同步回主内存。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;面试题：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/96756501&quot;&gt;Java面试题|JVM必看15道面试题&lt;/a&gt;、&lt;a href=&quot;https://blog.csdn.net/qq_30999361/article/deta</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程</title>
    <link href="http://example.com/2024/01/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://example.com/2024/01/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2024-01-18T03:00:10.504Z</published>
    <updated>2024-01-18T03:27:39.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AQS（AbstractQueuedSynchronizer）是Java并发包中的一个重要类，用于实现同步器和锁的基础组件。下面是AQS底层原理的简要解释：</p><ol><li>AQS的核心思想是一个FIFO队列，用于管理线程的获取和释放资源的顺序。</li><li>AQS通过内部的一个volatile状态变量来表示资源的占用情况，以及线程等待队列的状态。</li><li>AQS提供了两种操作方式：独占模式（Exclusive）和共享模式（Shared）。独占模式适用于只有一个线程能够访问资源的场景，而共享模式适用于多个线程可以同时访问资源的场景。</li><li>当线程尝试获取资源时，会先通过CAS操作修改AQS的状态变量，如果成功获取资源，则可以继续执行；否则，线程会被加入等待队列，并进入阻塞状态。</li><li>当资源被释放时，需要通知等待队列中的第一个线程可以继续执行。这个过程可以通过CAS操作来保证只有一个线程获取到通知，并唤醒。</li><li>AQS的子类可以通过继承AQS并重写指定的方法来实现自定义的同步器，例如ReentrantLock和Semaphore等。</li></ol><p>总的来说，AQS通过使用内部状态变量、等待队列和CAS操作，实现了线程的排队等待和唤醒机制，进而提供了可靠的同步和互斥操作。这一机制为Java中各种锁的实现提供了重要的基础支持。</p><h1 id="1、并发-多线程概念-⭐"><a href="#1、并发-多线程概念-⭐" class="headerlink" title="1、并发&#x2F;多线程概念 ⭐"></a>1、并发&#x2F;多线程概念 ⭐</h1><h2 id="1-1-常见概念"><a href="#1-1-常见概念" class="headerlink" title="1.1 常见概念"></a>1.1 常见概念</h2><ol><li><strong>线程与进程：</strong><br>:::tips</li></ol><ul><li><p><strong>进程：</strong>是正在运行的程序<br>是系统进行<strong>资源分配</strong>和<strong>调用</strong>的<strong>独立单位</strong><br>每一个进程都有它自己的<strong>内存空间</strong>和<strong>系统资源</strong> </p></li><li><p><strong>线程：</strong>是进程中的单个顺序控制流，是一条执行路径（Java默认 Main 和 GC 进程）<br>单线程：一个进程如果只有一条执行路径，则称为单线程程序<br>多线程：一个进程如果有多条执行路径，则称为多线程程序<br>:::<br>2.<strong>多线程&#x2F;并发区别：</strong><br>:::tips</p></li><li><p><strong>多线程：指在一个程序中同时执行多个线程</strong>，每个线程都是独立的执行路径，可以并发执行。多线程的目的是为了充分利用多核CPU或多个处理器的资源，提高程序的执行效率和并行处理能力。</p></li><li><p><strong>并发：指多个任务在同一个时间段内交替执行</strong>，通过时间片轮转或者其他调度算法来实现任务间的切换。并发的主要目的是尽量减少任务等待时间，提高系统整体的效率和响应能力。</p></li></ul><p>因此，<strong>多线程是实现并发的一种方式，但并发不仅限于多线程</strong>。在Java中，我们可以通过多线程编写并发程序，但也可以通过其他机制（比如使用非阻塞IO、异步编程或并发集合等）来实现并发操作。<br>:::</p><h2 id="1-2-并发三要素-可见-原子-有序"><a href="#1-2-并发三要素-可见-原子-有序" class="headerlink" title="1.2 并发三要素(可见&#x2F;原子&#x2F;有序)"></a>1.2 并发三要素(可见&#x2F;原子&#x2F;有序)</h2><p><strong>为什么需要多线程？</strong>众所周知，CPU、内存、I&#x2F;O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为:</p><ul><li>CPU 增加了缓存，以均衡与内存的速度差异；**&#x2F;&#x2F; 可见性问题**</li><li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I&#x2F;O 设备的速度差异；**&#x2F;&#x2F; 原子性问题**</li><li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。**&#x2F;&#x2F; 有序性问题**<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadSize</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="type">ThreadUnsafeExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadUnsafeExample</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadSize);</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.println(example.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">997</span> <span class="comment">// 结果总是小于1000</span></span><br></pre></td></tr></table></figure></li></ul><p>上述代码输出为什么不是1000? 并发出现问题的根源是什么?<br>:::tips<br><strong>可见性</strong>【CPU缓存引起】：一个线程对共享变量的修改，另外一个线程能够立刻看到<br><strong>原子性</strong>【分时复用引起】：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行<br><strong>有序性</strong>【重排序引起】：即程序执行的顺序按照代码的先后顺序执行<br>:::</p><ol><li><p><strong>可见性：</strong>一个线程对共享变量的修改，另外一个线程能够立刻看到</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//线程1执行的代码</span></span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">j = i;<span class="comment">//线程2执行的代码</span></span><br></pre></td></tr></table></figure><p>:::tips<br>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i &#x3D;10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。<br>此时线程2执行 j &#x3D; i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10。<br>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。<img src="https://cdn.nlark.com/yuque/0/2023/webp/35382725/1697201091520-a1f3af55-b86d-4161-845c-dbf1b91099db.webp#averageHue=%23ecf1e4&clientId=u17b23df9-2b95-4&from=drop&height=289&id=u702ce5e8&originHeight=382&originWidth=443&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=8666&status=done&style=none&taskId=u25ba13b7-b427-440d-b3e5-bf707260619&title=&width=335" alt="v2-a1a75c9f7264cf78d0927663371ca9d2_720w.webp"><br>:::<br><strong>解决方案（JMM）：</strong>Java内存模型只保证了<strong>基本读取</strong>和<strong>赋值</strong>是原子性操作，如果要实现更大范围操作的原子性，可以通过<strong>synchronized和Lock</strong>来实现。由于synchronized和Lock能够<strong>保证任一时刻只有一个线程执行该代码块</strong>，那么自然就不存在原子性问题了，从而保证了原子性。</p></li><li><p><strong>原子性：</strong>即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">i += <span class="number">1</span>;<span class="comment">// 线程1执行</span></span><br><span class="line">i += <span class="number">1</span>;<span class="comment">// 线程2执行</span></span><br></pre></td></tr></table></figure><p>:::tips<br>i +&#x3D; 1需要三条 CPU 指令</p></li><li><p>将变量 i 从内存读取到 CPU寄存器；</p></li><li><p>在CPU寄存器中执行 i + 1 操作；</p></li><li><p>将最后的结果i写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。</p></li></ol><p>由于CPU分时复用（线程切换）的存在，线程1执行了第一条指令后，就切换到线程2执行，假如线程2执行了这三条指令后，再切换会线程1执行后续两条指令，将造成最后写到内存中的i值是2而不是3。<br>:::<br><strong>解决方案（JMM）：synchronized和Lock</strong>能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p><ol start="3"><li><strong>有序性：</strong>即程序执行的顺序按照代码的先后顺序执行<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;              </span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">i = <span class="number">1</span>;                <span class="comment">//语句1  </span></span><br><span class="line">flag = <span class="literal">true</span>;          <span class="comment">//语句2</span></span><br></pre></td></tr></table></figure><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697025193996-8df5aa17-2994-4f68-b74b-a9ac06703ccb.png#averageHue=%23efeeed&clientId=u4831536b-25c6-4&from=drop&id=DoraY&originHeight=76&originWidth=529&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=1676&status=done&style=none&taskId=u23f4b427-5265-4fab-b8bd-7028243eb09&title=" alt="java-jmm-3.png"><br>:::tips<br>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</li></ol><ul><li><strong>编译器优化</strong>的重排序<strong>。</strong>编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li><strong>指令级并行</strong>的重排序<strong>。</strong>现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li><strong>内存系统</strong>的重排序<strong>。</strong>由于处理器使用缓存和读 &#x2F; 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。<br>:::<br><strong>解决方案（JMM）：synchronized和Lock</strong>保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。当然JMM是通过Happens-Before 规则来保证有序性的。</li></ul><h2 id="1-3-如何解决并发：JMM"><a href="#1-3-如何解决并发：JMM" class="headerlink" title="1.3 如何解决并发：JMM"></a>1.3 如何解决并发：JMM</h2><p><a href="https://zhuanlan.zhihu.com/p/29881777">Java内存模型（JMM）总结</a></p><ul><li>JMM（Java Memory Model）：Java内存模型<br>:::tips<br>JMM 规范了 JVM 如何提供按需禁用缓存和编译优化的方法，方法如下：</li></ul><ol><li><p><strong>synchronized、volatile 和 final 三个关键字</strong></p></li><li><p>Happens-Before 规则（×）<br>:::</p></li><li><p><strong>synchronized（看互斥同步模块）</strong></p></li><li><p><strong>volatile：</strong><br>:::tips<br><strong>可见性：</strong>引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。volatile关键字能有效的解决这个问题<br><strong>原子性：</strong>volatile是无法保证原子性的，只能保证单次的读&#x2F;写操作具有原子性。i++其实是一个复合操作，因此不能保证i++的原子性<br><strong>有序性：单例模式！</strong>采用双重检查加锁(DCL)的方式来实现<br>:::</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有序性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton; <span class="comment">//【核心】</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数私有，禁止外部实例化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>final：修饰类&#x2F;方法&#x2F;参数&#x2F;变量</strong><br>:::tips</p></li><li><p><strong>修饰类：</strong>当某个类的整体定义为final时，就表明这个类是不能有子类的。</p><ul><li>注意：final类中的所有方法都隐式为final，在final类中给任何方法添加final关键字是没有任何意义的</li></ul></li><li><p><strong>方法：</strong>private 方法是隐式的final（类中所有private方法都隐式地指定为final的，由于无法取用private方法，所以private不用加final）</p><ul><li>注意：final方法是可以被重载的</li></ul></li><li><p><strong>参数：</strong>Java允许在参数列表中以声明的方式将参数指明为final，这意味这你无法在方法中更改参数引用所指向的对象。这个特性主要用来向匿名内部类传递数据。</p></li><li><p><strong>变量：</strong>太简单不阐述<br>:::</p></li></ol><h2 id="1-4-线程状态转换"><a href="#1-4-线程状态转换" class="headerlink" title="1.4 线程状态转换"></a>1.4 线程状态转换</h2><p><strong>线程的生命周期：</strong>线程一共有五种状态，线程在各种状态之间转换。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697183013446-7b8ca940-f958-46f9-b34c-0ce25997c9ee.png#averageHue=%23fafafa&clientId=uc4f565ad-210d-4&id=oH8sI&originHeight=216&originWidth=762&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3542092e-d1aa-45b7-a6e0-97a5b825d58&title="><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697015337666-fd79cd42-5d38-40ca-b824-5f35b2df2b2e.png#averageHue=%23fdfcfc&clientId=u4831536b-25c6-4&from=drop&id=u69308b16&originHeight=492&originWidth=893&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=11971&status=done&style=none&taskId=u502595d0-3cc3-4371-9a89-51c96d0643d&title=" alt="ace830df-9919-48ca-91b5-60b193f593d2.png"></p><ol><li><p><strong>新建（new）：</strong>创建后未启动</p></li><li><p><strong>可运行（Runnable）：</strong>可能正在运行（Running）、可能正在等待CPU时间片（Ready）</p></li><li><p><strong>阻塞（Blocked）：</strong>等待获取一个排它锁，如果线程释放了锁就结束状态</p></li><li><p><strong>限期等待（Time Waiting）：</strong>一定时间后系统自动唤醒</p><table><thead><tr><th><strong>进入方法</strong></th><th><strong>退出方法</strong></th></tr></thead><tbody><tr><td>Thread.sleep() 方法</td><td>时间结束</td></tr><tr><td>设置 Timeout 参数的 Object.wait() 方法</td><td>时间结束 &#x2F; Object.notify() &#x2F; Object.notifyAll()</td></tr><tr><td>设置 Timeout 参数的 Thread.join() 方法</td><td>时间结束 &#x2F; 被调用的线程执行完毕</td></tr></tbody></table></li><li><p><strong>无限期等待（Waiting）：</strong>等待其他线程唤醒，不然不会被分配CPU时间片</p><table><thead><tr><th><strong>进入方法</strong></th><th><strong>退出方法</strong></th></tr></thead><tbody><tr><td>没有设置 Timeout 参数的 Object.wait() 方法</td><td>Object.notify() &#x2F; Object.notifyAll()</td></tr><tr><td>没有设置 Timeout 参数的 Thread.join() 方法</td><td>被调用的线程执行完毕</td></tr></tbody></table></li><li><p><strong>死亡（Terminated）：</strong>线程结束 &#x2F; 出现异常</p></li></ol><h1 id="2、实现线程-⭐⭐"><a href="#2、实现线程-⭐⭐" class="headerlink" title="2、实现线程 ⭐⭐"></a>2、实现线程 ⭐⭐</h1><p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。</p><blockquote><p>实现接口 VS 继承 </p></blockquote><p>Thread实现接口会更好一些，因为：</p><ol><li>Java <strong>不支持多重继承</strong>，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li><li>类可能只要求可执行就行，继承整个 Thread 类<strong>开销过大</strong>。</li></ol><h2 id="2-1-实现Runnable接口"><a href="#2-1-实现Runnable接口" class="headerlink" title="2.1 实现Runnable接口"></a>2.1 实现Runnable接口</h2><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Thread(Runnable target)</td><td>分配一个新的Thread对象</td></tr><tr><td>Thread(Runnable target, String name)</td><td>分配一个新的Thread对象，并重命名</td></tr></tbody></table><p>需要实现 run() 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 Thread 调用 start() 方法来启动线程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyRunnable</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instance);</span><br><span class="line"><span class="comment">//Thread t1 = new Thread(instance,&quot;高铁&quot;);</span></span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-继承Thread类"><a href="#2-2-继承Thread类" class="headerlink" title="2.2 继承Thread类"></a>2.2 继承Thread类</h2><ol><li><strong>核心方法</strong><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void run()</td><td>在线程开启后，此方法将被调用执行</td></tr><tr><td>void start()</td><td>启动线程，然后由JVM调用此线程的run()方法</td></tr></tbody></table></li></ol><p>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>线程信息方法</strong><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void setName(String name)</td><td>将此线程的名称更改为等于参数name</td></tr><tr><td>String getName()</td><td>返回此线程的名称</td></tr><tr><td>Thread currentThread()</td><td>返回对当前正在执行的线程对象的引用</td></tr></tbody></table></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一般用于日志打印</span></span><br><span class="line">System.out.println(Thread.currentThread().getName());</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>线程优先级</strong></li></ol><ul><li>两种线程调度方式 <ul><li><strong>分时调度模型：</strong>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片</li><li><strong>抢占式调度模型：</strong>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些（Java默认）<table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>final int getPriority()</td><td>返回此线程的优先级</td></tr><tr><td>final void setPriority(int newPriority)</td><td>更改此线程的优先级 线程默认优先级是5；线程优先级的范围是：1-10</td></tr></tbody></table></li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ThreadPriority</span> <span class="variable">tp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPriority</span>();</span><br><span class="line">tp.getPriority(); <span class="comment">//5</span></span><br><span class="line">tp.setPriority(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h2 id="2-3-实现Callable接口（JUC）"><a href="#2-3-实现Callable接口（JUC）" class="headerlink" title="2.3 实现Callable接口（JUC）"></a>2.3 实现Callable接口（JUC）</h2><p>与 Runnable 相比，Callable 可以有返回值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值通过 FutureTask（线程池内容） 进行封装</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="type">MyCallable</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(mc);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3、Java锁机制"><a href="#3、Java锁机制" class="headerlink" title="3、Java锁机制"></a>3、Java锁机制</h1><p>:::tips</p><ol><li><strong>线程要不要锁住同步资源？</strong><ul><li>锁住：<strong>悲观锁</strong></li><li>不锁住：<strong>乐观锁</strong></li></ul></li><li><strong>锁住同步资源失败，线程要不要阻塞？</strong><ul><li>阻塞</li><li>不阻塞：<strong>自旋锁&#x2F;自适应自旋锁</strong></li></ul></li><li><strong>多个线程竞争同步资源的流程细节有没有区别？</strong><ul><li>不锁住资源，多个线程中只有一个能修改资源成功，具它线程会重试：<strong>无锁</strong></li><li>同一个线程执行同步资源时自动获取资源：<strong>偏向锁</strong></li><li>多个线程竞争同步资源时，没有获取资源的线程自旋等待锁释放：<strong>轻量级锁</strong></li><li>多个线程竞争同步资源时，没有获取资源的线程阻塞等待唤醒：<strong>重量级锁</strong></li></ul></li><li><strong>多个线程竞争锁时要不要排队？</strong><ul><li>排队：<strong>公平锁</strong></li><li>先尝试插队，插队失败再排队：<strong>非公平锁</strong></li></ul></li><li><strong>一个线程中的多个流程能不能获取同一把锁？</strong><ul><li>能：<strong>可重入锁</strong></li><li>不能：<strong>非可重入锁</strong></li></ul></li><li><strong>多个线程能不能共享一把锁</strong><ul><li>能：<strong>共享锁</strong></li><li>不能：<strong>排它锁</strong><br>:::</li></ul></li></ol><h2 id="3-1-乐观锁-悲观锁"><a href="#3-1-乐观锁-悲观锁" class="headerlink" title="3.1 乐观锁&#x2F;悲观锁"></a>3.1 乐观锁&#x2F;悲观锁</h2><ul><li><strong>悲观锁适合写操作多的场景，</strong>先加锁可以保证写操作时数据正确。</li><li><strong>乐观锁适合读操作多的场景，</strong>不加锁的特点能够使其读操作的性能大幅提升。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697073457856-86a86e6b-106d-4199-8a3a-16d6ed30ba23.png#averageHue=%23f6f3ee&clientId=uf0f5972f-536f-4&from=drop&id=vGlT6&originHeight=1462&originWidth=1898&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=104259&status=done&style=none&taskId=ue621a7b8-0d53-4e15-96aa-d10dae0e8c9&title=" alt="java-lock-2.png"><br>对于同一个数据的并发操作：</p><ol><li><p>悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。【Java中，synchronized关键字和Lock的实现类都是悲观锁】</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// synchronized</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 操作同步资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReentrantLock</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">// 需要保证多个线程使用的是同一个锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modifyPublicResources</span><span class="params">()</span> &#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="comment">// 操作同步资源</span></span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。【Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的】</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();  <span class="comment">// 需要保证多个线程使用的是同一个AtomicInteger</span></span><br><span class="line">atomicInteger.incrementAndGet(); <span class="comment">//执行自增1</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="3-2-自旋锁-适应性自旋锁"><a href="#3-2-自旋锁-适应性自旋锁" class="headerlink" title="3.2 自旋锁&#x2F;适应性自旋锁"></a>3.2 自旋锁&#x2F;适应性自旋锁</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697074045476-bb4daf93-4bde-424b-b098-2f4846573d44.png#averageHue=%23fcfcfc&clientId=u39aa0cd9-7c7b-4&from=drop&id=BYkNU&originHeight=1276&originWidth=1320&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=46569&status=done&style=none&taskId=u4a86db4f-38c0-4b3d-8e70-860d6e0e6f0&title=" alt="java-lock-4.png"><br>:::tips<br><strong>概念：</strong>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。<br>我们可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么<strong>当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销</strong>。这就是自旋锁。<br>:::<br>:::tips<br><strong>缺点：</strong>自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。<strong>如果锁被占用的时间很短，自旋等待的效果就会非常好。</strong>反之，<strong>如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。</strong>所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。<br>:::<br>:::tips<br><strong>应用：</strong>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。<br>:::</p><h2 id="3-3-无锁-偏向锁-轻量级锁-重量级锁"><a href="#3-3-无锁-偏向锁-轻量级锁-重量级锁" class="headerlink" title="3.3 无锁&#x2F;偏向锁&#x2F;轻量级锁&#x2F;重量级锁"></a>3.3 无锁&#x2F;偏向锁&#x2F;轻量级锁&#x2F;重量级锁</h2><p>这四种锁是指锁的状态，专门针对synchronized的。<br>总结而言：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697114528909-c30e8f32-fa25-4de9-a71c-f00a7aa895ad.png#averageHue=%23c8e7fc&clientId=ua061cce9-94ae-4&from=drop&id=JIYzM&originHeight=264&originWidth=1544&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=3630&status=done&style=none&taskId=uda70a9e8-02c4-420f-bcdc-bdf49d8a82f&title=" alt="java-lock-6.png"></p><ol><li><strong>偏向锁：</strong>通过对比Mark Word解决加锁问题，避免执行CAS操作</li><li><strong>轻量级锁：</strong>是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能</li><li><strong>重量级锁：</strong>是将除了拥有锁的线程以外的线程都阻塞。</li></ol><h2 id="3-4-公平锁-非公平锁"><a href="#3-4-公平锁-非公平锁" class="headerlink" title="3.4 公平锁&#x2F;非公平锁"></a>3.4 公平锁&#x2F;非公平锁</h2><ol><li><strong>公平锁：</strong>是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。<ul><li><strong>优点：</strong>等待锁的线程不会饿死。</li><li><strong>缺点：</strong>整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</li></ul></li><li><strong>非公平锁：</strong>是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。<ul><li><strong>优点：</strong>可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。</li><li><strong>缺点：</strong>处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</li></ul></li></ol><ul><li>非公平锁：</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697114582796-1664ad3a-10e7-41cf-8df3-ac391fc9ea78.png#averageHue=%23fcfbfb&clientId=ua061cce9-94ae-4&from=drop&id=P8nXG&originHeight=1222&originWidth=1436&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=67145&status=done&style=none&taskId=u59d6e467-1f8d-46f6-afe6-e73511cd107&title=" alt="java-lock-8.png"></p><h2 id="3-5-可重入锁-非可重入锁"><a href="#3-5-可重入锁-非可重入锁" class="headerlink" title="3.5 可重入锁&#x2F;非可重入锁"></a>3.5 可重入锁&#x2F;非可重入锁</h2><p> 可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法1执行...&quot;</span>);</span><br><span class="line">        doOthers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doOthers</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法2执行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:::tips<br>在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。<br>如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。<br>:::<br>举例：</p><ol><li><strong>可重入锁：</strong>有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697115328950-bae6a972-2e21-4250-9beb-d9b7ffbbdba3.png#averageHue=%23fdfcfc&clientId=ua061cce9-94ae-4&from=drop&id=krkom&originHeight=1058&originWidth=1838&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=48125&status=done&style=none&taskId=u876b224c-20c0-4295-9ab1-e255bfe1b9b&title=" alt="java-lock-12.png"></p><ol start="2"><li><strong>非可重入锁：</strong>管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697115359811-21602da1-d961-4892-b865-9e6af8a23bcc.png#averageHue=%23fdfdfd&clientId=ua061cce9-94ae-4&from=drop&id=clCSW&originHeight=1052&originWidth=1812&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=49711&status=done&style=none&taskId=ufef624c3-87a3-464a-afe9-9eea0acd5fe&title=" alt="java-lock-13.png"></p><h2 id="3-6-排它锁-共享锁"><a href="#3-6-排它锁-共享锁" class="headerlink" title="3.6 排它锁&#x2F;共享锁"></a>3.6 排它锁&#x2F;共享锁</h2><ol><li><strong>排他锁：</strong>是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。</li><li><strong>共享锁：</strong>是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</li></ol><p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。<br>下图为ReentrantReadWriteLock的部分源码：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697115587090-0ab35346-1ac6-4a09-8137-bad826648788.png#averageHue=%23fdfcfc&clientId=ua061cce9-94ae-4&from=drop&id=D0LgF&originHeight=1076&originWidth=1850&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=145556&status=done&style=none&taskId=u247a6235-0f90-41ec-8dd1-80d5f42a8ea&title=" alt="java-lock-15.png"><br>:::tips<br>我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。<br>:::<br>在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样：<br>读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。</p><h1 id="4、线程控制-⭐⭐"><a href="#4、线程控制-⭐⭐" class="headerlink" title="4、线程控制 ⭐⭐"></a>4、线程控制 ⭐⭐</h1><h2 id="4-1-Executor（JUC）"><a href="#4-1-Executor（JUC）" class="headerlink" title="4.1 Executor（JUC）"></a>4.1 Executor（JUC）</h2><p>Executor <strong>管理多个异步任务的执行</strong>，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。<br>主要有三种 Executor:</p><ul><li>CachedThreadPool: 一个任务创建一个线程；</li><li>FixedThreadPool: 所有任务只能使用固定大小的线程；</li><li>SingleThreadExecutor: 相当于大小为 1 的 FixedThreadPool。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-2-Thread-sleep-join-yield-Daemon"><a href="#4-2-Thread-sleep-join-yield-Daemon" class="headerlink" title="4.2 Thread(sleep&#x2F;join&#x2F;yield&#x2F;Daemon)"></a>4.2 Thread(sleep&#x2F;join&#x2F;yield&#x2F;Daemon)</h2><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>static void sleep(long millis)</td><td><strong>线程暂停一段时间；</strong>等时间结束进入就绪态【线程会阻塞】</td></tr><tr><td>void join()</td><td><strong>在线程A中调用线程B的 join() 方法，先运行完B线程在运行A线程；</strong>【线程会阻塞】</td></tr><tr><td>void yield()</td><td><strong>线程暂停，让给同等或更高优先级的线程执行；</strong>线程让出CPU的执行【线程不会阻塞】</td></tr><tr><td>void setDaemon(boolean on)</td><td><strong>将此线程标记为守护线程</strong>，守护线程是一种在后台运行的线程，它的生命周期与程序的非守护线程不同</td></tr></tbody></table><ol><li><strong>sleep()：</strong>Thread.sleep(millisec) 方法会<strong>休眠当前正在执行的线程</strong>，millisec 单位为毫秒。</li></ol><p>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>join()：</strong>在线程A中调用线程B的 join() 方法，先运行完B线程在运行A线程；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 目标线程要执行的任务</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thread.start(); <span class="comment">// 启动目标线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待目标线程执行完成</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    thread.join(); <span class="comment">// 目标线程执行完成后，继续执行当前线程的其他任务</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>yield()：</strong>对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，<strong>可以切换给其它线程来执行</strong>。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    Thread.<span class="keyword">yield</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Daemon：守护线程</strong>是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p></li></ol><p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程【main() 属于非守护线程】</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line"><span class="comment">// 使用 setDaemon() 方法将一个线程设置为守护线程</span></span><br><span class="line">    thread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5、线程协作方案"><a href="#5、线程协作方案" class="headerlink" title="5、线程协作方案"></a>5、线程协作方案</h1><p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调</p><h2 id="5-1-join"><a href="#5-1-join" class="headerlink" title="5.1 join()"></a>5.1 join()</h2><p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">a.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-wait-notify-notifyAll"><a href="#5-2-wait-notify-notifyAll" class="headerlink" title="5.2 wait()&#x2F;notify()&#x2F;notifyAll()"></a>5.2 wait()&#x2F;notify()&#x2F;notifyAll()</h2><p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。它们都属于 Object 的一部分，而不属于 Thread。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotifyExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateExeception。<br>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</p><h2 id="5-3-await-signal-signalAll-（JUC）"><a href="#5-3-await-signal-signalAll-（JUC）" class="headerlink" title="5.3 await()&#x2F;signal()&#x2F;signalAll()（JUC）"></a>5.3 await()&#x2F;signal()&#x2F;signalAll()（JUC）</h2><p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。使用 Lock 来获取一个 Condition 对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AwaitSignalExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="type">AwaitSignalExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AwaitSignalExample</span>();</span><br><span class="line">    executorServiSWce.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6、线程安全（互斥同步）-⭐⭐"><a href="#6、线程安全（互斥同步）-⭐⭐" class="headerlink" title="6、线程安全（互斥同步） ⭐⭐"></a>6、线程安全（互斥同步） ⭐⭐</h1><p>:::tips<br> 互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁(这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁)、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。<br>:::<br>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p><blockquote><p>使用建议</p></blockquote><p> 除非需要使用 ReentrantLock 的高级功能，否则<strong>优先使用 synchronized</strong>，原因如下：</p><ol><li><p>synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。</p></li><li><p>synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p><blockquote><p>ReentrantLock 的高级性质</p></blockquote></li><li><p>ReentrantLock 可中断线程（当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情）</p></li><li><p>ReentrantLock 默认情况下也是非公平锁，但是也可以是公平的</p></li><li><p>一个 ReentrantLock 可以同时绑定多个 Condition 对象</p></li></ol><h2 id="6-1-synchronized"><a href="#6-1-synchronized" class="headerlink" title="6.1 synchronized"></a>6.1 synchronized</h2><ol><li><p><strong>同步代码块：</strong>（同一个对象）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>同步方法：</strong>（作用在整个方法）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">func</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态方法：作用在整个类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>同步类：</strong>（作用在整个类）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SynchronizedExample.class) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="6-2-ReentrantLock（JUC）"><a href="#6-2-ReentrantLock（JUC）" class="headerlink" title="6.2 ReentrantLock（JUC）"></a>6.2 ReentrantLock（JUC）</h2><p>Lock是接口不能直接实例化，这里采用它的实现类<strong>ReentrantLock</strong>来实例化</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void lock()</td><td>加锁</td></tr><tr><td>void unlock()</td><td>解锁</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 确保释放锁，从而避免发生死锁。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">LockExample</span> <span class="variable">lockExample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockExample</span>();</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7、线程安全（非阻塞同步）-⭐"><a href="#7、线程安全（非阻塞同步）-⭐" class="headerlink" title="7、线程安全（非阻塞同步） ⭐"></a>7、线程安全（非阻塞同步） ⭐</h1><p>:::tips<br>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为<strong>阻塞同步</strong>。<br>:::</p><h2 id="7-1-CAS（乐观锁）"><a href="#7-1-CAS（乐观锁）" class="headerlink" title="7.1 CAS（乐观锁）"></a>7.1 CAS（乐观锁）</h2><p>:::tips<br>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略: 先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施(不断地重试，直到成功为止)。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为<strong>非阻塞同步</strong>。<br><strong>乐观锁</strong>需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成<strong>（硬件平台的汇编指令）</strong>。硬件支持的原子性操作最典型的是: 比较并交换(Compare-and-Swap，CAS)。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。<br>:::<br><strong>CAS会导致问题：</strong></p><ol><li><p><strong>ABA 问题：</strong>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。<br>:::tips<br>ABA问题的解决思路就是<strong>使用版本号</strong>。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A-&gt;B-&gt;A就会变成1A-&gt;2B-&gt;3A。<br>JDK的Atomic包里提供了一个类<strong>AtomicStampedReference</strong>来解决ABA问题。这个类的<strong>compareAndSet</strong>方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。<br>:::</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicStampedReferenceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference&lt;String&gt; atomicRef = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">expectedReference</span> <span class="operator">=</span> atomicRef.getReference();</span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedStamp</span> <span class="operator">=</span> atomicRef.getStamp();</span><br><span class="line">        <span class="type">String</span> <span class="variable">newReference</span> <span class="operator">=</span> <span class="string">&quot;B&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newStamp</span> <span class="operator">=</span> expectedStamp + <span class="number">1</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> atomicRef.compareAndSet(expectedReference, newReference, expectedStamp, newStamp);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;compareAndSet执行结果：&quot;</span> + success);</span><br><span class="line">        System.out.println(<span class="string">&quot;最终的引用值：&quot;</span> + atomicRef.getReference());</span><br><span class="line">        System.out.println(<span class="string">&quot;最终的标记值：&quot;</span> + atomicRef.getStamp());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>循环时间长开销大问题：</strong><br>:::tips<br> 自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。<br>pause指令有两个作用：</p></li><li><p>它可以延迟流水线执行命令(de-pipeline)，使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零；</p></li><li><p>它可以避免在退出循环的时候因内存顺序冲突(Memory Order Violation)而引起CPU流水线被清空(CPU Pipeline Flush)，从而提高CPU的执行效率。<br>:::</p></li><li><p><strong>只能保证一个共享变量的原子操作：</strong><br>:::tips<br>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。<br>还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i &#x3D; 2，j &#x3D; a，合并一下ij &#x3D; 2a，然后用CAS来操作ij。<br>从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。<br>:::</p></li></ol><h2 id="7-2-AtomicXXX（JUC）"><a href="#7-2-AtomicXXX（JUC）" class="headerlink" title="7.2 AtomicXXX（JUC）"></a>7.2 AtomicXXX（JUC）</h2><ul><li>一共4个分类，13个小类。<br>:::tips</li></ul><ol><li><strong>原子更新基本类型：</strong></li></ol><ul><li>AtomicBoolean: 原子更新布尔类型</li><li>AtomicInteger: 原子更新整型 ⭐</li><li>AtomicLong: 原子更新长整型<br>:::<br>:::tips</li></ul><ol start="2"><li><strong>原子更新数组：</strong></li></ol><ul><li>AtomicIntegerArray: 原子更新整型数组里的元素。</li><li>AtomicLongArray: 原子更新长整型数组里的元素。</li><li>AtomicReferenceArray: 原子更新引用类型数组里的元素。</li></ul><p>最常用的两个方法：</p><ul><li>get(int index)：获取索引为index的元素值</li><li>compareAndSet(int i,E expect,E update): 如果当前值等于预期值，则以原子方式将数组位置i的元素设置为update值<br>:::<br>:::tips</li></ul><ol start="3"><li><strong>原子更新引用类型：</strong></li></ol><ul><li>AtomicReference: 原子更新引用类型。 ⭐</li><li>AtomicStampedReference: 原子更新引用类型, 内部使用Pair来存储元素值及其版本号。</li><li>AtomicMarkableReferce: 原子更新带有标记位的引用类型。</li></ul><p> 这三个类提供的方法都差不多，首先构造一个引用对象，然后把引用对象set进Atomic类，然后调用<strong>compareAndSet</strong>等一些方法去进行原子操作，原理都是基于Unsafe实现，但AtomicReferenceFieldUpdater略有不同，更新的字段必须用volatile修饰。<br>:::<br>:::tips</p><ol start="4"><li><strong>原子更新字段类：</strong></li></ol><ul><li>AtomicIntegerFieldUpdater: 原子更新整型的字段的更新器。</li><li>AtomicLongFieldUpdater: 原子更新长整型字段的更新器。</li><li>AtomicReferenceFieldUpdater: 上面已经说过此处不在赘述。</li></ul><p>是基于反射的原子更新字段的值。要想原子地更新字段类需要两步:</p><ul><li>第一步，因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。</li><li>第二步，更新类的字段必须使用public volatile修饰。<br>:::<br>以下代码使用了 AtomicInteger 执行了自增的操作。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        cnt.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>AtomicInteger 常用API：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span>：获取当前的值</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span>：获取当前的值，并设置新的值</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span>：获取当前的值，并自增</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span>：获取当前的值，并自减</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span>：获取当前的值，并加上预期的值</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> newValue)</span>: 最终会设置成newValue,使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span><br></pre></td></tr></table></figure></li></ul><h1 id="生产者消费者-多线程"><a href="#生产者消费者-多线程" class="headerlink" title="生产者消费者(多线程)"></a>生产者消费者(多线程)</h1><p>:::tips<br>为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库</p><ul><li><p>生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为</p></li><li><p>消费者只需要从共享数据区中去获取数据，并不需要关心生产者的行为<br>:::<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697183015987-d093d359-e7d6-4ff7-aade-e84bbc8b4a17.png#averageHue=%23afc7e8&clientId=uc4f565ad-210d-4&id=bWiuf&originHeight=90&originWidth=725&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1e48c02e-8906-4008-95b4-0193a0baf70&title="></p></li><li><p>Object类的等待和唤醒方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void wait()</td><td>导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法</td></tr><tr><td>void notify()</td><td>唤醒正在等待对象监视器的单个线程</td></tr><tr><td>void notifyAll()</td><td>唤醒正在等待对象监视器的所有线程</td></tr></tbody></table></li><li><p>案例需求</p></li></ul><p>生产者消费者案例中包含的类：（Box、Producer、Customer）</p><ol><li><p><strong>奶箱类(Box)：</strong>定义一个成员变量，表示第x瓶奶，提供存储牛奶和获取牛奶的操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个成员变量，表示第x瓶奶</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> milk;</span><br><span class="line">    <span class="comment">//定义一个成员变量，表示奶箱的状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">state</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//提供存储牛奶和获取牛奶的操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> milk)</span> &#123;</span><br><span class="line">        <span class="comment">//如果有牛奶，等待消费</span></span><br><span class="line">        <span class="keyword">if</span>(state) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有牛奶，就生产牛奶</span></span><br><span class="line">        <span class="built_in">this</span>.milk = milk;</span><br><span class="line">        System.out.println(<span class="string">&quot;送奶工将第&quot;</span> + <span class="built_in">this</span>.milk + <span class="string">&quot;瓶奶放入奶箱&quot;</span>);</span><br><span class="line">        <span class="comment">//生产完毕之后，修改奶箱状态</span></span><br><span class="line">        state = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//唤醒其他等待的线程</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//如果没有牛奶，等待生产</span></span><br><span class="line">        <span class="keyword">if</span>(!state) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果有牛奶，就消费牛奶</span></span><br><span class="line">        System.out.println(<span class="string">&quot;用户拿到第&quot;</span> + <span class="built_in">this</span>.milk + <span class="string">&quot;瓶奶&quot;</span>);</span><br><span class="line">        <span class="comment">//消费完毕之后，修改奶箱状态</span></span><br><span class="line">        state = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//唤醒其他等待的线程</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>生产者类(Producer)：</strong>实现Runnable接口，重写run()方法，调用存储牛奶的操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Box b;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Box b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">30</span>; i++) &#123;</span><br><span class="line">            b.put(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>消费者类(Customer)：</strong>实现Runnable接口，重写run()方法，调用获取牛奶的操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Box b;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(Box b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            b.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>测试类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoxDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建奶箱对象，这是共享数据区域</span></span><br><span class="line">        <span class="type">Box</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Box</span>();</span><br><span class="line">        <span class="comment">//创建生产者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用存储牛奶的操作</span></span><br><span class="line">        <span class="type">Producer</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(b);</span><br><span class="line">        <span class="comment">//创建消费者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用获取牛奶的操作</span></span><br><span class="line">        <span class="type">Customer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(b);</span><br><span class="line">        <span class="comment">//创建2个线程对象，分别把生产者对象和消费者对象作为构造方法参数传递</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(p);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(c);</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;AQS&quot;&gt;&lt;a href=&quot;#AQS&quot; class=&quot;headerlink&quot; title=&quot;AQS&quot;&gt;&lt;/a&gt;AQS&lt;/h2&gt;&lt;p&gt;AQS（AbstractQueuedSynchronizer）是Java并发包中的一个重要类，用于实现同步器和锁的基础组件。下面是A</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java集合</title>
    <link href="http://example.com/2024/01/18/Java%E9%9B%86%E5%90%88/"/>
    <id>http://example.com/2024/01/18/Java%E9%9B%86%E5%90%88/</id>
    <published>2024-01-18T02:59:47.232Z</published>
    <updated>2024-01-18T03:27:52.148Z</updated>
    
    <content type="html"><![CDATA[<ul><li>深入学习：<a href="https://zhuanlan.zhihu.com/p/143700575">吃透Java集合框架！</a></li><li><strong>简易知识体系：</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697187591067-f5c2bd11-7e85-4aa8-8c36-4d7b25e4fae4.png#averageHue=%23f8f1f1&clientId=ud965fb95-e94f-4&id=tYgzb&originHeight=287&originWidth=745&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uaeb321fe-9aeb-40c2-aec9-c46e342af5a&title="></p><ul><li><strong>超详细体系架构图：</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1694090838773-d351e02b-570b-468e-8e7b-de1f3b5c1af4.png#averageHue=%23f6f6f6&clientId=ud63063b1-26c1-4&from=paste&height=574&id=zz03N&originHeight=717&originWidth=978&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=138841&status=done&style=none&taskId=udd42561e-42e3-4463-9e1a-1dadb71b17b&title=&width=782.4" alt="image.png"></p><h1 id="1、Collection"><a href="#1、Collection" class="headerlink" title="1、Collection"></a>1、Collection</h1><ul><li>Collection集合概述 <ul><li>是单例集合的顶层接口，它表示一组对象，这些对象也称为Collection的元素</li><li>JDK 不提供此接口的任何直接实现，它提供更具体的子接口（如<strong>Set</strong>和<strong>List</strong>）实现<table><thead><tr><th><strong>返回值</strong></th><th><strong>方法名</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>boolean</td><td>add(E e)</td><td>添加元素</td></tr><tr><td>boolean</td><td>remove(Object o)</td><td>从集合中移除指定的元素</td></tr><tr><td>void</td><td>clear()</td><td>清空集合中的元素</td></tr><tr><td>boolean</td><td>contains(Object o)</td><td>判断集合中是否存在指定的元素</td></tr><tr><td>boolean</td><td>isEmpty()</td><td>判断集合是否为空</td></tr><tr><td>int</td><td>size()</td><td>集合的长度，也就是集合中元素的个数</td></tr></tbody></table></li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Collection集合的对象</span></span><br><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"><span class="comment">//添加元素：boolean add(E e)</span></span><br><span class="line">c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="1-1-iterator-迭代器"><a href="#1-1-iterator-迭代器" class="headerlink" title="1.1 iterator 迭代器"></a>1.1 iterator 迭代器</h2><ul><li>迭代器：集合的专用遍历方式<ul><li>Iterator iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到</li><li>迭代器是通过**集合的iterator()**方法得到的，所以我们说它是依赖于集合而存在的</li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1692345384687-e4620daa-4b8b-457b-aeda-729c1653dc89.png#averageHue=%23343331&clientId=u04d8008e-237f-4&from=paste&height=180&id=Ujpw6&originHeight=225&originWidth=230&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6116&status=done&style=none&taskId=u6658fc21-29ba-4e2d-b68e-98e4f2e12e2&title=&width=184" alt="image.png"></p><ul><li>注：一共就这四个方法：<table><thead><tr><th><strong>返回值</strong></th><th><strong>方法名</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>boolean</td><td>hasNext()</td><td>如果集合中存在元素，则返回true</td></tr><tr><td>E</td><td>next()</td><td>返回集合的下一个元素</td></tr><tr><td>void</td><td>remove()</td><td>删除next()返回的最后一个元素</td></tr><tr><td>void</td><td>forEachRemaining()</td><td>对集合的每个剩余元素执行指定的操作</td></tr></tbody></table></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; num = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">//创建一个ArrayList</span></span><br><span class="line">ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(num);</span><br><span class="line">Iterator&lt;Integer&gt; iterate = nums.iterator(); <span class="comment">//创建Iterator的实例</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> iterate.next(); <span class="comment">//1、使用next()方法</span></span><br><span class="line">iterate.remove(); <span class="comment">//2、使用remove()方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(iterate.hasNext()) &#123; <span class="comment">//3、使用hasNext()方法</span></span><br><span class="line">    <span class="comment">//4、使用forEachRemaining()方法</span></span><br><span class="line">    iterate.forEachRemaining((value) -&gt; System.out.print(value + <span class="string">&quot;, &quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2、List-有序集合"><a href="#2、List-有序集合" class="headerlink" title="2、List 有序集合"></a>2、List 有序集合</h1><ul><li>概述：<strong>有序集合</strong>(序列)，用户可以精确控制列表中每个元素的插入位置。用户可以通过整数索引访问元素，并搜索列表中的元素。</li><li>List集合特点：有索引、允许重复的元素、元素存取有序</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1692347100566-6a739527-986c-400e-8800-e56118cace9e.png#averageHue=%2334302e&clientId=u04d8008e-237f-4&from=paste&height=325&id=lXo0N&originHeight=406&originWidth=646&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25315&status=done&style=none&taskId=ue60b7ed4-0c3b-45b5-a760-b6664c07c07&title=&width=516.8" alt="image.png"></p><table><thead><tr><th><strong>返回值</strong></th><th><strong>方法名</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>void</td><td>add(int index,E element)</td><td>在此集合中的指定位置<strong>插入</strong>指定的元素</td></tr><tr><td>E</td><td>remove(int index)</td><td><strong>删除</strong>指定索引处的元素，返回被删除的元素</td></tr><tr><td>E</td><td>set(int index,E element)</td><td><strong>修改</strong>指定索引处的元素，返回被修改的元素</td></tr><tr><td>E</td><td>get(int index)</td><td>返回指定索引处的元素</td></tr></tbody></table><blockquote><p>列表迭代器</p></blockquote><ul><li>ListIterator介绍 <ul><li>通过List集合的listIterator()方法得到，所以说它是List集合特有的迭代器</li><li>用于允许程序员沿任一方向遍历的列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); <span class="comment">//创建集合对象</span></span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>); <span class="comment">//添加元素</span></span><br><span class="line">list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">ListIterator&lt;String&gt; lit = list.listIterator(); <span class="comment">//获取列表迭代器</span></span><br><span class="line"><span class="keyword">while</span> (lit.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> lit.next();</span><br><span class="line">    <span class="keyword">if</span>(s.equals(<span class="string">&quot;world&quot;</span>))  lit.add(<span class="string">&quot;javaee&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="2-1-ArrayList-⭐"><a href="#2-1-ArrayList-⭐" class="headerlink" title="2.1 ArrayList ⭐"></a>2.1 ArrayList ⭐</h2><ul><li>ArrayList：底层是<strong>数组结构</strong>实现，<strong>查询快、增删慢</strong> （底层：动态数组）</li><li>泛型的使用：约束集合中存储元素的数据类型 <table><thead><tr><th><strong>返回值</strong></th><th><strong>方法名</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>boolean</td><td></td><td></td></tr><tr><td>void</td><td>add(E element)</td><td></td></tr><tr><td>add(int index, E element)</td><td>将指定元素追加到ArrayList的末尾</td><td></td></tr><tr><td>在指定位置插入指定元素</td><td></td><td></td></tr><tr><td>boolean</td><td></td><td></td></tr><tr><td>E</td><td>remove(Object element)</td><td></td></tr><tr><td>remove(int index)</td><td>从ArrayList中移除指定元素</td><td></td></tr><tr><td>移除指定位置的元素</td><td></td><td></td></tr><tr><td>E</td><td>get(int index)</td><td>获取指定位置的元素</td></tr><tr><td>E</td><td>set(int index, E element)</td><td>将指定位置的元素替换为新元素，</td></tr><tr><td>并返回原来位置元素的值。</td><td></td><td></td></tr></tbody></table></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建ArrayList集合对象</span></span><br><span class="line">ArrayList&lt;Student&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;林青霞&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张曼玉&quot;</span>, <span class="number">35</span>);</span><br><span class="line">array.add(s1);</span><br><span class="line">array.add(s2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器：集合特有的遍历方式</span></span><br><span class="line">Iterator&lt;Student&gt; it = array.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">    System.out.println(s.getName() + <span class="string">&quot;,&quot;</span> + s.getAge());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通for：带有索引的遍历方式</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;array.size(); i++) &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> array.get(i);</span><br><span class="line">    System.out.println(s.getName() + <span class="string">&quot;,&quot;</span> + s.getAge());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增强for：最方便的遍历方式</span></span><br><span class="line"><span class="keyword">for</span>(Student s : array) &#123;</span><br><span class="line">    System.out.println(s.getName() + <span class="string">&quot;,&quot;</span> + s.getAge());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:::tips</p><ul><li>增加（add）操作：在末尾添加元素的时间复杂度为O(1)，如果需要在中间或开头插入元素，则为O(n)。</li><li>删除（remove）操作：删除指定索引的元素的时间复杂度为O(n)，因为需要移动后续元素。</li><li>修改（set）操作：修改指定索引位置的元素的时间复杂度为O(1)。</li><li>查找（get）操作：根据索引获取元素的时间复杂度为O(1)。<br>:::</li></ul><h2 id="2-2-LinkedList"><a href="#2-2-LinkedList" class="headerlink" title="2.2 LinkedList"></a>2.2 LinkedList</h2><ul><li>LinkedList：底层是<strong>链表结构</strong>实现，<strong>查询慢，增删快</strong>（底层：双向链表）<table><thead><tr><th><strong>返回值</strong></th><th><strong>方法名</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>boolean</td><td></td><td></td></tr><tr><td>void</td><td></td><td></td></tr><tr><td>boolean</td><td>add(E element)</td><td></td></tr><tr><td>add(int index, E element)</td><td></td><td></td></tr><tr><td>addFirst(E element)</td><td>元素插入到链表末尾</td><td></td></tr><tr><td>指定位置插入元素</td><td></td><td></td></tr><tr><td>在链表开头插入元素（addLast）</td><td></td><td></td></tr><tr><td>E</td><td></td><td></td></tr><tr><td>boolean</td><td></td><td></td></tr><tr><td>E</td><td>remove(int index)</td><td></td></tr><tr><td>remove(E element)</td><td></td><td></td></tr><tr><td>removeFirst()</td><td>移除指定位置的元素，并返回被移除的元素</td><td></td></tr><tr><td>从链表中移除指定元素</td><td></td><td></td></tr><tr><td>移除并返回链表第一个元素（removeLast）</td><td></td><td></td></tr><tr><td>E</td><td></td><td></td></tr><tr><td>void</td><td>get(int index)</td><td></td></tr><tr><td>getFirst()</td><td>获取指定位置的元素，并返回其值。</td><td></td></tr><tr><td>返回链表的第一个元素（getLast）</td><td></td><td></td></tr><tr><td>E</td><td>set(int index, E element)</td><td>将指定位置的元素替换为新元素，并返回原来位置元素的值。</td></tr></tbody></table></li></ul><p>:::tips</p><ul><li>增加（add）操作：在末尾添加元素的时间复杂度为O(1)，如果需要在中间或开头插入元素，则为O(n)。</li><li>删除（remove）操作：删除指定节点的时间复杂度为O(1)。</li><li>修改（set）操作：修改指定节点的元素的时间复杂度为O(1)。</li><li>查找（get）操作：根据索引获取元素的时间复杂度为O(n)。<br>:::</li></ul><h2 id="2-3-Queue"><a href="#2-3-Queue" class="headerlink" title="2.3 Queue"></a>2.3 Queue</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1692347766206-18a8f84f-4d30-43c6-930e-172737b142c7.png#averageHue=%2333302e&clientId=u04d8008e-237f-4&from=paste&height=276&id=gOCiB&originHeight=345&originWidth=648&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20852&status=done&style=none&taskId=uc31523c5-95d7-4c83-8419-a37d8ae37ea&title=&width=518.4" alt="image.png"></p><blockquote><p>1、PriorityQueue</p></blockquote><table><thead><tr><th><strong>返回值</strong></th><th><strong>方法名</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>boolean</td><td>offer(E e)</td><td></td></tr><tr><td>add(E e)</td><td>都是插入到优先级队列中</td><td></td></tr><tr><td>差别：队列已满时，offer返回false；add抛出异常</td><td></td><td></td></tr><tr><td>E</td><td>poll()</td><td>检索并移除队列中的头部元素</td></tr><tr><td>boolean</td><td>peek()</td><td></td></tr><tr><td>element()</td><td>检索但不移除队列中的头部元素</td><td></td></tr><tr><td>差别：队列为空时，peek返回null；element抛出异常</td><td></td><td></td></tr><tr><td>boolean</td><td>remove(Object o)</td><td>移除队列中的指定元素</td></tr></tbody></table><h1 id="3、Set-无序集合"><a href="#3、Set-无序集合" class="headerlink" title="3、Set 无序集合"></a>3、Set 无序集合</h1><ul><li>Set集合的特点：元素存取无序、没有索引(只能<strong>迭代器</strong>&#x2F;<strong>增强for循环</strong>遍历)、不能存储重复元素</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1692347274507-060b3c7c-400a-4407-b25b-4daf8d8c6aa1.png#averageHue=%23332f2e&clientId=u04d8008e-237f-4&from=paste&height=312&id=fUD8W&originHeight=390&originWidth=624&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23468&status=done&style=none&taskId=u0e250c5f-1987-4db4-a6ec-3a765dd641a&title=&width=499.2" alt="image.png"></p><blockquote><p>哈希值</p></blockquote><ul><li>Hash值：是JDK根据对象的<strong>地址&#x2F;字符串&#x2F;数字</strong>算出来的int类型的数值 </li><li>如何获取哈希值：Object类中的public int hashCode()：返回对象的哈希码值 </li><li>哈希值的特点 <ul><li>同一个对象多次调用hashCode()方法返回的哈希值是相同的</li><li>默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同</li></ul></li></ul><h2 id="3-1-HashSet-⭐"><a href="#3-1-HashSet-⭐" class="headerlink" title="3.1 HashSet ⭐"></a>3.1 HashSet ⭐</h2><p>:::tips<br>HashSet集合特点： </p><ul><li><p>底层数据结构是哈希表</p></li><li><p>对集合的迭代顺序不作任何保证，也就是说不保证存储和取出的元素顺序一致</p></li><li><p>没有带索引的方法，所以不能使用普通for循环遍历</p></li><li><p>由于是Set集合，所以是不包含重复元素的集合<br>:::</p><table><thead><tr><th><strong>返回值</strong></th><th><strong>方法名</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>boolean</td><td>add(E element)</td><td></td></tr><tr><td>addAll(Collection&lt;? extends E&gt; collection)</td><td>将指定元素添加到HashSet中</td><td></td></tr><tr><td>将指定集合中所有元素添加到HashSet中</td><td></td><td></td></tr><tr><td>boolean</td><td>remove(Object element)</td><td></td></tr><tr><td>removeAll(Collection&lt;?&gt; collection)</td><td>从HashSet中移除指定元素</td><td></td></tr><tr><td>从HashSet中移除与指定集合中元素相同的所有元素</td><td></td><td></td></tr><tr><td>boolean</td><td>retainAll(Collection&lt;?&gt; collection)</td><td>仅保留HashSet中与指定集合中元素相同的元素，移除其他元素。</td></tr><tr><td>boolean</td><td>containsAll(Collection&lt;?&gt; collection)</td><td>判断HashSet是否包含指定集合中的所有元素</td></tr></tbody></table></li><li><p>哈希表图示：**数组+链表 **结构</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697187591078-55b8d3ae-950f-492c-aeff-86dddb918421.png#averageHue=%23f7f2f2&clientId=ud965fb95-e94f-4&id=bz1bS&originHeight=262&originWidth=777&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3c9c52fc-78b6-408c-953d-9fa6bc73bc2&title="><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686289066063-d9156d38-6433-4cea-94b7-4da797d7a12f.png#averageHue=%23f6f4f4&clientId=u72ac83f4-7ae1-4&from=drop&id=c3jS0&originHeight=370&originWidth=954&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=63438&status=done&style=none&taskId=u2124de98-7638-4ada-9cd2-6c48d390f14&title=" alt="20210105174428536.png"></p><ul><li><p>当链表元素&gt;&#x3D;8时，链表进化成红黑树（增删慢，要维护树结构，但查询效率高！）<br>:::tips</p></li><li><p>增加（add）操作：添加元素的时间复杂度为O(1)。</p></li><li><p>删除（remove）操作：删除元素的时间复杂度为O(1)。</p></li><li><p>修改（set）操作：HashSet不提供直接修改操作，需要先删除再添加。</p></li><li><p>查找（contains）操作：判断元素是否存在的时间复杂度为O(1)。<br>:::</p></li></ul><h2 id="3-2-TreeSet"><a href="#3-2-TreeSet" class="headerlink" title="3.2 TreeSet"></a>3.2 TreeSet</h2><ul><li><p>TreeSet：元素有序，可以按照一定的规则进行排序，具体排序方式取决于构造方法 </p><table><thead><tr><th><strong>构造方法</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>TreeSet()</td><td>根据其元素的<strong>自然排序</strong>进行排序</td></tr><tr><td>TreeSet(Comparator comparator)</td><td>根据指定的<strong>比较器</strong>进行排序</td></tr></tbody></table></li><li><p>TreeSet特点：没有索引方法(不能使用普通for循环遍历)、Set集合(不包含重复元素集合)</p><table><thead><tr><th><strong>返回值</strong></th><th><strong>方法名</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>boolean</td><td>add(E element)</td><td>将指定元素添加到TreeSet中</td></tr><tr><td>boolean</td><td>remove(Object element)</td><td>从TreeSet中移除指定元素</td></tr><tr><td>E</td><td>first()</td><td></td></tr><tr><td>last()</td><td>返回TreeSet中的第一个（最小）元素。</td><td></td></tr><tr><td>返回TreeSet中的最后一个（最大）元素。</td><td></td><td></td></tr><tr><td>E</td><td>ceiling(E element)</td><td></td></tr><tr><td>floor(E element)</td><td>返回TreeSet中大于等于给定元素的最小元素。</td><td></td></tr><tr><td>返回TreeSet中小于等于给定元素的最大元素。</td><td></td><td></td></tr><tr><td>E</td><td>pollFirst()</td><td></td></tr><tr><td>pollLast()</td><td>移除并返回TreeSet中的第一个（最小）元素。</td><td></td></tr><tr><td>移除并返回TreeSet中的最后一个（最大）元素。</td><td></td><td></td></tr><tr><td>NavigableSet<E></td><td>descendingSet()</td><td>返回TreeSet的逆序视图，其中元素按降序排列。</td></tr></tbody></table></li></ul><p>:::tips</p><ul><li>增加（add）操作：添加元素的时间复杂度为O(log n)。</li><li>删除（remove）操作：删除元素的时间复杂度为O(log n)。</li><li>修改（set）操作：TreeSet不提供直接修改操作，需要先删除再添加。</li><li>查找（contains）操作：判断元素是否存在的时间复杂度为O(log n)。<br>:::</li></ul><blockquote><p>自然排序Comparable &#x2F; 比较器排序Comparator</p></blockquote><ul><li>案例需求 <ul><li>存储学生对象并遍历，创建TreeSet集合使用无参构造方法</li><li>要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序</li></ul></li><li>实现步骤 <ul><li>用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的</li><li>自然排序，就是让元素所属的类实现Comparable接口，重写compareTo(T o)方法</li><li>重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写<br>:::tips</li></ul></li></ul><ol><li><p>自然排序Comparable的使用：</p><ul><li>用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的</li><li>自然排序，就是让元素所属的类实现Comparable接口，重写compareTo(T o)方法</li><li>重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写<br>:::<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自然排序 Comparator</span></span><br><span class="line">TreeSet&lt;Student&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Student&gt;();</span><br></pre></td></tr></table></figure>:::tips</li></ul></li><li><p>比较器排序Comparator的使用：</p><ul><li>用TreeSet集合存储自定义对象，<strong>带参构造方法</strong>使用的是比较器排序对元素进行排序的</li><li>比较器排序，就是让集合构造方法接收Comparator的实现类对象，重写compare(T o1,T o2)方法</li><li>重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写<br>:::<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比较器 Comparable</span></span><br><span class="line">TreeSet&lt;Student&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Student&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student s1, Student s2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> s1.getAge() - s2.getAge(); <span class="comment">//主要条件</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> num == <span class="number">0</span> ? s1.getName().compareTo(s2.getName()):num; <span class="comment">//次要条件</span></span><br><span class="line">    <span class="keyword">return</span> num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="3-3-LinkedHashSet"><a href="#3-3-LinkedHashSet" class="headerlink" title="3.3 LinkedHashSet"></a>3.3 LinkedHashSet</h2><ul><li>LinkedHashSet集合特点 <ul><li>哈希表和链表实现的Set接口，具有可预测的迭代次序</li><li>由链表保证元素有序，也就是说元素的存储和取出顺序是一致的</li><li>由哈希表保证元素唯一，也就是说没有重复的元素<table><thead><tr><th><strong>返回值</strong></th><th><strong>方法名</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>boolean</td><td>add(E element)</td><td>将指定元素添加到LinkedHashSet中</td></tr><tr><td>boolean</td><td>remove(Object element)</td><td>从LinkedHashSet中移除指定元素</td></tr><tr><td>E</td><td>get(int index)</td><td>根据索引位置获取LinkedHashSet中的元素。</td></tr><tr><td>Iterator<E></td><td>iterator()</td><td>遍历LinkedHashSet中的元素</td></tr><tr><td>Object[]</td><td>toArray()</td><td>将LinkedHashSet转换为一个对象数组</td></tr><tr><td>boolean</td><td>addAll(Collection&lt;? extends E&gt; collection)</td><td>将指定集合中的所有元素添加到LinkedHashSet中</td></tr><tr><td>boolean</td><td>retainAll(Collection&lt;?&gt; collection)</td><td>仅保留LinkedHashSet中与指定集合中的元素相同的元素，移除其他元素。</td></tr></tbody></table></li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedHashSet&lt;String&gt; linkedHashSet = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;String&gt;();</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">linkedHashSet.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">linkedHashSet.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String s : linkedHashSet) </span><br><span class="line">    System.out.println(s);</span><br></pre></td></tr></table></figure><h1 id="4、Map-键值集合"><a href="#4、Map-键值集合" class="headerlink" title="4、Map 键值集合"></a>4、Map 键值集合</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1692348528480-a3aa549e-6406-4b56-8e0d-011acc815d14.png#averageHue=%23373230&clientId=u04d8008e-237f-4&from=drop&height=316&id=RoLuc&originHeight=1046&originWidth=1872&originalType=binary&ratio=1&rotation=0&showTitle=false&size=710965&status=done&style=none&taskId=u964c333a-3258-44e9-beb3-a35f70e9c82&title=&width=566.3999938964844" alt="image.png"></p><ul><li>Map集合特点 ：key:value对映射关系、键不能重复，值可以重复、元素存取无序</li></ul><h2 id="4-1-HashMap-⭐"><a href="#4-1-HashMap-⭐" class="headerlink" title="4.1 HashMap ⭐"></a>4.1 HashMap ⭐</h2><p>:::tips<br><strong>概述：</strong>HashMap使用哈希表来存储数据，通过计算键的哈希值来确定其在内部数组中的存储位置。</p><ol><li>HashMap的键是唯一的，如果插入相同的键，新的值会覆盖旧的值。它不保证键值对的顺序，也不保证插入顺序和访问顺序一致。</li><li>使用HashMap可以快速地插入、获取、更新和删除键值对，其时间复杂度为O(1)。它是线程不安全的，需要在多线程环境下使用可以使用ConcurrentHashMap。</li><li>HashMap在遍历时，不保证元素的顺序，如果需要有序遍历，可以考虑使用LinkedHashMap。此外，由于哈希碰撞的存在，当键的哈希值相同时，会使用链表或红黑树等数据结构来解决冲突，以保证性能。<br>:::<table><thead><tr><th><strong>返回值</strong></th><th><strong>方法名</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>V</td><td>put(K key, V value)</td><td>将指定的键值对添加到HashMap中【键存在：并返回之前关联的值 &#x2F; 键不存在：则返回null】</td></tr><tr><td>V</td><td>remove(Object key)</td><td>移除HashMap中指定键对应的键值对，并返回之前关联的值。</td></tr><tr><td>boolean</td><td>containsKey(Object key)</td><td></td></tr><tr><td>containsValue(Object value)</td><td>判断HashMap中是否包含指定键 &#x2F; 值。</td><td></td></tr></tbody></table></li></ol><ul><li>集合的<strong>获取功能</strong><table><thead><tr><th><strong>返回值</strong></th><th><strong>方法名</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>V</td><td>get(Object key)</td><td>根据<strong>键</strong>获取<strong>值</strong></td></tr><tr><td>Set<K></td><td>keySet()</td><td>获取<strong>所有键</strong>的集合</td></tr><tr><td>Collection<V></td><td>values()</td><td>获取<strong>所有值</strong>的集合</td></tr><tr><td>Set<K></td><td>entrySet()</td><td>获取<strong>所有键值对对象</strong>的集合</td></tr></tbody></table></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;郭靖&quot;</span>, <span class="string">&quot;黄蓉&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//V get(Object key):根据键获取值</span></span><br><span class="line">System.out.println(map.get(<span class="string">&quot;张无忌&quot;</span>));</span><br><span class="line">System.out.println(map.get(<span class="string">&quot;张三丰&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//Set&lt;K&gt; keySet():获取所有键的集合</span></span><br><span class="line">Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line"><span class="keyword">for</span>(String key : keySet) </span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key); <span class="comment">//获得到value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Collection&lt;V&gt; values():获取所有值的集合</span></span><br><span class="line">Collection&lt;String&gt; values = map.values();</span><br><span class="line"><span class="keyword">for</span>(String value : values) </span><br><span class="line">    System.out.println(value);</span><br></pre></td></tr></table></figure><p>:::tips</p><ul><li>增加（put）操作：添加键值对的时间复杂度为O(1)。</li><li>删除（remove）操作：删除键值对的时间复杂度为O(1)。</li><li>修改（put）操作：修改键值对的时间复杂度为O(1)。</li><li>查找（get）操作：根据键获取值的时间复杂度为O(1)。<br>:::</li></ul><blockquote><p>1、String值是Student</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String, Student&gt; hm = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Student&gt;();</span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;林青霞&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张曼玉&quot;</span>, <span class="number">35</span>);</span><br><span class="line">hm.put(<span class="string">&quot;itheima001&quot;</span>, s1);</span><br><span class="line">hm.put(<span class="string">&quot;itheima002&quot;</span>, s2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式1：键找值</span></span><br><span class="line">Set&lt;String&gt; keySet = hm.keySet();</span><br><span class="line"><span class="keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">value</span> <span class="operator">=</span> hm.get(key);</span><br><span class="line">    System.out.println(key + <span class="string">&quot;,&quot;</span> + value.getName() + <span class="string">&quot;,&quot;</span> + value.getAge());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2：键值对对象找键和值</span></span><br><span class="line">Set&lt;Map.Entry&lt;String, Student&gt;&gt; entrySet = hm.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Student&gt; me : entrySet) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> me.getKey();</span><br><span class="line">    <span class="type">Student</span> <span class="variable">value</span> <span class="operator">=</span> me.getValue();</span><br><span class="line">    System.out.println(key + <span class="string">&quot;,&quot;</span> + value.getName() + <span class="string">&quot;,&quot;</span> + value.getAge());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2、Student值是String</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Student, String&gt; hm = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Student, String&gt;();</span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;林青霞&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张曼玉&quot;</span>, <span class="number">35</span>);</span><br><span class="line">hm.put(s1, <span class="string">&quot;西安&quot;</span>);</span><br><span class="line">hm.put(s2, <span class="string">&quot;武汉&quot;</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;Student&gt; keySet = hm.keySet();</span><br><span class="line"><span class="keyword">for</span> (Student key : keySet) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> hm.get(key);</span><br><span class="line">    System.out.println(key.getName() + <span class="string">&quot;,&quot;</span> + key.getAge() + <span class="string">&quot;,&quot;</span> +</span><br><span class="line">                       value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-TreeMap-LinkedHashMap"><a href="#4-2-TreeMap-LinkedHashMap" class="headerlink" title="4.2 TreeMap &#x2F; LinkedHashMap"></a>4.2 TreeMap &#x2F; LinkedHashMap</h2><ul><li><p>TreeMap：</p><table><thead><tr><th><strong>返回值</strong></th><th><strong>方法名</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>K</td><td>firstKey()</td><td></td></tr><tr><td>lastKey()</td><td>返回TreeMap中最小的键</td><td></td></tr><tr><td>返回TreeMap中最大的键</td><td></td><td></td></tr><tr><td>K</td><td>higherKey(K key)</td><td></td></tr><tr><td>lowerKey(K key)</td><td>返回TreeMap中严格大于给定键的最小键；</td><td></td></tr><tr><td>返回TreeMap中严格小于给定键的最大键；</td><td></td><td></td></tr><tr><td>K</td><td>ceilingKey(K key)</td><td></td></tr><tr><td>floorKey(K key)</td><td>返回TreeMap中大于或等于给定键的最小键；</td><td></td></tr><tr><td>返回TreeMap中小于或等于给定键的最大键；</td><td></td><td></td></tr><tr><td>Map.Entry&lt;K, V&gt;</td><td>pollFirstEntry()</td><td></td></tr><tr><td>pollLastEntry()</td><td>移除并返回TreeMap中最小的键值对</td><td></td></tr><tr><td>移除并返回TreeMap中最大的键值对</td><td></td><td></td></tr></tbody></table></li><li><p>LinkedHashMap：</p><table><thead><tr><th><strong>返回值</strong></th><th><strong>方法名</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>boolean</td><td>removeEldestEntry(Map.Entry&lt;K, V&gt; eldest)</td><td>在插入新的键值对之后，判断是否需要移除最老的键值对。默认实现为始终返回false，即不移除最老的键值对。如果需要实现移除策略，可以重写该方法。</td></tr></tbody></table></li></ul><p>:::tips</p><ul><li>增加（put）操作：添加键值对的时间复杂度为O(log n)。</li><li>删除（remove）操作：删除键值对的时间复杂度为O(log n)。</li><li>修改（put）操作：修改键值对的时间复杂度为O(log n)。</li><li>查找（get）操作：根据键获取值的时间复杂度为O(log n)。<br>:::</li></ul><h1 id="5、工具类"><a href="#5、工具类" class="headerlink" title="5、工具类"></a>5、工具类</h1><ul><li>工具类设计思想 <ul><li>构造方法用private修饰</li><li>成员用public static修饰</li></ul></li></ul><h2 id="5-1-Collections"><a href="#5-1-Collections" class="headerlink" title="5.1 Collections"></a>5.1 Collections</h2><blockquote><p>1、Collections概述和使用</p></blockquote><ul><li>Collections类的作用<br>是针对集合操作的工具类 </li><li>Collections类常用方法 <table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static void sort(List list)</td><td>升序</td></tr><tr><td>public static void reverse(List list)</td><td>反转</td></tr><tr><td>public static void shuffle(List list)</td><td>随机排序</td></tr></tbody></table></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list);</span><br><span class="line">Collections.reverse(list);</span><br><span class="line">Collections.shuffle(list);</span><br></pre></td></tr></table></figure><ul><li>详细方法：<table><thead><tr><th><strong>返回值</strong></th><th><strong>方法名</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>void</td><td>sort(list)</td><td>对指定的List升序排序，</td></tr><tr><td>要求元素的类型实现Comparable接口</td><td></td><td></td></tr><tr><td>void</td><td>reverse(list)</td><td>反转指定List中元素的顺序</td></tr><tr><td>int</td><td>binarySearch(list, key)</td><td>使用二分查找算法查找已排序List指定的关键字。返回关键字在List中的索引，如果找不到则返回负数</td></tr><tr><td>void</td><td>shuffle(list)</td><td>随机排列指定List中的元素</td></tr><tr><td>boolean</td><td>addAll(collection, elements)</td><td>将指定元素添加到指定Collection中。</td></tr><tr><td>如果Collection发生改变，则返回true。</td><td></td><td></td></tr><tr><td>T</td><td>max(collection)</td><td></td></tr><tr><td>min(collection)</td><td>返回集合中的最大&#x2F;最小元素</td><td></td></tr><tr><td>int</td><td>frequency(collection, object)</td><td>返回指定对象在指定</td></tr><tr><td>Collection中出现的次数</td><td></td><td></td></tr><tr><td>Object[]</td><td>toArray(collection)</td><td>将指定Collection转换为数组</td></tr><tr><td>Collection<T></td><td>synchronizedCollection(collection)</td><td>返回指定Collection的同步</td></tr><tr><td>（线程安全）版本</td><td></td><td></td></tr></tbody></table></li></ul><h2 id="5-2-Arrays"><a href="#5-2-Arrays" class="headerlink" title="5.2 Arrays"></a>5.2 Arrays</h2><ul><li><p>Arrays的常用方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static String toString(int[] a)</td><td>返回指定数组的内容的字符串表达形式</td></tr><tr><td>public static void sort(int[] a)</td><td>按照数字顺序排列指定的数组</td></tr><tr><td><strong>public static List&lt;?&gt; asList(?)</strong></td><td><strong>将对象数组转为List集合</strong></td></tr></tbody></table></li><li><p>详细方法</p><table><thead><tr><th><strong>返回值</strong></th><th><strong>方法名</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>String</td><td>toString(array)</td><td>将指定数组转换为字符串表示形式。返回的字符串包含数组的元素，以逗号分隔，并使用方括号括起来。</td></tr><tr><td>List<T></td><td>asList(array)</td><td>将数组转换为List集合</td></tr><tr><td>Stream<T></td><td>stream(array)</td><td>将数组转换为流（Stream）对象，</td></tr><tr><td>可以进行各种流操作。</td><td></td><td></td></tr><tr><td>void</td><td>sort(array)</td><td>对数组进行升序排序。要求数组元素的类型实现Comparable接口。</td></tr><tr><td>int</td><td>binarySearch(array, key)</td><td>返回栈顶的元素，但不移除它</td></tr><tr><td>T[]</td><td>copyOf(original, newLength)</td><td>对集合的每个剩余元素执行指定的操作</td></tr><tr><td>void</td><td>fill(array, value)</td><td>将指定值填充到数组的每个元素中</td></tr><tr><td>int</td><td>hashCode(array)</td><td>返回指定数组的哈希码值</td></tr></tbody></table></li></ul><h1 id="【拓展】"><a href="#【拓展】" class="headerlink" title="【拓展】"></a>【拓展】</h1><h2 id="HashTable-ConcurrentHashMap"><a href="#HashTable-ConcurrentHashMap" class="headerlink" title="HashTable&#x2F;ConcurrentHashMap"></a>HashTable&#x2F;ConcurrentHashMap</h2><ul><li>集合体系架构图：</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1694220663655-e000d78c-654f-4616-b904-f4875c3eb689.png#averageHue=%23fcfcfa&from=url&id=pNtMv&originHeight=578&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=208718&status=done&style=none&title=" alt="mmexport1694220637139.png"></p><ul><li>HashTable存储发生哈希碰撞：</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1694221561795-34c9d2d2-233d-45a0-93dc-0dcf5873c557.png#averageHue=%23faf4ea&from=url&id=iKzoB&originHeight=241&originWidth=421&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24764&status=done&style=none&title=" alt="mmexport1694221541440.png"></p><ul><li>ConcurrentHashMap存储发生哈希碰撞：</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1694221582538-35559e6b-e671-42ee-b7fd-fc1ccfa0875b.png#averageHue=%23f1efee&from=url&id=xp9W6&originHeight=371&originWidth=663&originalType=binary&ratio=1&rotation=0&showTitle=false&size=38906&status=done&style=none&title=" alt="mmexport1694221547566.png"><br>当冲突链表达到一定长度时，链表会转换成红黑树。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;深入学习：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/143700575&quot;&gt;吃透Java集合框架！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简易知识体系：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;htt</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础/高级特性</title>
    <link href="http://example.com/2024/01/18/Java%E5%9F%BA%E7%A1%80:%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2024/01/18/Java%E5%9F%BA%E7%A1%80:%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</id>
    <published>2024-01-18T02:59:25.942Z</published>
    <updated>2024-01-18T03:28:06.844Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://caochenlei.blog.csdn.net/article/details/119992847">学习Java8这一篇就够了_java8会这些就够了-CSDN博客</a></p><ul><li>面试题：<a href="https://blog.csdn.net/qq_30999361/article/details/124482581">Java基础知识面试题（91道含答案）</a><br>:::tips<br>Java8新添特性：</li></ul><ol><li><strong>Lambda表达式：允许把函数作为一个方法的参数</strong>（函数作为参数传递到方法中），使代码更加简洁和可读，并有助于编写并行代码。<ul><li>Collections.sort(names, (s1, s2) -&gt; s1.compareTo(s2));</li></ul></li><li><strong>方法引用：方法引用提供了一种简化代码的方法。</strong>它可以直接引用已存在的方法&#x2F;构造器，减少冗余代码，与 Lambda 表达式一起使用<strong>。</strong><ul><li>Integer::parseInt</li></ul></li><li><strong>函数式接口：支持函数式编程的特性。</strong>提供了一系列的函数式接口，用于便捷地使用Lambda表达式和方法引用（java.util.function）<ul><li>Consumer<T>：接受一个输入参数并且不返回结果的操作</li><li>Supplier<T>：提供一个结果的供应商</li><li>Function&lt;T, R&gt;：将一个类型的值转换为另一个类型的值</li><li>Predicate<T>：对一个输入参数进行判断，并返回一个布尔值。</li></ul></li><li><strong>Stream API：提供了一种流式操作集合的方法。</strong>可以通过一系列的操作（如过滤、映射、收集等）对数据进行处理。它能够简化对集合的操作，并支持并行处理，函数式编程风格（java.util.stream）</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696661152842-f0c740e0-c9d3-4727-9eac-b601d6ad78fd.png#averageHue=%23f0efee&clientId=uff5592ff-7738-4&from=paste&height=74&id=tSWX4&originHeight=92&originWidth=713&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=3701&status=done&style=none&taskId=ue780d218-f8e3-4115-a1f1-77849734f6f&title=&width=570.4" alt="image.png"></p><ol start="5"><li><strong>默认方法：允许在接口中定义具有默认实现的方法。</strong>这样一来，即使在旧版本的接口中增加新的抽象方法，也不会破坏现有的实现类。</li><li><strong>Optional类：用于解决空指针异常的类。</strong>是一种用于处理可能为 null 的值的容器类。它可以减少空指针异常，并提供了一系列的方法来处理可能为空的值。（java.util.optional）<br>:::<blockquote><p>匿名内部类 —&gt; lambda —&gt; 方法引用</p></blockquote></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匿名内部类</span></span><br><span class="line">Consumer&lt;String&gt; consumer1 = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lambda表达式</span></span><br><span class="line">Consumer&lt;String&gt; consumer2 = s -&gt; System.out.println(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法引用【类::方法】默认传入参数s</span></span><br><span class="line">Consumer&lt;String&gt; consumer3 = System.out::println;</span><br></pre></td></tr></table></figure><ol><li><p><strong>Lambda表达式：</strong><a href="https://www.cainiaojc.com/java/java8-lambda-expressions.html">Java Lambda 表达式</a><strong>&#x2F;</strong><a href="http://dict.code-nav.cn/Java/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F.html">Lambda表达式</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 java 8 排序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sortUsingJava8</span><span class="params">(List&lt;String&gt; names)</span>&#123;</span><br><span class="line">  Collections.sort(names, (s1, s2) -&gt; s1.compareTo(s2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>方法引用：</strong><a href="https://www.cainiaojc.com/java/java8-method-references.html">Java 8 方法引用</a></p></li><li><p><strong>Stream流：</strong><a href="https://www.cainiaojc.com/java/java8-streams.html">Java 8 Stream</a><strong>【*】</strong><a href="http://dict.code-nav.cn/Java/Stream%20API.html#terminal-%E6%93%8D%E4%BD%9C">Stream API</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链式编程！！！！</span></span><br><span class="line">list.stream()</span><br><span class="line">.map((x)-&gt;x.getName().toUpperCase())</span><br><span class="line">.filter((x)-&gt;x.getId()%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">.sorted((x,y) -&gt; x.getWeight() - y.getWeight())</span><br><span class="line">.limit(<span class="number">5</span>)</span><br><span class="line">.collect(Collectors.toList())</span><br><span class="line">.forEach(System.out::println);</span><br></pre></td></tr></table></figure><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>### map</td><td></td></tr></tbody></table></li></ol><p> | <strong>【元素处理】</strong>对映射的每个元素进行相应处理<br>平方处理：.map( i -&gt; i*i) |<br>| ### filter<br> | <strong>【筛选过滤if】</strong>通过设置的条件过滤出元素<br>判空处理：filter(string -&gt; string.isEmpty()) |</p><ul><li>stream流两种形式：<ul><li>stream() − 为集合创建串行流。</li><li>parallelStream()  − 为集合创建并行流。</li></ul></li></ul><h1 id="1、基础知识"><a href="#1、基础知识" class="headerlink" title="1、基础知识"></a>1、基础知识</h1><blockquote><p>Java语言跨平台原理</p></blockquote><p>Java程序并非是直接运行的，Java编译器将Java源程序编译成与平台无关的字节码文件(class文件)，然后由Java虚拟机（JVM）对字节码文件解释执行。所以在不同的操作系统下，只需安装不同的Java虚拟机即可实现java程序的跨平台。</p><ul><li>JVM（Java Virtual Machine），Java虚拟机</li><li>JRE（Java Runtime Environment），Java运行环境，包含了JVM和Java的核心类库（Java API）</li><li>JDK（Java Development Kit）称为Java开发工具，包含了JRE和开发工具</li></ul><p>总结：我们只需安装JDK即可，它包含了java的运行环境和虚拟机。</p><ul><li>JVM的内存模型，分别是：<strong>栈内存</strong>、<strong>堆内存、</strong>寄存器、方法区、本地方法栈<table><thead><tr><th>区域名称</th><th>作用</th></tr></thead><tbody><tr><td><strong>堆内存</strong></td><td>存储对象或者数组，new来创建的，都存储在堆内存。</td></tr><tr><td><strong>方法栈</strong></td><td>方法运行时使用的内存，比如main和GC方法运行，进入方法栈中执行。</td></tr><tr><td>寄存器</td><td>给CPU使用，和我们开发无关。</td></tr><tr><td>本地方法栈</td><td>JVM在使用操作系统功能的时候使用，和我们开发无关。</td></tr><tr><td>方法区</td><td>存储可以运行的class文件。</td></tr></tbody></table></li></ul><p>Java虚拟机要运行程序，必须要对内存进行空间的分配和管理。</p><h2 id="1-1-基本数据类型-⭐"><a href="#1-1-基本数据类型-⭐" class="headerlink" title="1.1 基本数据类型 ⭐"></a>1.1 基本数据类型 ⭐</h2><p>Java是一个强类型语言，Java中的数据必须明确数据类型。<br>在Java中的数据类型包括<strong>基本数据类型</strong>和<strong>引用数据类型</strong>两种。</p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>关键字</strong></th><th><strong>内存占用（B）</strong></th><th><strong>取值范围（2的次方）</strong></th></tr></thead><tbody><tr><td>整数类型</td><td>byte</td><td>1</td><td>[-128,127]</td></tr><tr><td></td><td>short</td><td>2</td><td>[-215,215-1]</td></tr><tr><td></td><td><strong>int（默认）</strong></td><td>4</td><td>[-231,231-1]</td></tr><tr><td></td><td>long</td><td>8</td><td>[-263,263-1]</td></tr><tr><td>浮点类型</td><td>float</td><td>4</td><td>[-231,231-1]</td></tr><tr><td></td><td><strong>double（默认）</strong></td><td>8</td><td>[-263,263-1]</td></tr><tr><td>字符类型</td><td>char</td><td>2</td><td>[0,65535]</td></tr><tr><td>布尔类型</td><td>boolean</td><td>1</td><td>true，false</td></tr></tbody></table><ul><li><strong>类型转换：</strong>boolean类型不能与其他基本数据类型相互转换</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697201457602-ef51df63-02e8-4310-86c8-954dfa5719ed.png#averageHue=%23fdfcfc&clientId=uef60bb95-3f71-4&id=jHcfN&originHeight=197&originWidth=775&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u42731f98-5f42-4ba0-929b-dfac43ceb94&title="><br>char字符对应的一些特殊值<br>:::tips</p><ul><li>‘a’ – 97 a-z是连续的，所以’b’对应的数值是98，’c’是99，依次递加</li><li>‘A’ – 65 A-Z是连续的，所以’B’对应的数值是66，’C’是67，依次递加</li><li>‘0’ – 48 0-9是连续的，所以’1’对应的数值是49，’2’是50，依次递加<br>:::</li></ul><h2 id="1-2-抽象类-接口-⭐"><a href="#1-2-抽象类-接口-⭐" class="headerlink" title="1.2 抽象类 &#x2F; 接口 ⭐"></a>1.2 抽象类 &#x2F; 接口 ⭐</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697198074254-9cc9eff1-9fe8-44d9-a692-3d4d3038e3cf.png#averageHue=%23f9efe9&clientId=uef60bb95-3f71-4&id=IWMPo&originHeight=339&originWidth=613&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u811002d9-b5be-4639-94ff-f7b99be2a20&title="><br>:::tips<br>相同点：</p><ol><li>都<strong>不能被实例化</strong></li><li>接口的实现类&#x2F;抽象类的子类都只有实现或继承之后才能被实例化</li></ol><p>不同点：</p><ol><li>实现接口implements，继承抽象类extends，一个类可以实现多个接口，但只能继承一个抽象类</li><li>接口只有<strong>方法定义</strong>，没有实现；抽象类中有<strong>方法定义</strong>和<strong>方法实现</strong></li><li>接口强调特定功能的实现，抽象类强调所属关系<br>:::<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象类的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> class 类名 &#123;&#125;</span><br><span class="line"><span class="comment">//抽象方法的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口用关键字interface修饰</span></span><br><span class="line"><span class="keyword">public</span> interface 接口名 &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类实现接口用implements表示</span></span><br><span class="line"><span class="keyword">public</span> class 类名 implements 接口名 &#123;&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="1-3-权限修饰符"><a href="#1-3-权限修饰符" class="headerlink" title="1.3 权限修饰符"></a>1.3 权限修饰符</h2><table><thead><tr><th></th><th><strong>同一类</strong></th><th><strong>同一包子类无关类</strong></th><th><strong>不同包的子类</strong></th><th><strong>不同包的非子类</strong></th></tr></thead><tbody><tr><td><strong>public</strong></td><td>✔️</td><td>✔️</td><td>✔️</td><td>✔️</td></tr><tr><td><strong>protected</strong></td><td>✔️</td><td>✔️</td><td>✔️</td><td></td></tr><tr><td><strong>默认</strong></td><td>✔️</td><td>✔️</td><td></td><td></td></tr><tr><td><strong>private</strong></td><td>✔️</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>修饰类时，只能使用 public 或默认访问修饰符（不使用任何修饰符）。</li><li>在接口中，接口的所有成员都默认使用 public 访问权限。</li></ul><h2 id="1-4-final-static"><a href="#1-4-final-static" class="headerlink" title="1.4 final &#x2F; static"></a>1.4 final &#x2F; static</h2><ul><li>final 用于限定不可修改的特性，用于限制继承和修改</li><li>static 用于表示类级别的共享特性，用于实现共享和方便访问。<br>:::tips</li></ul><ol><li><strong>修饰范围：</strong></li></ol><ul><li>final：可以修饰类、方法和变量。被 final 修饰的类不能被继承，被 final 修饰的方法不能被子类重写，被 final 修饰的变量是不可修改的。</li><li>static：可以修饰方法、变量和内部类。被 static 修饰的方法和变量属于类级别，可以直接通过类名访问，不需要创建对象。</li></ul><ol start="2"><li><strong>内存分配：</strong></li></ol><ul><li>final：被 final 修饰的变量在声明时必须被初始化，且其值在初始化后不能再被修改。</li><li>static：被 static 修饰的变量属于类级别，只有一份实例存在，被所有对象共享。</li></ul><ol start="3"><li><strong>继承和多态性：</strong></li></ol><ul><li>final：被 final 修饰的类不能被继承，被 final 修饰的方法不能被子类重写，但可以被继承类继承和调用。</li><li>static：静态方法和变量属于类级别，不具备多态性。</li></ul><ol start="4"><li><strong>访问方式：</strong></li></ol><ul><li>final：被 final 修饰的类、方法和变量可以通过对象或类名直接访问。</li><li>static：被 static 修饰的方法和变量可以直接通过类名访问，不需要创建对象，静态内部类也可以通过类名直接访问。<br>:::</li></ul><h2 id="1-5-可变参数"><a href="#1-5-可变参数" class="headerlink" title="1.5 可变参数"></a>1.5 可变参数</h2><ul><li><p>可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了 【变量其实是一个数组】</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>... a)</span> &#123; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>可变参数的使用</p></blockquote></li><li><p>Arrays工具类中有一个静态方法： </p><ul><li>public static List <strong>asList</strong>(T… a)：返回由指定数组支持的固定大小的列表</li><li>返回的集合不能做增删操作，可以做修改操作<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">asList</span><span class="params">(T... a)</span>：<span class="comment">//返回由指定数组支持的固定大小的列表</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;java&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;javaee&quot;</span>); <span class="comment">//UnsupportedOperationException</span></span><br><span class="line">list.remove(<span class="string">&quot;world&quot;</span>); <span class="comment">//UnsupportedOperationException</span></span><br><span class="line">list.set(<span class="number">1</span>,<span class="string">&quot;javaee&quot;</span>);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>List接口中有一个静态方法： </p><ul><li>public static List <strong>of</strong>(E… elements)：返回包含任意数量元素的不可变列表</li><li>返回的集合不能做增删改操作<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">of</span><span class="params">(E... elements)</span>：<span class="comment">//返回包含任意数量元素的不可变列表</span></span><br><span class="line">List&lt;String&gt; list = List.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;javaee&quot;</span>);<span class="comment">//UnsupportedOperationException</span></span><br><span class="line">list.remove(<span class="string">&quot;java&quot;</span>);<span class="comment">//UnsupportedOperationException</span></span><br><span class="line">list.set(<span class="number">1</span>,<span class="string">&quot;javaee&quot;</span>);<span class="comment">//UnsupportedOperationException</span></span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Set接口中有一个静态方法： </p><ul><li>public static Set <strong>of</strong>(E… elements) ：返回一个包含任意数量元素的不可变集合</li><li>在给元素的时候，不能给重复的元素</li><li>返回的集合不能做增删操作，没有修改的方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="title function_">of</span><span class="params">(E... elements)</span> ：<span class="comment">//返回一个包含任意数量元素的不可变集合</span></span><br><span class="line">Set&lt;String&gt; set = Set.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;java&quot;</span>,<span class="string">&quot;world&quot;</span>);<span class="comment">//IllegalArgumentException</span></span><br><span class="line">Set&lt;String&gt; set = Set.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;java&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;javaee&quot;</span>);<span class="comment">//UnsupportedOperationException</span></span><br><span class="line">set.remove(<span class="string">&quot;world&quot;</span>);<span class="comment">//UnsupportedOperationException</span></span><br><span class="line">System.out.println(set);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="1-6-对象内存图"><a href="#1-6-对象内存图" class="headerlink" title="1.6 对象内存图"></a>1.6 对象内存图</h2><ul><li><strong>成员变量</strong>使用过程</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697200484068-46fe8cfa-d4b1-44d2-9b35-034813be38e4.png#averageHue=%23f5f3c2&clientId=uef60bb95-3f71-4&id=WI3Pj&originHeight=318&originWidth=749&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0647274f-a895-40ce-9feb-9b630d03f92&title="></p><ul><li><strong>成员方法</strong>调用过程</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697203348688-d0facadb-a4ce-4b55-b69e-77bdc977bb77.png#averageHue=%23f0e9bb&clientId=uef60bb95-3f71-4&id=Pu5ej&originHeight=244&originWidth=695&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5290bde1-50b8-4227-94db-e96b13238f6&title="><br>注：多个对象在堆内存中，都有不同的内存划分，成员变量存储在各自的内存区域中，成员方法多个对象共用的一份。</p><h1 id="2、面向对象"><a href="#2、面向对象" class="headerlink" title="2、面向对象"></a>2、面向对象</h1><h2 id="2-1-封装"><a href="#2-1-封装" class="headerlink" title="2.1 封装"></a>2.1 封装</h2><p>:::tips<br><strong>封装：</strong>是面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作的 ；</p><ul><li><strong>原则：</strong>将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问：成员变量private，提供对应的getXxx()&#x2F;setXxx()方法 ；</li><li><strong>好处：</strong>通过方法来控制成员变量的操作，提高了代码的安全性 把代码用方法进行封装，提高了代码的复用性；<br>:::</li></ul><h2 id="2-2-继承"><a href="#2-2-继承" class="headerlink" title="2.2 继承"></a>2.2 继承</h2><p>:::tips<br><strong>继承：</strong>继承可以让类与类之间产生关系，子类则可以<strong>使用父类中非私有的成员</strong>（extends）</p><ul><li><strong>优点</strong>：<ul><li>提高代码的<strong>复用性</strong>(多个类相同的成员可以放到同一个类中)</li><li>提高代码的<strong>维护性</strong>(如果方法的代码需要修改，修改一处即可)</li></ul></li><li><strong>弊端</strong>：继承让类与类之间产生了关系，<strong>类的耦合性增强</strong>，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性<br>:::</li></ul><ol><li>继承中变量的<strong>访问特点（就近原则）</strong>：<ul><li>子类局部 —&gt; 子类成员 —&gt; 父类成员(不考虑父亲的父亲…)</li></ul></li><li><strong>super关键字</strong><br>:::tips<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697199880884-3b332489-cfc3-463c-a72f-24c4f5a319d7.png#averageHue=%23f3e3ca&clientId=uef60bb95-3f71-4&id=A2Lrx&originHeight=321&originWidth=765&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5ae34483-c82a-4b47-83a0-5e766abf216&title="></li></ol><ul><li>super.成员变量 - 访问父类成员变量</li><li>super.成员方法 - 访问父类成员方法</li><li>super(…) - 访问父类构造方法<br>:::</li></ul><h2 id="2-3-多态"><a href="#2-3-多态" class="headerlink" title="2.3 多态"></a>2.3 多态</h2><p>:::tips<br><strong>多态：</strong>同一个对象，在不同时刻表现出来的不同形态（前提条件：有继承&#x2F;实现关系、有方法重写、父类引用指向子类对象  Animal animal1 &#x3D; new Dog();）</p><ul><li><strong>优缺点：</strong><ul><li><strong>优点：提高程序的扩展性。</strong>定义方法时候，使用<strong>父类型作为参数</strong>，在使用的时候，使用<strong>具体的子类型参与操作；</strong></li><li><strong>弊端：不能使用子类的特有成员</strong>，基于弊端，因此我们不需要在子类中定义成员方法</li></ul></li><li><strong>编译原则：</strong><ul><li><strong>成员变量</strong>：编译看父类，运行看父类 </li><li><strong>成员方法</strong>：编译看父类，运行看子类</li></ul></li><li><strong>多态形式：</strong><ul><li><strong>编译时多态（静态多态）：</strong>通过方法的重载实现，即在同一类中定义多个同名的方法，但参数列表不同。根据调用时传递的参数类型，编译器在编译阶段就可以确定调用的方法，并进行静态绑定。</li><li><strong>运行时多态（动态多态）：</strong>通过方法的覆盖实现，即子类重写父类的方法，且方法签名完全一致。通过父类或接口的引用变量指向子类对象时，根据实际对象的类型进行动态绑定，即在运行时根据对象的实际类型确定调用的方法。<br> :::<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal is making a sound.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> / Cat <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog is barking.&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat is meowing.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        animal1.makeSound(); <span class="comment">// 输出：Dog is barking.</span></span><br><span class="line">        animal2.makeSound(); <span class="comment">// 输出：Cat is meowing.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="3、常用API"><a href="#3、常用API" class="headerlink" title="3、常用API"></a>3、常用API</h1><p>API (Application Programming Interface) ：应用程序编程接口</p><h2 id="3-1-String类-⭐"><a href="#3-1-String类-⭐" class="headerlink" title="3.1 String类 ⭐"></a>3.1 String类 ⭐</h2><ul><li>java.lang包下的类<blockquote><p>String构造方法</p></blockquote></li></ul><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public String()</td><td>创建一个空白字符串对象，不含有任何内容</td></tr><tr><td>public String(char[] chs)</td><td>根据字符数组的内容，来创建字符串对象</td></tr><tr><td>public String(byte[] bys)</td><td>根据字节数组的内容，来创建字符串对象</td></tr><tr><td>String s &#x3D; “abc”;</td><td>直接赋值的方式创建字符串对象，内容就是abc</td></tr></tbody></table><blockquote><p><strong>String常用方法</strong></p></blockquote><ol><li><p><strong>与“长度”有关</strong></p><table><thead><tr><th>返回类型</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>int</td><td>length()</td><td>得到一个字符串的<strong>字符个数</strong></td></tr></tbody></table></li><li><p><strong>与“数组”有关</strong></p><table><thead><tr><th>返回类型</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>byte[]</td><td>getBytes()</td><td>将一个字符串转换成<strong>字节数组</strong></td></tr><tr><td>char[]</td><td>toCharArray()</td><td>将一个字符串转换成<strong>字符数组</strong></td></tr><tr><td>String[]</td><td>split(String)</td><td>将一个字符串<strong>按照指定内容分开</strong></td></tr></tbody></table></li><li><p><strong>与“判断”有关</strong></p><table><thead><tr><th>返回类型</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>boolean</td><td>equals(String)</td><td>判断<strong>两个字符串的内容</strong></td></tr><tr><td>boolean</td><td>equalsIgnoreCase(String)</td><td>判断<strong>两个字符串的内容</strong>（忽略大小写）</td></tr><tr><td>boolean</td><td>contains(String)</td><td>判断一个字符串里面<strong>是否包含指定的内容</strong></td></tr><tr><td>boolean</td><td>startsWith(String)</td><td>判断一个字符串是否<strong>以指定的内容开头</strong></td></tr><tr><td>boolean</td><td>endsWith(String)</td><td>判断一个字符串是否<strong>以指定的内容结尾</strong></td></tr></tbody></table></li><li><p><strong>与“修改内容”有关</strong></p><table><thead><tr><th>返回类型</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>String</td><td>toUpperCase()</td><td>将一个字符串全部转换成大写</td></tr><tr><td>String</td><td>toLowerCase()</td><td>将一个字符串全部转换成小写</td></tr><tr><td>String</td><td>replace(String,String)</td><td>将某个内容全部替换成指定内容</td></tr><tr><td>String</td><td>replaceAll(String,String)</td><td>将某个内容全部替换成指定内容【支持正则】</td></tr><tr><td>String</td><td>repalceFirst(String,String)</td><td>将第一次出现的某个内容替换成指定的内容</td></tr><tr><td>String</td><td>substring(int)</td><td>从指定下标开始一直<strong>截取</strong>到字符串的最后</td></tr><tr><td>String</td><td>substring(int,int)</td><td>从下标x<strong>截取</strong>到下标y-1对应的元素</td></tr><tr><td>String</td><td>trim()</td><td>去除一个字符串的前后空格</td></tr></tbody></table></li><li><p><strong>与”位置“有关</strong></p><table><thead><tr><th>返回类型</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>char</td><td>charAt(int)</td><td>得到指定下标位置对应的字符</td></tr><tr><td>int</td><td>indexOf(String)</td><td>得到指定内容第一次出现的下标</td></tr><tr><td>int</td><td>lastIndexOf(String)</td><td>得到指定内容最后一次出现的下标</td></tr></tbody></table></li></ol><blockquote><p>字符串的比较</p></blockquote><ul><li>&#x3D;&#x3D;号的作用<ul><li>比较<strong>基本</strong>数据类型：比较的是<strong>具体的值</strong></li><li>比较<strong>引用</strong>数据类型：比较的是<strong>对象地址值（相比值使用equals方法）</strong></li></ul></li></ul><h2 id="3-2-StringBuilder类-⭐"><a href="#3-2-StringBuilder类-⭐" class="headerlink" title="3.2 StringBuilder类 ⭐"></a>3.2 StringBuilder类 ⭐</h2><p>StringBuilder 是一个可变的字符串类，我们可以把它看成是一个容器，这里的可变指的是 StringBuilder 对象中的内容是可变的<br>:::tips</p><ul><li><p>StringBuilder类和String类的区别 </p><ul><li>String类：内容是不可变的</li><li>StringBuilder类：内容是可变的<br> :::</li></ul></li><li><p>构造方法 </p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>StringBuilder()</td><td>创建一个空白可变字符串对象，不含有任何内容</td></tr><tr><td>StringBuilder(String str)</td><td>根据字符串的内容，来创建可变字符串对象</td></tr></tbody></table></li><li><p>常用的方法</p><table><thead><tr><th>返回值</th><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>StringBuilder</td><td>append (T)</td><td>添加数据，并返回对象本身</td></tr><tr><td>StringBuilder</td><td>reverse()</td><td>返回相反的字符序列</td></tr><tr><td>int</td><td>length()</td><td>返回长度，实际存储值</td></tr><tr><td>String</td><td>toString()</td><td>StringBuilder转换为String</td></tr></tbody></table></li></ul><blockquote><p>StringBuilder和String相互转换</p></blockquote><ul><li><p>StringBuilder转换为String：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br></pre></td></tr></table></figure></li><li><p>String转换为StringBuilder：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-3-Math-System类"><a href="#3-3-Math-System类" class="headerlink" title="3.3 Math &#x2F; System类"></a>3.3 Math &#x2F; System类</h2><p>概述：基本数字运算</p><ul><li>调用方式：Math类中无构造方法，但内部的方法都是静态的，则可以通过类名进行调用。</li></ul><ol><li><p>**Math类常用方法 **</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static int <strong>abs</strong>(int a)</td><td>返回参数的绝对值</td></tr><tr><td>public static double <strong>ceil</strong>(double a)</td><td>返回大于或等于参数的最小double值，等于一个整数</td></tr><tr><td>public static double <strong>floor</strong>(double a)</td><td>返回小于或等于参数的最大double值，等于一个整数</td></tr><tr><td>public static int <strong>round</strong>(float a)</td><td>按照四舍五入返回最接近参数的int</td></tr><tr><td>public static int <strong>max</strong>(int a,int b)</td><td>返回两个int值中的较大值</td></tr><tr><td>public static int <strong>min</strong>(int a,int b)</td><td>返回两个int值中的较小值</td></tr><tr><td>public static double <strong>pow</strong> (double a,double b)</td><td>返回a的b次幂的值</td></tr><tr><td>public static double <strong>random</strong>()</td><td>返回值为double的正值，[0.0,1.0)</td></tr></tbody></table></li><li><p><strong>System类的常用方法</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static void exit(int status)</td><td>终止当前运行的 Java 虚拟机，非零表示异常终止</td></tr><tr><td>public static long currentTimeMillis()</td><td>返回当前时间(以毫秒为单位)</td></tr></tbody></table></li></ol><ul><li>需求：在控制台输出1-10000，计算这段代码执行了多少毫秒<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取开始的时间节点</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 获取代码运行结束后的时间节点</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">&quot;共耗时：&quot;</span> + (end ­ start) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-4-包装类"><a href="#3-4-包装类" class="headerlink" title="3.4 包装类"></a>3.4 包装类</h2><ul><li>作用：将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据，常用的操作之一：用于<strong>基本数据类型</strong>与<strong>字符串</strong>之间的转换 </li><li>除了int变为Integer、char变成Character之外，其他都是开头改大写变成包装类</li></ul><p><strong>Integer类概述：</strong>包装一个对象中的原始类型 int 的值</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static Integer valueOf(int i)</td><td>返回表示指定的 int 值的 Integer 实例</td></tr><tr><td>public static Integer valueOf(String s)</td><td>返回一个保存指定值的 Integer 对象 String</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.valueOf(<span class="string">&quot;100&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>int和String类型的相互转换</p></blockquote><ul><li><p>**int转换成String **</p><ul><li>方法一：直接在数字后加一个空字符串</li><li><strong>方法二</strong>：通过String类静态方法<strong>valueOf()</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> number + <span class="string">&quot;&quot;</span>; <span class="comment">//方式1</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> String.valueOf(number); <span class="comment">//方式2</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>**String转换成int **</p><ul><li>方法一：先将字符串数字转成Integer，再调用valueOf()方法</li><li><strong>方式二</strong>：通过Integer静态方法**parseInt()**进行转换<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;100&quot;</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(s); <span class="comment">//方式1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">s1</span> <span class="operator">=</span> i.intValue();</span><br><span class="line"><span class="type">int</span> <span class="variable">s2</span> <span class="operator">=</span> Integer.parseInt(s); <span class="comment">//方式2</span></span><br></pre></td></tr></table></figure><blockquote><p>自动拆箱和自动装箱</p></blockquote></li></ul></li><li><p><strong>自动装箱</strong>：把基本数据类型转换为对应的包装类类型 </p></li><li><p>** 自动拆箱**：把包装类类型转换为对应的基本数据类型 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 自动装箱</span></span><br><span class="line">i += <span class="number">200</span>; <span class="comment">// i + 200 自动拆箱；注意：i=i+200 是自动装箱</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="3-5-Date-Calender类"><a href="#3-5-Date-Calender类" class="headerlink" title="3.5 Date &#x2F; Calender类"></a>3.5 Date &#x2F; Calender类</h2><blockquote><p>1、Date类</p></blockquote><p>概述：Date 代表了一个特定的时间，精确到毫秒 </p><ul><li>Date构造方法 <table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public Date()</td><td>分配一个 Date对象，并初始化，以便它代表它被分配的时间，精确到毫秒</td></tr><tr><td>public Date(long date)</td><td>分配一个 Date对象，并将其初始化为表示从<strong>标准基准时间</strong>起指定的毫秒数（Thu Jan 01 08:00:00 CST 1970）</td></tr></tbody></table></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();<span class="comment">//Sun Jan 29 16:23:30 CST 2023</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">date</span> <span class="operator">=</span> <span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>;</span><br><span class="line"><span class="type">Date</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(date); <span class="comment">//Thu Jan 01 09:00:00 CST 1970</span></span><br></pre></td></tr></table></figure><ul><li>常用方法<table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public long getTime()</td><td>获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值</td></tr><tr><td>public void setTime(long time)</td><td>设置时间，给的是毫秒值</td></tr></tbody></table></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">//创建日期对象</span></span><br><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">d.setTime(time);</span><br><span class="line">System.out.println(d); <span class="comment">//now</span></span><br></pre></td></tr></table></figure><blockquote><p>2、SimpleDateFormat类</p></blockquote><p>概述：SimpleDateFormat是一个具体的类，用于以区域设置敏感的方式格式化和解析日期。我们重点学习<strong>日期格式化</strong>和<strong>解析。</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public final String <strong>format</strong>(Date date)</td><td><strong>Date</strong>转换成<strong>String</strong></td></tr><tr><td>public Date <strong>parse</strong>(String source)</td><td><strong>String</strong>转换成<strong>Date</strong></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式化：从 Date 到 String</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sdf.format(d); <span class="comment">//2023年01月29日 16:36:27</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从 String 到 Date</span></span><br><span class="line"><span class="type">String</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="string">&quot;2048-08-09 11:11:11&quot;</span>;</span><br><span class="line"><span class="comment">//ParseException</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">dd</span> <span class="operator">=</span> sdf2.parse(ss); <span class="comment">//Sun Aug 09 11:11:11 CST 2048</span></span><br></pre></td></tr></table></figure><blockquote><p>3、自定义DateUtils日期工具类</p></blockquote><p>定义一个日期工具类(DateUtils)，包含两个方法：把日期转换为指定格式的字符串；把字符串解析为指定格式 的日期，然后定义一个测试类(DateDemo)，测试日期工具类的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DateUtils</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    把日期转为指定格式的字符串</span></span><br><span class="line"><span class="comment">    返回值类型：String</span></span><br><span class="line"><span class="comment">    参数：Date date, String format</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">dateToString</span><span class="params">(Date date, String format)</span> &#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(format);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sdf.format(date);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    把字符串解析为指定格式的日期</span></span><br><span class="line"><span class="comment">    返回值类型：Date</span></span><br><span class="line"><span class="comment">    参数：String s, String format</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">stringToDate</span><span class="params">(String s, String format)</span> <span class="keyword">throws</span></span><br><span class="line">        ParseException &#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(format);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> sdf.parse(s);</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">//创建日期对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> DateUtils.dateToString(d, <span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> DateUtils.dateToString(d, <span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> DateUtils.dateToString(d, <span class="string">&quot;HH:mm:ss&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;2048-08-09 12:12:12&quot;</span>;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">dd</span> <span class="operator">=</span> DateUtils.stringToDate(s, <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>4、Calender日历类</p></blockquote><p>概述：Calendar 为特定瞬间与一组日历字段之间的转换提供了一些方法，并为操作日历字段提供了一些方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Calendar.getInstance();</td><td>提供 Calendar 实例</td></tr><tr><td>public int <strong>get</strong>(int field)</td><td>返回给定日历字段的值</td></tr><tr><td>public abstract void <strong>add</strong>(int field, int amount)</td><td>根据日历的规则，将指定的时间量添加或减去给定的日历字段</td></tr><tr><td>public final void <strong>set</strong>(int year,int month,int date)</td><td>设置当前日历的年月日</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二月天案例：获取任意一年的二月有多少天</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalendarTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入年：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        </span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance(); <span class="comment">//设置日历对象的年、月、日</span></span><br><span class="line">        c.set(year, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        c.add(Calendar.DATE, -<span class="number">1</span>); <span class="comment">//3月1日往前推一天，就是2月的最后一天</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">date</span> <span class="operator">=</span> c.get(Calendar.DATE); <span class="comment">//获取这一天输出即可</span></span><br><span class="line">        System.out.println(year + <span class="string">&quot;年的2月份有&quot;</span> + date + <span class="string">&quot;天&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4、泛型"><a href="#4、泛型" class="headerlink" title="4、泛型"></a>4、泛型</h1><ul><li><p>概述：泛型是<strong>JDK5</strong>中引入的特性，它提供了<strong>编译时类型安全检测机制</strong>，该机制允许在编译时检测到非法的类型 它的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。一提到参数，最熟悉的就是定义方 法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，然后在使用&#x2F;调用时传入具体的类型。这种参数类型可以用在类、方法和接口中，分别被称为**泛型类、泛型方法、泛型接口 **<br>:::tips</p></li><li><p><strong>泛型定义格式：</strong></p><ul><li>&lt;类型&gt;：指定一种类型的格式。这里的类型可以看成是形参</li><li>&lt;类型1,类型2…&gt;：指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看成是形参</li><li>将来具体调用时候给定的类型可以看成是实参，并且实参的类型只能是引用数据类型</li></ul></li><li><p>**泛型的好处 **</p><ul><li>把运行时期的问题提前到了编译期间</li><li>避免了强制类型转换<br> :::</li></ul></li></ul><ol><li><p><strong>泛型类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 class 类名&lt;类型&gt; &#123; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getT</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setT</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Generic&lt;String&gt; g1 = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;String&gt;();</span><br><span class="line">Generic&lt;Integer&gt; g2 = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure></li><li><p><strong>泛型方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 &lt;类型&gt; 返回值类型 方法名(类型 变量名) &#123; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Generic</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Generic</span>();</span><br><span class="line">g.show(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">g.show(<span class="number">30</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>泛型接口</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 interface 接口名&lt;类型&gt; &#123; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generic</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generic</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Generic&lt;String&gt; g1 = <span class="keyword">new</span> <span class="title class_">GenericImpl</span>&lt;String&gt;();</span><br><span class="line">g1.show(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">Generic&lt;Integer&gt; g2 = <span class="keyword">new</span> <span class="title class_">GenericImpl</span>&lt;Integer&gt;();</span><br><span class="line">g2.show(<span class="number">30</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>类型通配符</strong></p></li></ol><ul><li><p>作用：为了表示各种泛型List的父类，可以使用类型通配符<br>:::tips<br><strong>类型通配符的分类：</strong></p></li><li><p>**类型通配符：&lt;?&gt; **</p><ul><li>List&lt;?&gt;：表示元素类型未知的List，它的元素可以匹配任何的类型</li><li>这种带通配符的List仅表示它是各种泛型List的父类，并不能把元素添加到其中</li></ul></li><li><p>**类型通配符上限： &lt;? extends 类型&gt; **</p><ul><li>List&lt;? extends Number&gt;：它表示的类型是Number或者其子类型</li></ul></li><li><p>**类型通配符下限： &lt;? super 类型&gt; **</p><ul><li>List&lt;? super Number&gt; ：它表示的类型是Number或者其父类型<br> :::<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类型通配符：&lt;?&gt;</span></span><br><span class="line">List&lt;?&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">List&lt;?&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line">List&lt;?&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//类型通配符上限：&lt;? extends 类型&gt;</span></span><br><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; list5 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; list6 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//类型通配符下限：&lt;? super 类型&gt;</span></span><br><span class="line">List&lt;? <span class="built_in">super</span> Number&gt; list7 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">List&lt;? <span class="built_in">super</span> Number&gt; list8 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line"><span class="comment">// List&lt;? super Number&gt; list9 = new ArrayList&lt;Integer&gt;();</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="5、异常-⭐"><a href="#5、异常-⭐" class="headerlink" title="5、异常 ⭐"></a>5、异常 ⭐</h1><ul><li><strong>父类 Throwable：</strong>Throwable 是 Java 异常体系的顶级父类，它具有两个重要的子类，即 Exception 和 Error</li><li><strong>异常 Error：</strong>Error 是严重的错误，表示 JVM 或底层系统发生的不可恢复的错误。Error 类型的异常通常不被捕获或声明抛出。</li><li><strong>错误 Exception：</strong>Exception 是可被检查的异常，表示程序在正常运行时遇到的非预期情况。Exception 类型的异常需要通过捕获或声明抛出来处理。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696662064627-4eaef782-aa66-4c90-8930-45e888de648a.png#averageHue=%23f4f3ee&clientId=uff5592ff-7738-4&from=drop&id=ud9e6568e&originHeight=485&originWidth=969&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=175405&status=done&style=none&taskId=u0e5a0331-1809-46cb-93f0-c83eea27263&title=" alt="74c5a727d11d1c36f75c9422f38e326a.png"><br>:::tips</p><ul><li><strong>编译时异常</strong> （都是Exception类及其子类）<ul><li>必须显示处理，否则程序就会发生错误，无法通过编译</li></ul></li><li><strong>运行时异常</strong> （都是RuntimeException类及其子类）<ul><li>无需显示处理，也可以和编译时异常一样处理<br> :::<br> <img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1694220597665-4d144d12-8d59-4ea2-9200-b359493466a1.png#averageHue=%23f2fcf4&from=url&id=tfZxQ&originHeight=661&originWidth=936&originalType=binary&ratio=1&rotation=0&showTitle=false&size=148307&status=done&style=none&title=" alt="mmexport1694220539925.png"></li></ul></li></ul><ol><li><p><strong>try-catch方式处理异常：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    可能出现异常的代码;</span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类名 变量名) &#123;</span><br><span class="line">    异常的处理代码;</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    执行完上面的一定执行的代码；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Throwable成员方法</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public String getMessage()</td><td>返回此 throwable 的详细消息字符串</td></tr><tr><td>public String toString()</td><td>返回此可抛出的简短描述</td></tr><tr><td>public void printStackTrace()</td><td>把异常的错误信息输出在控制台</td></tr></tbody></table></li></ol><h2 id="5-1-throw-throws"><a href="#5-1-throw-throws" class="headerlink" title="5.1 throw&#x2F;throws"></a>5.1 throw&#x2F;throws</h2><p><strong>throws和throw的区别：</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697187691766-f90aa803-1b56-4462-b99c-0fb7a1d6eddb.png#averageHue=%23ececec&clientId=ud965fb95-e94f-4&id=KSu5L&originHeight=131&originWidth=771&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3dbb7db9-3bfb-4526-ae2d-9df6b0ed7ae&title="></p><ol><li><p><strong>throw 处理异常：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">menthod</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;年龄不能小于18岁！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>throws 处理异常：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">menthod</span><span class="params">()</span> <span class="keyword">throws</span> 异常类名 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编译时异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;2048-08-09&quot;</span>;</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">    <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> sdf.parse(s);</span><br><span class="line">    System.out.println(d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行时异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> ArrayIndexOutOfBoundsException &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="5-2-自定义异常"><a href="#5-2-自定义异常" class="headerlink" title="5.2 自定义异常"></a>5.2 自定义异常</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScoreException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ScoreException</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ScoreException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkScore</span><span class="params">(<span class="type">int</span> score)</span> <span class="keyword">throws</span> ScoreException &#123;</span><br><span class="line">        <span class="keyword">if</span>(score&lt;<span class="number">0</span> || score&gt;<span class="number">100</span>) &#123;</span><br><span class="line">            <span class="comment">// throw new ScoreException();</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ScoreException</span>(<span class="string">&quot;你给的分数有误，分数应该在0-100之间&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;成绩正常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6、反射-⭐"><a href="#6、反射-⭐" class="headerlink" title="6、反射 ⭐"></a>6、反射 ⭐</h1><p>:::tips<br>是指在运行时去获取一个<strong>类的变量&#x2F;方法信息</strong>。然后通过<strong>获取到的信息来创建对象</strong>，调用方法的一种机制。 由于这种动态性，可以极大的增强程序的灵活性，程序不用在编译期就完成确定，在运行期仍然可以扩展<br>:::</p><h2 id="6-1-获取Class类对象的三种方法"><a href="#6-1-获取Class类对象的三种方法" class="headerlink" title="6.1 获取Class类对象的三种方法"></a>6.1 获取Class类对象的三种方法</h2><ul><li>类名.class属性</li><li>对象名.getClass()方法</li><li>Class.forName(全类名)方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">//使用类的class属性来获取该类对应的Class对象</span></span><br><span class="line">    Class&lt;Student&gt; c1 = Student.class;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用对象的getClass()方法，返回该对象所属类对应的Class对象</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Student</span>&gt; c3 = s.getClass();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用Class类中的静态方法forName(String className)</span></span><br><span class="line">    Class&lt;?&gt; c4 = Class.forName(<span class="string">&quot;com.itheima_02.Student&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-2-Class类反射获取属性"><a href="#6-2-Class类反射获取属性" class="headerlink" title="6.2 Class类反射获取属性"></a>6.2 Class类反射获取属性</h2><p>:::tips<br>Class类反射可以获取到（创建对象）：<strong>构造方法 &#x2F; 成员方法 &#x2F; 成员变量</strong><br>:::<br><strong>Class类反射获取：创建对象</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>T newInstance(Object…initargs)</td><td>根据指定的构造方法创建对象</td></tr></tbody></table><ol><li><strong>Class类反射获取：构造方法</strong><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>getConstructors()</td><td>返回所有公共构造方法对象的数组</td></tr><tr><td>getDeclaredConstructors()</td><td>返回所有构造方法对象的数组</td></tr><tr><td>getConstructor(Class… parameterTypes)</td><td>返回单个公共构造方法对象</td></tr><tr><td>getDeclaredConstructor(Class… parameterTypes)</td><td>返回单个构造方法对象</td></tr></tbody></table></li></ol><ul><li><p>案例1 ：通过反射获取<strong>公共的构造方法</strong>并创建对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Class对象</span></span><br><span class="line">Class&lt;?&gt; c = Class.forName(<span class="string">&quot;com.itheima_02.Student&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; con = c.getConstructor(String.class, <span class="type">int</span>.class,</span><br><span class="line">                                      String.class);</span><br><span class="line"><span class="comment">//基本数据类型也可以通过.class得到对应的Class类型</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> con.newInstance(<span class="string">&quot;林青霞&quot;</span>, <span class="number">30</span>, <span class="string">&quot;西安&quot;</span>);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure></li><li><p>案例2 ：通过反射获取<strong>私有构造方法</strong>并创建对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Class对象</span></span><br><span class="line">Class&lt;?&gt; c = Class.forName(<span class="string">&quot;com.itheima_02.Student&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; con = c.getDeclaredConstructor(String.class);</span><br><span class="line">con.setAccessible(<span class="literal">true</span>); <span class="comment">//取消访问检查-暴力反射</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> con.newInstance(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>Class类反射获取：成员方法</strong><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Method[] getMethods()</td><td>返回所有公共成员方法对象的数组，包 括继承的</td></tr><tr><td>Method[] getDeclaredMethods()</td><td>返回所有成员方法对象的数组，不包括 继承的</td></tr><tr><td>Method getMethod(String name, Class… parameterTypes)</td><td>返回单个公共成员方法对象</td></tr><tr><td>Method getDeclaredMethod(String name, Class… parameterTypes)</td><td>返回单个成员方法对象</td></tr><tr><td>invoke(Object obj,Object… args)</td><td>调用obj对象的成员方法，参数是args,返回值是Object类型</td></tr></tbody></table></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Class对象</span></span><br><span class="line">Class&lt;?&gt; c = Class.forName(<span class="string">&quot;com.itheima_02.Student&quot;</span>);</span><br><span class="line"><span class="comment">//Method[] getMethods() 返回一个包含 方法对象的数组， 方法对象反映由该 Class对象表示的类或接口的所有公共方法，包括由类或接口声明的对象以及从超类和超级接口继承的类</span></span><br><span class="line"><span class="comment">//Method[] getDeclaredMethods() 返回一个包含 方法对象的数组， 方法对象反映由Class对象表示的类或接口的所有声明方法，包括public，protected，default（package）访问和私有方法，但不包括继承方法</span></span><br><span class="line">Method[] methods = c.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span>(Method method : methods) </span><br><span class="line">    System.out.println(method);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 返回一个 方法对象，该对象反映由该 Class对象表示的类或接口的指定公共成员方法</span></span><br><span class="line"><span class="comment">//Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) 返回一个方法对象，它反映此表示的类或接口的指定声明的方法 Class对象</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> c.getMethod(<span class="string">&quot;method1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取无参构造方法创建对象</span></span><br><span class="line">Constructor&lt;?&gt; con = c.getConstructor();</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> con.newInstance();</span><br><span class="line"><span class="comment">//Object invoke(Object obj, Object... args) 在具有指定参数的指定对象上调用此方法对象表示的基础方法</span></span><br><span class="line">m.invoke(obj);</span><br></pre></td></tr></table></figure><ul><li>案例1：通过<strong>反射获取成员方法</strong>并调用<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; c = Class.forName(<span class="string">&quot;com.itheima_02.Student&quot;</span>);<span class="comment">//获取Class对象</span></span><br><span class="line">Constructor&lt;?&gt; con = c.getConstructor();</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> con.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//s.method1();</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> c.getMethod(<span class="string">&quot;method1&quot;</span>);</span><br><span class="line">m1.invoke(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">//s.method2();</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m2</span> <span class="operator">=</span> c.getMethod(<span class="string">&quot;method2&quot;</span>, String.class);</span><br><span class="line">m2.invoke(obj,<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//s.method3();</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m3</span> <span class="operator">=</span> c.getMethod(<span class="string">&quot;method3&quot;</span>, String.class, <span class="type">int</span>.class);</span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> m3.invoke(obj, <span class="string">&quot;林青霞&quot;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//s.method4();</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m4</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;function&quot;</span>);</span><br><span class="line">m4.setAccessible(<span class="literal">true</span>);</span><br><span class="line">m4.invoke(obj);</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><strong>Class类反射获取：成员变量</strong><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Field[] getFields()</td><td>返回所有公共成员变量对象的数组</td></tr><tr><td>Field[] getDeclaredFields()</td><td>返回所有成员变量对象的数组</td></tr><tr><td>Field getField(String name)</td><td>返回单个公共成员变量对象</td></tr><tr><td>Field getDeclaredField(String name)</td><td>返回单个成员变量对象</td></tr><tr><td>voidset(Object obj,Object value)</td><td>给obj对象的成员变量赋值为value</td></tr></tbody></table></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Class对象</span></span><br><span class="line">Class&lt;?&gt; c = Class.forName(<span class="string">&quot;com.itheima_02.Student&quot;</span>);</span><br><span class="line"><span class="comment">//Field[] getFields() 返回一个包含 Field对象的数组， Field对象反映由该 Class对象表示的类或接口的所有可访问的公共字段</span></span><br><span class="line"><span class="comment">//Field[] getDeclaredFields() 返回一个 Field对象的数组，反映了由该 Class对象表示的类或接口声明的所有字段</span></span><br><span class="line">Field[] fields = c.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span>(Field field : fields) </span><br><span class="line">    System.out.println(field);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Field getField(String name) 返回一个 Field对象，该对象反映由该 Class对象表示的类或接口的指定公共成员字段</span></span><br><span class="line"><span class="comment">//Field getDeclaredField(String name) 返回一个 Field对象，该对象反映由该Class对象表示的类或接口的指定声明字段</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">addressField</span> <span class="operator">=</span> c.getField(<span class="string">&quot;address&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取无参构造方法创建对象</span></span><br><span class="line">Constructor&lt;?&gt; con = c.getConstructor();</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> con.newInstance();</span><br><span class="line"><span class="comment">//Field提供有关类或接口的单个字段的信息和动态访问</span></span><br><span class="line"><span class="comment">//void set(Object obj, Object value) 将指定的对象参数中由此 Field对象表示的字段设置为指定的新值</span></span><br><span class="line">addressField.set(obj,<span class="string">&quot;西安&quot;</span>); <span class="comment">//给obj的成员变量addressField赋值为西安</span></span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure><ul><li>案例1：通过<strong>反射获取成员变量</strong>并赋值<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Class对象</span></span><br><span class="line">Class&lt;?&gt; c = Class.forName(<span class="string">&quot;com.itheima_02.Student&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; con = c.getConstructor();</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> con.newInstance();</span><br><span class="line">System.out.println(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">//s.name = &quot;林青霞&quot;;</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">nameField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">nameField.set(obj, <span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">System.out.println(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">//s.age = 30;</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">ageField</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">ageField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">ageField.set(obj,<span class="number">30</span>);</span><br><span class="line">System.out.println(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">//s.address = &quot;西安&quot;;</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">addressField</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;address&quot;</span>);</span><br><span class="line">addressField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">addressField.set(obj,<span class="string">&quot;西安&quot;</span>);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-3-反射案例"><a href="#6-3-反射案例" class="headerlink" title="6.3 反射案例"></a>6.3 反射案例</h2><p><strong>案例1-越过泛型检查：</strong>通过反射技术，向一个泛型为Integer的集合中添加一些字符串数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建集合</span></span><br><span class="line">ArrayList&lt;Integer&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// array.add(10);</span></span><br><span class="line"><span class="comment">// array.add(20);</span></span><br><span class="line"><span class="comment">// array.add(&quot;hello&quot;);</span></span><br><span class="line"></span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">ArrayList</span>&gt; c = array.getClass();</span><br><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> c.getMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">m.invoke(array,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">m.invoke(array,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">m.invoke(array,<span class="string">&quot;java&quot;</span>);</span><br><span class="line">System.out.println(array);</span><br></pre></td></tr></table></figure><p><strong>案例2：</strong>通过反射运行配置文件中指定类的指定方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载数据</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;myReflect\\class.txt&quot;</span>);</span><br><span class="line">prop.load(fr);</span><br><span class="line">fr.close();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">className=com.itheima_06.Student</span></span><br><span class="line"><span class="comment">methodName=study</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> prop.getProperty(<span class="string">&quot;className&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> prop.getProperty(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line"><span class="comment">//通过反射来使用</span></span><br><span class="line">Class&lt;?&gt; c = Class.forName(className);<span class="comment">//com.itheima_06.Student</span></span><br><span class="line">Constructor&lt;?&gt; con = c.getConstructor();</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> con.newInstance();</span><br><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> c.getMethod(methodName);<span class="comment">//study</span></span><br><span class="line">m.invoke(obj);</span><br></pre></td></tr></table></figure><h1 id="7、类加载器-⭐-o"><a href="#7、类加载器-⭐-o" class="headerlink" title="7、类加载器 ⭐ o"></a>7、类加载器 ⭐ o</h1><ol><li>Bootstrap ClassLoader（启动类加载器）：负责加载Java核心类库，比如rt.jar等。它是用C++实现的，并不继承自java.lang.ClassLoader。</li><li>Extension ClassLoader（扩展类加载器）：负责加载Java的扩展类库，主要加载jre&#x2F;lib&#x2F;ext或者被java.ext.dirs系统属性指定的目录中的类。</li><li>System ClassLoader（系统类加载器）：也称为应用程序类加载器，负责加载应用程序classpath下的类。</li></ol><p>这些内置类加载器按照父子关系组成了一个层次结构，ClassLoader通过委托机制来寻找并加载类。当一个类加载器收到加载请求时，它首先会尝试使用自己的类路径加载类，只有当找不到类时，它才会将加载请求委托给其父类加载器。<br>除了这些内置的类加载器，Java还提供了自定义类加载器的机制，可以通过继承java.lang.ClassLoader类来实现自定义的类加载器，并且可以通过调用ClassLoader的相关方法来加载、链接和实例化类。</p><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p>类加载概念：当需要使用某个类时，虚拟机将会加载它的”.class”文件，并创建对应的java.lang.Class对象，将class文件加载到虚拟机的内存<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697186662026-fced95e0-0035-4d46-9450-96a2d164aa7a.png#averageHue=%23f3f1f1&clientId=ufb8daf59-3664-4&from=drop&id=u7a168024&originHeight=317&originWidth=700&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=111731&status=done&style=none&taskId=ucfd2c7e5-85d9-447e-8196-a21171a835f&title=" alt="20170430160610299.png"></p><ul><li>类加载的描述 <ul><li>当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过类的加载，类的连接，类的初始 化这三个步骤来对类进行初始化。如果不出现意外情况，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载或者类初始化</li></ul></li><li>类的加载</li><li>就是指将class文件读入内存，并为之创建一个 java.lang.Class 对象</li><li>任何类被使用时，系统都会为之建立一个 java.lang.Class 对象</li><li>类的连接 <ul><li><strong>验证阶段</strong>：用于检验被加载的类是否有正确的内部结构，并和其他类协调一致</li><li><strong>准备阶段</strong>：负责为类的类变量分配内存，并设置默认初始化值</li><li><strong>解析阶段</strong>：将类的二进制数据中的符号引用替换为直接引用</li></ul></li><li>类的初始化 <ul><li>在该阶段，主要就是对类变量进行初始化</li></ul></li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><blockquote><p>1、类加载器的作用</p></blockquote><ul><li>负责将.class文件加载到内存中，并为之生成对应的 java.lang.Class 对象。</li></ul><blockquote><p>2、JVM的类加载机制</p></blockquote><ul><li>全盘负责：就是当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li><li>父类委托：就是当一个类加载器负责加载某个Class时，先让父类加载器试图加载该Class，只有在父类加载器 无法加载该类时才尝试从自己的类路径中加载该类</li><li>缓存机制：保证所有加载过的Class都会被缓存，当程序需要使用某个Class对象时，类加载器先从缓存区中搜索该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存储到缓存区</li></ul><blockquote><p>3、Java中的内置类加载器</p></blockquote><ul><li><strong>Bootstrap class loader</strong>：它是虚拟机的内置类加载器，通常表示为null ，并且没有父null</li><li><strong>Platform class loader</strong>：平台类加载器可以看到所有平台类 ，平台类包括由平台类加载器或其祖先定义的Java SE平台API，其实现类和JDK特定的运行时类</li><li><strong>System class loader</strong>：它也被称为应用程序类加载器 ，与平台类加载器不同。 系统类加载器通常用于定义应 用程序类路径，模块路径和JDK特定工具上的类</li><li>类加载器的继承关系：System的父加载器为Platform，而Platform的父加载器为Bootstrap</li></ul><blockquote><p>4、ClassLoader 中的两个方法</p></blockquote><ul><li>方法分类<table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>static ClassLoader getSystemClassLoader()</td><td>返回用于委派的系统类加载器</td></tr><tr><td>ClassLoader getParent()</td><td>返回父类加载器进行委派</td></tr></tbody></table></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//static ClassLoader getSystemClassLoader()：返回用于委派的系统类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">c</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(c); <span class="comment">//AppClassLoader</span></span><br><span class="line">        <span class="comment">//ClassLoader getParent()：返回父类加载器进行委派</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">c2</span> <span class="operator">=</span> c.getParent();</span><br><span class="line">        System.out.println(c2); <span class="comment">//PlatformClassLoader</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">c3</span> <span class="operator">=</span> c2.getParent();</span><br><span class="line">        System.out.println(c3); <span class="comment">//null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Lambda表达式-o"><a href="#Lambda表达式-o" class="headerlink" title="Lambda表达式 o"></a>Lambda表达式 o</h1><blockquote><p>1、体验Lambda表达式</p></blockquote><ul><li><p>案例需求<br>启动一个线程，在控制台输出一句话：多线程程序启动了 </p></li><li><p>实现方式一 </p><ul><li>实现步骤 <ul><li>定义一个类MyRunnable实现Runnable接口，重写run()方法</li><li>创建MyRunnable类的对象</li><li>创建Thread类的对象，把MyRunnable的对象作为构造参数传递</li><li>启动线程</li></ul></li></ul></li><li><p>实现方式二 </p><ul><li>匿名内部类的方式改进</li></ul></li><li><p>实现方式三 </p><ul><li>Lambda表达式的方式改进<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一的线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;多线程程序启动了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//方式一</span></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">my</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(my);</span><br><span class="line">        t.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方式二</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;多线程程序启动了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方式三</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>( () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;多线程程序启动了&quot;</span>);</span><br><span class="line">        &#125; ).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>函数式编程思想概述<br>函数式思想则尽量忽略面向对象的复杂语法：“强调做什么，而不是以什么形式去做”<br>而我们要学习的Lambda表达式就是函数式思想的体现</p></li></ul><blockquote><p>2、Lambda表达式的标准格式</p></blockquote><ul><li>格式：<br><strong>(形式参数) -&gt; {代码块}</strong> <ul><li>形式参数：如果有多个参数，参数之间用逗号隔开；如果没有参数，留空即可</li><li>-&gt;：由英文中画线和大于符号组成，固定写法。代表指向动作</li><li>代码块：是我们具体要做的事情，也就是以前我们写的方法体内容</li></ul></li><li>组成Lambda表达式的三要素： <ul><li>形式参数，箭头，代码块</li></ul></li></ul><h2 id="Lambda练习"><a href="#Lambda练习" class="headerlink" title="Lambda练习"></a>Lambda练习</h2><ol><li>Lambda练习1</li></ol><ul><li>Lambda表达式的使用前提 <ul><li>有一个接口</li><li>接口中有且仅有一个抽象方法</li></ul></li><li>练习描述<br>无参无返回值抽象方法的练习 </li><li>操作步骤 <ul><li>定义一个接口(Eatable)，里面定义一个抽象方法：void eat();</li><li>定义一个测试类(EatableDemo)，在测试类中提供两个方法 <ul><li>一个方法是：useEatable(Eatable e)</li><li>一个方法是主方法，在主方法中调用useEatable方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Eatable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EatableImpl</span> <span class="keyword">implements</span> <span class="title class_">Eatable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;一天一苹果，医生远离我&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EatableDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//在主方法中调用useEatable方法</span></span><br><span class="line">        <span class="type">Eatable</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EatableImpl</span>();</span><br><span class="line">        useEatable(e);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//匿名内部类</span></span><br><span class="line">        useEatable(<span class="keyword">new</span> <span class="title class_">Eatable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;一天一苹果，医生远离我&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Lambda表达式</span></span><br><span class="line">        useEatable(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;一天一苹果，医生远离我&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">useEatable</span><span class="params">(Eatable e)</span> &#123;</span><br><span class="line">        e.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ol start="2"><li>Lambda练习2</li></ol><ul><li>练习描述<br>有参无返回值抽象方法的练习 </li><li>操作步骤 <ul><li>定义一个接口(Flyable)，里面定义一个抽象方法：void fly(String s);</li><li>定义一个测试类(FlyableDemo)，在测试类中提供两个方法 <ul><li>一个方法是：useFlyable(Flyable f)</li><li>一个方法是主方法，在主方法中调用useFlyable方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匿名内部类</span></span><br><span class="line">useFlyable(<span class="keyword">new</span> <span class="title class_">Flyable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        System.out.println(<span class="string">&quot;飞机自驾游&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lambda</span></span><br><span class="line">useFlyable((String s) -&gt; &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    System.out.println(<span class="string">&quot;飞机自驾游&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ol start="3"><li>Lambda练习3</li></ol><ul><li>练习描述<br>有参有返回值抽象方法的练习 </li><li>操作步骤 <ul><li>定义一个接口(Addable)，里面定义一个抽象方法：int add(int x,int y);</li><li>定义一个测试类(AddableDemo)，在测试类中提供两个方法 <ul><li>一个方法是：useAddable(Addable a)</li><li>一个方法是主方法，在主方法中调用useAddable方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Addable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddableDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//在主方法中调用useAddable方法</span></span><br><span class="line">        useAddable((<span class="type">int</span> x,<span class="type">int</span> y) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">useAddable</span><span class="params">(Addable a)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a.add(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="省略模式和注意事项"><a href="#省略模式和注意事项" class="headerlink" title="省略模式和注意事项"></a>省略模式和注意事项</h2><ol><li>省略模式</li></ol><ul><li>省略的规则 <ul><li>参数类型可以省略。但是有多个参数的情况下，不能只省略一个</li><li>如果参数有且仅有一个，那么小括号可以省略</li><li>如果代码块的语句只有一条，可以省略大括号和分号，和return关键字<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Addable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">(String s)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// useAddable((int x,int y) -&gt; &#123;</span></span><br><span class="line">        <span class="comment">// return x + y;</span></span><br><span class="line">        <span class="comment">// &#125;);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//参数的类型可以省略</span></span><br><span class="line">        useAddable((x, y) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;);</span><br><span class="line">     </span><br><span class="line">        <span class="comment">// useFlyable((String s) -&gt; &#123;</span></span><br><span class="line">        <span class="comment">// System.out.println(s);</span></span><br><span class="line">        <span class="comment">// &#125;);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果参数有且仅有一个，那么小括号可以省略</span></span><br><span class="line">        <span class="comment">// useFlyable(s -&gt; &#123;</span></span><br><span class="line">        <span class="comment">// System.out.println(s);</span></span><br><span class="line">        <span class="comment">// &#125;);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果代码块的语句只有一条，可以省略大括号和分号</span></span><br><span class="line">        useFlyable(s -&gt; System.out.println(s));</span><br><span class="line">        <span class="comment">//如果代码块的语句只有一条，可以省略大括号和分号，如果有return，return也要省略掉</span></span><br><span class="line">        useAddable((x, y) -&gt; x + y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">useFlyable</span><span class="params">(Flyable f)</span> &#123;</span><br><span class="line">        f.fly(<span class="string">&quot;风和日丽，晴空万里&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">useAddable</span><span class="params">(Addable a)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a.add(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ol start="2"><li>注意事项</li></ol><ul><li>使用Lambda必须要有接口，并且要求接口中有且仅有一个抽象方法 </li><li>必须有上下文环境，才能推导出Lambda对应的接口 <ul><li>根据局部变量的赋值得知Lambda对应的接口<br>Runnable r &#x3D; () -&gt; System.out.println(“Lambda表达式”); </li><li>根据调用方法的参数得知Lambda对应的接口<br>new Thread(() -&gt; System.out.println(“Lambda表达式”)).start();</li></ul></li></ul><blockquote><p>Lambda表达式和匿名内部类的区别</p></blockquote><ul><li>所需类型不同 <ul><li>匿名内部类：可以是接口，也可以是抽象类，还可以是具体类</li><li>Lambda表达式：只能是接口</li></ul></li><li>使用限制不同 <ul><li>如果接口中有且仅有一个抽象方法，可以使用Lambda表达式，也可以使用匿名内部类</li><li>如果接口中多于一个抽象方法，只能使用匿名内部类，而不能使用Lambda表达式</li></ul></li><li>实现原理不同 <ul><li>匿名内部类：编译之后，产生一个单独的.class字节码文件</li><li>Lambda表达式：编译之后，没有一个单独的.class字节码文件。对应的字节码会在运行的时候动态生成</li></ul></li></ul><h1 id="方法引用-o"><a href="#方法引用-o" class="headerlink" title="方法引用 o"></a>方法引用 o</h1><blockquote><p>1、概述</p></blockquote><ul><li>方法引用的出现原因<br>在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿参数做操作<br>那么考虑一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑呢？答案肯定是没有必要<br>那我们又是如何使用已经存在的方案的呢？<br>这就是我们要讲解的方法引用，我们是通过方法引用来使用已经存在的方案 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Printable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printString</span><span class="params">(String s)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintableDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//在主方法中调用usePrintable方法</span></span><br><span class="line">        <span class="comment">// usePrintable((String s) -&gt; &#123;</span></span><br><span class="line">        <span class="comment">// System.out.println(s);</span></span><br><span class="line">        <span class="comment">// &#125;);</span></span><br><span class="line">        <span class="comment">//Lambda简化写法</span></span><br><span class="line">        usePrintable(s -&gt; System.out.println(s));</span><br><span class="line">        <span class="comment">//方法引用</span></span><br><span class="line">        usePrintable(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">usePrintable</span><span class="params">(Printable p)</span> &#123;</span><br><span class="line">        p.printString(<span class="string">&quot;爱生活爱Java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>2、方法引用符</p></blockquote><ul><li>方法引用符<br><strong>::</strong> 该符号为引用运算符，而它所在的表达式被称为方法引用 </li><li>推导与省略 <ul><li>如果使用Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式， 它们都将被自动推导</li><li>如果使用方法引用，也是同样可以根据上下文进行推导</li><li>方法引用是Lambda的孪生兄弟</li></ul></li></ul><h2 id="引用类方法"><a href="#引用类方法" class="headerlink" title="引用类方法"></a>引用类方法</h2><p>引用类方法，其实就是引用类的静态方法</p><ul><li><p>格式<br>类名::静态方法 </p></li><li><p>范例<br>Integer::parseInt<br>Integer类的方法：public static int parseInt(String s) 将此String转换为int类型数据 </p></li><li><p>练习描述 </p><ul><li>定义一个接口(Converter)，里面定义一个抽象方法 int convert(String s);</li><li>定义一个测试类(ConverterDemo)，在测试类中提供两个方法 <ul><li>一个方法是：useConverter(Converter c) 、</li><li>一个方法是主方法，在主方法中调用useConverter方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Converter</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">convert</span><span class="params">(String s)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConverterDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//Lambda写法</span></span><br><span class="line">        useConverter(s -&gt; Integer.parseInt(s));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//引用类方法</span></span><br><span class="line">        useConverter(Integer::parseInt);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">useConverter</span><span class="params">(Converter c)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> c.convert(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">        System.out.println(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>使用说明<br>Lambda表达式被类方法替代的时候，它的形式参数全部传递给静态方法作为参数</p></li></ul><h2 id="引用对象的实例方法"><a href="#引用对象的实例方法" class="headerlink" title="引用对象的实例方法"></a>引用对象的实例方法</h2><p>引用对象的实例方法，其实就引用类中的成员方法</p><ul><li>格式<br>对象::成员方法 </li><li>范例<br>“HelloWorld”::toUpperCase<br>String类中的方法：public String toUpperCase() 将此String所有字符转换为大写 </li><li>练习描述 <ul><li>定义一个类(PrintString)，里面定义一个方法 </li><li>public void printUpper(String s)：把字符串参数变成大写的数据，然后在控制台输出 </li><li>定义一个接口(Printer)，里面定义一个抽象方法<br>void printUpperCase(String s) </li><li>定义一个测试类(PrinterDemo)，在测试类中提供两个方法 <ul><li>一个方法是：usePrinter(Printer p)</li><li>一个方法是主方法，在主方法中调用usePrinter方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintString</span> &#123;</span><br><span class="line">    <span class="comment">//把字符串参数变成大写的数据，然后在控制台输出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printUpper</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> s.toUpperCase();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printUpperCase</span><span class="params">(String s)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrinterDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//Lambda简化写法</span></span><br><span class="line">        usePrinter(s -&gt; System.out.println(s.toUpperCase()));</span><br><span class="line">        <span class="comment">//引用对象的实例方法</span></span><br><span class="line">        <span class="type">PrintString</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintString</span>();</span><br><span class="line">        usePrinter(ps::printUpper);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">usePrinter</span><span class="params">(Printer p)</span> &#123;</span><br><span class="line">        p.printUpperCase(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="引用类的实例方法"><a href="#引用类的实例方法" class="headerlink" title="引用类的实例方法"></a>引用类的实例方法</h2><p>引用类的实例方法，其实就是引用类中的成员方法</p><ul><li><p>格式<br>类名::成员方法 </p></li><li><p>范例<br>String::substring<br>public String substring(int beginIndex,int endIndex)<br>从beginIndex开始到endIndex结束，截取字符串。返回一个子串，子串的长度为endIndex-beginIndex </p></li><li><p>练习描述 </p><ul><li>定义一个接口(MyString)，里面定义一个抽象方法：<br>String mySubString(String s,int x,int y); </li><li>定义一个测试类(MyStringDemo)，在测试类中提供两个方法 <ul><li>一个方法是：useMyString(MyString my)</li><li>一个方法是主方法，在主方法中调用useMyString方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line">    String <span class="title function_">mySubString</span><span class="params">(String s,<span class="type">int</span> x,<span class="type">int</span> y)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStringDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//Lambda简化写法</span></span><br><span class="line">        useMyString((s,x,y) -&gt; s.substring(x,y));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//引用类的实例方法</span></span><br><span class="line">        useMyString(String::substring);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">useMyString</span><span class="params">(MyString my)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> my.mySubString(<span class="string">&quot;HelloWorld&quot;</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>使用说明<br>Lambda表达式被类的实例方法替代的时候 第一个参数作为调用者 后面的参数全部传递给该方法作为参数</p></li></ul><h2 id="引用构造器"><a href="#引用构造器" class="headerlink" title="引用构造器"></a>引用构造器</h2><p>引用构造器，其实就是引用构造方法</p><ul><li><p>l格式<br>类名::new </p></li><li><p>范例<br>Student::new </p></li><li><p>练习描述 </p><ul><li>定义一个<strong>类</strong>(Student)，里面有两个成员变量(name,age)<br>并提供无参构造方法和带参构造方法，以及成员变量对应的get和set方法 </li><li>定义一个<strong>接口</strong>(StudentBuilder)，里面定义一个抽象方法<br>Student build(String name,int age); </li><li>定义一个<strong>测试类</strong>(StudentDemo)，在测试类中提供两个方法 <ul><li>一个方法是：useStudentBuilder(StudentBuilder s)</li><li>一个方法是主方法，在主方法中调用useStudentBuilder方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentBuilder</span> &#123;</span><br><span class="line">    Student <span class="title function_">build</span><span class="params">(String name,<span class="type">int</span> age)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//Lambda简化写法</span></span><br><span class="line">        useStudentBuilder((name,age) -&gt; <span class="keyword">new</span> <span class="title class_">Student</span>(name,age));</span><br><span class="line">        <span class="comment">//引用构造器</span></span><br><span class="line">        useStudentBuilder(Student::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">useStudentBuilder</span><span class="params">(StudentBuilder sb)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> sb.build(<span class="string">&quot;林青霞&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        System.out.println(s.getName() + <span class="string">&quot;,&quot;</span> + s.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>使用说明<br>Lambda表达式被构造器替代的时候，它的形式参数全部传递给构造器作为参数</p></li></ul><h1 id="函数式接口-o"><a href="#函数式接口-o" class="headerlink" title="函数式接口 o"></a>函数式接口 o</h1><p>Java 函数式接口是在 java.util.function 包下定义的，用于支持函数式编程的特性。它提供了一系列的函数式接口，用于便捷地使用Lambda表达式和方法引用。<br>:::tips</p><ul><li>Consumer<T>：接受一个输入参数并且不返回结果的操作。</li><li>Supplier<T>：提供一个结果的供应商。</li><li>Function&lt;T, R&gt;：将一个类型的值转换为另一个类型的值。</li><li>Predicate<T>：对一个输入参数进行判断，并返回一个布尔值。<br>:::</li></ul><blockquote><p>1、概述</p></blockquote><ul><li>概念<br>有且仅有一个抽象方法的接口 </li><li>如何检测一个接口是不是函数式接口<br><a href="/FunctionalInterface">@FunctionalInterface </a><br>放在接口定义的上方：如果接口是函数式接口，编译通过；如果不是，编译失败 </li><li>注意事项 我们自己定义函数式接口的时候，@FunctionalInterface是可选的，就算我不写这个注解，只要保证满足函数式接口定义的条件，也照样是函数式接口。但是，建议加上该注解</li></ul><blockquote><p>2、函数式接口作为方法的参数</p></blockquote><ul><li>需求描述<br>定义一个类(RunnableDemo)，在类中提供两个方法<br>一个方法是：startThread(Runnable r) 方法参数Runnable是一个函数式接口<br>一个方法是主方法，在主方法中调用startThread方法 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//在主方法中调用startThread方法</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//匿名内部类的方式</span></span><br><span class="line">        startThread(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程启动了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Lambda方式</span></span><br><span class="line">        startThread(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程启动了&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">startThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>3、函数式接口作为方法的返回值</p></blockquote><ul><li><p>需求描述<br>定义一个类(ComparatorDemo)，在类中提供两个方法<br>一个方法是：Comparator getComparator() 方法返回值Comparator是一个函数式接口<br>一个方法是主方法，在主方法中调用getComparator方法 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComparatorDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义集合，存储字符串元素</span></span><br><span class="line">        ArrayList&lt;String&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        array.add(<span class="string">&quot;cccc&quot;</span>);</span><br><span class="line">        array.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        array.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        array.add(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前：&quot;</span> + array);</span><br><span class="line">        Collections.sort(array, getComparator());</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后：&quot;</span> + array);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparator&lt;String&gt; <span class="title function_">getComparator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//匿名内部类的方式实现</span></span><br><span class="line">        <span class="comment">// return new Comparator&lt;String&gt;() &#123;</span></span><br><span class="line">        <span class="comment">// @Override</span></span><br><span class="line">        <span class="comment">// public int compare(String s1, String s2) &#123;</span></span><br><span class="line">        <span class="comment">// return s1.length()-s2.length();</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// &#125;;</span></span><br><span class="line">        <span class="comment">//Lambda方式实现</span></span><br><span class="line">        <span class="keyword">return</span> (s1, s2) -&gt; s1.length() - s2.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以下是常用的函数式接口</p></li></ul><h2 id="Supplier接口"><a href="#Supplier接口" class="headerlink" title="Supplier接口"></a>Supplier接口</h2><ul><li>Supplier接口<br>Supplier接口也被称为<strong>生产型接口</strong>，如果我们指定了接口的泛型是什么类型，那么接口中的get方法就会生产 什么类型的数据供我们使用。 </li><li>常用方法<br>只有一个无参的方法 <table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>T get()</td><td>按照某种实现逻辑(由Lambda表达式实现)返回一个数据</td></tr></tbody></table></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SupplierDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> getString(() -&gt; <span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> getInteger(() -&gt; <span class="number">30</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一个方法，返回一个整数数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer <span class="title function_">getInteger</span><span class="params">(Supplier&lt;Integer&gt; sup)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sup.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一个方法，返回一个字符串数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getString</span><span class="params">(Supplier&lt;String&gt; sup)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sup.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Supplier接口练习之获取最大值</p></blockquote><ul><li>案例需求<br>定义一个类(SupplierTest)，在类中提供两个方法<br>一个方法是：int getMax(Supplier sup) 用于返回一个int数组中的最大值<br>一个方法是主方法，在主方法中调用getMax方法 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SupplierTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个int数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">19</span>, <span class="number">50</span>, <span class="number">28</span>, <span class="number">37</span>, <span class="number">46</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> getMax(()-&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] &gt; max) &#123;</span><br><span class="line">                    max = arr[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(maxValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回一个int数组中的最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(Supplier&lt;Integer&gt; sup)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sup.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Consumer接口"><a href="#Consumer接口" class="headerlink" title="Consumer接口"></a>Consumer接口</h2><ul><li>Consumer接口<br>Consumer接口也被称为<strong>消费型接口</strong>，它消费的数据的数据类型由泛型指定 </li><li>常用方法<br>Consumer：包含两个方法 <table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void accept(T t)</td><td>对给定的参数执行此操作</td></tr><tr><td>default Consumer andThen(Consumer after)</td><td>返回一个组合的Consumer，依次执行此操作，然后执行after操作</td></tr></tbody></table></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//操作一</span></span><br><span class="line">        operatorString(<span class="string">&quot;林青霞&quot;</span>, s -&gt; System.out.println(s));</span><br><span class="line">        <span class="comment">//操作二</span></span><br><span class="line">        operatorString(<span class="string">&quot;林青霞&quot;</span>, s -&gt; System.out.println(<span class="keyword">new</span></span><br><span class="line">                                                      <span class="title class_">StringBuilder</span>(s).reverse().toString()));</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">        <span class="comment">//传入两个操作使用andThen完成</span></span><br><span class="line">        operatorString(<span class="string">&quot;林青霞&quot;</span>, s -&gt; System.out.println(s), s -&gt;</span><br><span class="line">                       System.out.println(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s).reverse().toString()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义一个方法，用不同的方式消费同一个字符串数据两次</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">operatorString</span><span class="params">(String name, Consumer&lt;String&gt; con1,</span></span><br><span class="line"><span class="params">                                       Consumer&lt;String&gt; con2)</span> &#123;</span><br><span class="line">        <span class="comment">// con1.accept(name);</span></span><br><span class="line">        <span class="comment">// con2.accept(name);</span></span><br><span class="line">        con1.andThen(con2).accept(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义一个方法，消费一个字符串数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">operatorString</span><span class="params">(String name, Consumer&lt;String&gt; con)</span> &#123;</span><br><span class="line">        con.accept(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Consumer接口练习之按要求打印信息</p></blockquote><ul><li>案例需求<br>String[] strArray &#x3D; {“林青霞,30”, “张曼玉,35”, “王祖贤,33”};<br>字符串数组中有多条信息，请按照格式：“姓名：XX,年龄：XX”的格式将信息打印出来 </li><li>要求： <ul><li>把打印姓名的动作作为第一个Consumer接口的Lambda实例</li><li>把打印年龄的动作作为第二个Consumer接口的Lambda实例</li><li>将两个Consumer接口按照顺序组合到一起使用<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] strArray = &#123;<span class="string">&quot;林青霞,30&quot;</span>, <span class="string">&quot;张曼玉,35&quot;</span>, <span class="string">&quot;王祖贤,33&quot;</span>&#125;;</span><br><span class="line">        printInfo(strArray, str -&gt; System.out.print(<span class="string">&quot;姓名：&quot;</span> + str.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>]),</span><br><span class="line">                  str -&gt; System.out.println(<span class="string">&quot;,年龄：&quot;</span> +</span><br><span class="line">                                            Integer.parseInt(str.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>])));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printInfo</span><span class="params">(String[] strArray, Consumer&lt;String&gt; con1,</span></span><br><span class="line"><span class="params">                                  Consumer&lt;String&gt; con2)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String str : strArray) &#123;</span><br><span class="line">            con1.andThen(con2).accept(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Predicate接口"><a href="#Predicate接口" class="headerlink" title="Predicate接口"></a>Predicate接口</h2><ul><li>Predicate接口<br>Predicate接口通常用于判断参数是否满足指定的条件 </li><li>常用方法 <table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>boolean test(T t)</td><td>对给定的参数进行判断(判断逻辑由Lambda表达式实现)，返回 一个布尔值</td></tr><tr><td>default Predicate negate()</td><td>返回一个逻辑的否定，对应逻辑非</td></tr><tr><td>default Predicate and(Predicate other)</td><td>返回一个组合判断，对应短路与</td></tr><tr><td>default Predicate or(Predicate other)</td><td>返回一个组合判断，对应短路或</td></tr></tbody></table></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PredicateDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> checkString(<span class="string">&quot;hello&quot;</span>, s -&gt; s.length() &gt; <span class="number">8</span>);</span><br><span class="line">        System.out.println(b1);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> checkString(<span class="string">&quot;helloworld&quot;</span>,s -&gt; s.length() &gt; <span class="number">8</span>);</span><br><span class="line">        System.out.println(b2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断给定的字符串是否满足要求</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkString</span><span class="params">(String s, Predicate&lt;String&gt; pre)</span> &#123;</span><br><span class="line">        <span class="comment">// return !pre.test(s);</span></span><br><span class="line">        <span class="keyword">return</span> pre.negate().test(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PredicateDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> checkString(<span class="string">&quot;hello&quot;</span>, s -&gt; s.length() &gt; <span class="number">8</span>);</span><br><span class="line">        System.out.println(b1);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> checkString(<span class="string">&quot;helloworld&quot;</span>, s -&gt; s.length() &gt; <span class="number">8</span>);</span><br><span class="line">        System.out.println(b2);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b3</span> <span class="operator">=</span> checkString(<span class="string">&quot;hello&quot;</span>,s -&gt; s.length() &gt; <span class="number">8</span>, s -&gt; s.length() &lt;</span><br><span class="line">                                 <span class="number">15</span>);</span><br><span class="line">        System.out.println(b3);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b4</span> <span class="operator">=</span> checkString(<span class="string">&quot;helloworld&quot;</span>,s -&gt; s.length() &gt; <span class="number">8</span>, s -&gt; s.length()</span><br><span class="line">                                 &lt; <span class="number">15</span>);</span><br><span class="line">        System.out.println(b4);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同一个字符串给出两个不同的判断条件，最后把这两个判断的结果做逻辑与运算的结果作为最终的结果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkString</span><span class="params">(String s, Predicate&lt;String&gt; pre1,</span></span><br><span class="line"><span class="params">                                       Predicate&lt;String&gt; pre2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pre1.or(pre2).test(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断给定的字符串是否满足要求</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkString</span><span class="params">(String s, Predicate&lt;String&gt; pre)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pre.test(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Predicate接口练习之筛选满足条件数据</p></blockquote><ul><li>练习描述 <ul><li>String[] strArray &#x3D; {“林青霞,30”, “柳岩,34”, “张曼玉,35”, “貂蝉,31”, “王祖贤,33”};</li><li>字符串数组中有多条信息，请通过Predicate接口的拼装将符合要求的字符串筛选到集合ArrayList中，并遍历ArrayList集合</li><li>同时满足如下要求：姓名长度大于2；年龄大于33</li></ul></li><li>分析 <ul><li>有两个判断条件,所以需要使用两个Predicate接口,对条件进行判断</li><li>必须同时满足两个条件,所以可以使用and方法连接两个判断条件<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PredicateTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] strArray = &#123;<span class="string">&quot;林青霞,30&quot;</span>, <span class="string">&quot;柳岩,34&quot;</span>, <span class="string">&quot;张曼玉,35&quot;</span>, <span class="string">&quot;貂蝉,31&quot;</span>, <span class="string">&quot;王祖贤,33&quot;</span>&#125;;</span><br><span class="line">        ArrayList&lt;String&gt; array = myFilter(strArray, s -&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>].length()&gt;<span class="number">2</span>,s -&gt; Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]) &gt; <span class="number">33</span>);</span><br><span class="line">        <span class="keyword">for</span> (String str : array) &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过Predicate接口的拼装将符合要求的字符串筛选到集合ArrayList中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title function_">myFilter</span><span class="params">(String[] strArray, Predicate&lt;String&gt; pre1, Predicate&lt;String&gt; pre2)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个集合</span></span><br><span class="line">        ArrayList&lt;String&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (String str : strArray) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre1.and(pre2).test(str)) &#123;</span><br><span class="line">                array.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Function接口"><a href="#Function接口" class="headerlink" title="Function接口"></a>Function接口</h2><ul><li>Function接口<br>Function接口通常用于对参数进行处理，转换(处理逻辑由Lambda表达式实现)，然后返回一个新的值 </li><li>常用方法 <table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>R apply(T t)</td><td>将此函数应用于给定的参数</td></tr><tr><td>default Function andThen(Function after)</td><td>返回一个组合函数，首先将该函数应用于输入，然后将after函数应用于结果</td></tr></tbody></table></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//操作一</span></span><br><span class="line">        convert(<span class="string">&quot;100&quot;</span>,s -&gt; Integer.parseInt(s));</span><br><span class="line">        <span class="comment">//操作二</span></span><br><span class="line">        convert(<span class="number">100</span>,i -&gt; String.valueOf(i + <span class="number">566</span>));</span><br><span class="line">        <span class="comment">//使用andThen的方式连续执行两个操作</span></span><br><span class="line">        convert(<span class="string">&quot;100&quot;</span>, s -&gt; Integer.parseInt(s), i -&gt; String.valueOf(i + <span class="number">566</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一个方法，把一个字符串转换int类型，在控制台输出</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">convert</span><span class="params">(String s, Function&lt;String,Integer&gt; fun)</span> &#123;</span><br><span class="line">        <span class="comment">// Integer i = fun.apply(s);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> fun.apply(s);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一个方法，把一个int类型的数据加上一个整数之后，转为字符串在控制台输出</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">convert</span><span class="params">(<span class="type">int</span> i, Function&lt;Integer,String&gt; fun)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> fun.apply(i);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一个方法，把一个字符串转换int类型，把int类型的数据加上一个整数之后，转为字符串在控制台输出</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">convert</span><span class="params">(String s, Function&lt;String,Integer&gt; fun1,</span></span><br><span class="line"><span class="params">                                Function&lt;Integer,String&gt; fun2)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ss</span> <span class="operator">=</span> fun1.andThen(fun2).apply(s);</span><br><span class="line">        System.out.println(ss);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Function接口练习之按照指定要求操作数据</p></blockquote><ul><li>练习描述 <ul><li>String s &#x3D; “林青霞,30”; </li><li>请按照我指定的要求进行操作：<br>1:将字符串截取得到数字年龄部分<br>2:将上一步的年龄字符串转换成为int类型的数据<br>3:将上一步的int数据加70，得到一个int结果，在控制台输出 </li><li>请通过Function接口来实现函数拼接 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;林青霞,30&quot;</span>;</span><br><span class="line">        convert(s, ss -&gt; ss.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>], Integer::parseInt, i -&gt; i + <span class="number">70</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">convert</span><span class="params">(String s, Function&lt;String, String&gt; fun1,</span></span><br><span class="line"><span class="params">                                Function&lt;String, Integer&gt; fun2, Function&lt;Integer, Integer&gt; fun3)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> fun1.andThen(fun2).andThen(fun3).apply(s);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="Stream流-o"><a href="#Stream流-o" class="headerlink" title="Stream流 o"></a>Stream流 o</h1><p>:::tips</p><ul><li><p>现在有两个ArrayList集合，分别存储6名男演员名称和6名女演员名称，要求完成如下的操作 </p><ul><li>男演员只要名字为3个字的前三人</li><li>女演员只要姓林的，并且不要第一个</li><li>把过滤后的男演员姓名和女演员姓名合并到一起</li><li>把上一步操作后的元素作为构造方法的参数创建演员对象,遍历数据<br> :::<br> 演员类Actor已经提供，里面有一个成员变量，一个带参构造方法，以及成员变量对应的get&#x2F;set方法 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建集合</span></span><br><span class="line">ArrayList&lt;String&gt; manList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">manList.add(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">ArrayList&lt;String&gt; womanList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">womanList.add(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"></span><br><span class="line">Stream.concat(manList.stream()</span><br><span class="line">                  .filter(s -&gt; s.length() == <span class="number">3</span>)</span><br><span class="line">                  .limit(<span class="number">3</span>),</span><br><span class="line">              womanList.stream()</span><br><span class="line">                  .filter(s -&gt; s.startsWith(<span class="string">&quot;林&quot;</span>)).skip(<span class="number">1</span>))</span><br><span class="line">                  .map(Actor::<span class="keyword">new</span>)</span><br><span class="line">                  .forEach(p -&gt; System.out.println(p.getName()));</span><br></pre></td></tr></table></figure></li></ul></li><li><p>案例需求<br>按照下面的要求完成集合的创建和遍历 </p><ul><li>创建一个集合，存储多个字符串元素</li><li>把集合中所有以”张”开头的元素存储到一个新的集合</li><li>把”张”开头的集合中的长度为3的元素存储到一个新的集合</li><li>遍历上一步得到的集合<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个集合，存储多个字符串元素</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张曼玉&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;王祖贤&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;柳岩&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张敏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//把集合中所有以&quot;张&quot;开头的元素存储到一个新的集合</span></span><br><span class="line">        ArrayList&lt;String&gt; zhangList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s : list) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.startsWith(<span class="string">&quot;张&quot;</span>)) &#123;</span><br><span class="line">                zhangList.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(zhangList);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//把&quot;张&quot;开头的集合中的长度为3的元素存储到一个新的集合</span></span><br><span class="line">        ArrayList&lt;String&gt; threeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s : zhangList) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.length() == <span class="number">3</span>) &#123;</span><br><span class="line">                threeList.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(threeList);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历上一步得到的集合</span></span><br><span class="line">        <span class="keyword">for</span>(String s : threeList) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个集合，存储多个字符串元素</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张曼玉&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;王祖贤&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;柳岩&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张敏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        <span class="comment">//Stream流来改进</span></span><br><span class="line">        list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).filter(s -&gt; s.length() ==</span><br><span class="line">                                                            <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Stream流的好处 </p><ul><li>直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：获取流、过滤姓张、过滤长度为3、逐一打印</li><li>Stream流把真正的函数式编程风格引入到Java中</li></ul></li></ul><h2 id="Stream流的常见生成方式"><a href="#Stream流的常见生成方式" class="headerlink" title="Stream流的常见生成方式"></a>Stream流的常见生成方式</h2><ul><li>Stream流的思想</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697183013414-5ff5b073-aceb-4b0d-82f4-7a40ff3026cb.png#averageHue=%23c9d9ee&clientId=uc4f565ad-210d-4&id=qCJeJ&originHeight=185&originWidth=636&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2d4342cf-4ebc-4fae-aff8-15e83219987&title="></p><ul><li>生成Stream流的方式 <ul><li>Collection体系集合<br>使用默认方法stream()生成流， default Stream stream() </li><li>Map体系集合<br>把Map转成Set集合，间接的生成流 </li><li>数组<br>通过Stream接口的静态方法of(T… values)生成流 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//Collection体系的集合可以使用默认方法stream()生成流</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        Stream&lt;String&gt; listStream = list.stream();</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        Stream&lt;String&gt; setStream = set.stream();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Map体系的集合间接的生成流</span></span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line">        Stream&lt;String&gt; keyStream = map.keySet().stream();</span><br><span class="line">        Stream&lt;Integer&gt; valueStream = map.values().stream();</span><br><span class="line">        Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; entryStream = map.entrySet().stream();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//数组可以通过Stream接口的静态方法of(T... values)生成流</span></span><br><span class="line">        String[] strArray = &#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;java&quot;</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; strArrayStream = Stream.of(strArray);</span><br><span class="line">        Stream&lt;String&gt; strArrayStream2 = Stream.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;java&quot;</span>);</span><br><span class="line">        Stream&lt;Integer&gt; intStream = Stream.of(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Stream流中间操作方法"><a href="#Stream流中间操作方法" class="headerlink" title="Stream流中间操作方法"></a>Stream流中间操作方法</h2><ul><li>概述<br>中间操作的意思是，执行完此方法之后，Stream流依然可以继续执行其他操作。 </li><li>常见方法 <table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Stream filter(Predicate predicate)</td><td>用于对流中的数据进行过滤</td></tr><tr><td>Stream limit(long maxSize)</td><td>返回此流中的元素组成的流，截取前指定参数个数的数据</td></tr><tr><td>Stream skip(long n)</td><td>跳过指定参数个数的数据，返回由该流的剩余元素组成的流</td></tr><tr><td>static Stream concat(Stream a, Stream b)</td><td>合并a和b两个流为一个流</td></tr><tr><td>Stream distinct()</td><td>返回由该流的不同元素（根据Object.equals(Object) ）组成的流</td></tr><tr><td>Stream sorted()</td><td>返回由此流的元素组成的流，根据自然顺序排序</td></tr><tr><td>Stream sorted(Comparator comparator)</td><td>返回由该流的元素组成的流，根据提供的Comparator进行排序</td></tr><tr><td>Stream map(Function mapper)</td><td>返回由给定函数应用于此流的元素的结果组成的流</td></tr><tr><td>IntStream mapToInt(ToIntFunction mapper)</td><td>返回一个IntStream其中包含将给定函数应用于此流的元素的结果</td></tr></tbody></table></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个集合，存储多个字符串元素</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张曼玉&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;王祖贤&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;柳岩&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张敏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//需求1：把list集合中以张开头的元素在控制台输出</span></span><br><span class="line">        list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//需求2：把list集合中长度为3的元素在控制台输出</span></span><br><span class="line">        list.stream().filter(s -&gt; s.length() == <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//需求3：把list集合中以张开头的，长度为3的元素在控制台输出</span></span><br><span class="line">        list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).filter(s -&gt; s.length() ==</span><br><span class="line">                                                            <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个集合，存储多个字符串元素</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张曼玉&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;王祖贤&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;柳岩&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张敏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        <span class="comment">//需求1：取前3个数据在控制台输出</span></span><br><span class="line">        list.stream().limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">        <span class="comment">//需求2：跳过3个元素，把剩下的元素在控制台输出</span></span><br><span class="line">        list.stream().skip(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">        <span class="comment">//需求3：跳过2个元素，把剩下的元素中前2个在控制台输出</span></span><br><span class="line">        list.stream().skip(<span class="number">2</span>).limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个集合，存储多个字符串元素</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张曼玉&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;王祖贤&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;柳岩&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张敏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        <span class="comment">//需求1：取前4个数据组成一个流</span></span><br><span class="line">        Stream&lt;String&gt; s1 = list.stream().limit(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">//需求2：跳过2个数据组成一个流</span></span><br><span class="line">        Stream&lt;String&gt; s2 = list.stream().skip(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//需求3：合并需求1和需求2得到的流，并把结果在控制台输出</span></span><br><span class="line">        <span class="comment">// Stream.concat(s1,s2).forEach(System.out::println);</span></span><br><span class="line">        <span class="comment">//需求4：合并需求1和需求2得到的流，并把结果在控制台输出，要求字符串元素不能重复</span></span><br><span class="line">        Stream.concat(s1,s2).distinct().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个集合，存储多个字符串元素</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;linqingxia&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;zhangmanyu&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;wangzuxian&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;liuyan&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;zhangmin&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;zhangwuji&quot;</span>);</span><br><span class="line">        <span class="comment">//需求1：按照字母顺序把数据在控制台输出</span></span><br><span class="line">        <span class="comment">// list.stream().sorted().forEach(System.out::println);</span></span><br><span class="line">        <span class="comment">//需求2：按照字符串长度把数据在控制台输出</span></span><br><span class="line">        list.stream().sorted((s1,s2) -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> s1.length()-s2.length();</span><br><span class="line">            <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> num==<span class="number">0</span>?s1.compareTo(s2):num;</span><br><span class="line">            <span class="keyword">return</span> num2;</span><br><span class="line">        &#125;).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个集合，存储多个字符串元素</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;20&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;30&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;40&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;50&quot;</span>);</span><br><span class="line">        <span class="comment">//需求：将集合中的字符串数据转换为整数之后在控制台输出</span></span><br><span class="line">        <span class="comment">// list.stream().map(s -&gt; Integer.parseInt(s)).forEach(System.out::println);</span></span><br><span class="line">        <span class="comment">// list.stream().map(Integer::parseInt).forEach(System.out::println);</span></span><br><span class="line">        <span class="comment">// list.stream().mapToInt(Integer::parseInt).forEach(System.out::println);</span></span><br><span class="line">        <span class="comment">//int sum() 返回此流中元素的总和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> list.stream().mapToInt(Integer::parseInt).sum();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Stream流终结操作方法"><a href="#Stream流终结操作方法" class="headerlink" title="Stream流终结操作方法"></a>Stream流终结操作方法</h2><ul><li>概念<br>终结操作的意思是，执行完此方法之后，Stream流将不能再执行其他操作。 </li><li>常见方法 <table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void forEach(Consumer action)</td><td>对此流的每个元素执行操作</td></tr><tr><td>long count()</td><td>返回此流中的元素数</td></tr></tbody></table></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个集合，存储多个字符串元素</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张曼玉&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;王祖贤&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;柳岩&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张敏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        <span class="comment">//需求1：把集合中的元素在控制台输出</span></span><br><span class="line">        <span class="comment">// list.stream().forEach(System.out::println);</span></span><br><span class="line">        <span class="comment">//需求2：统计集合中有几个以张开头的元素，并把统计结果在控制台输出</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Stream流的收集操作"><a href="#Stream流的收集操作" class="headerlink" title="Stream流的收集操作"></a>Stream流的收集操作</h2><ul><li><p>概念<br>对数据使用Stream流的方式操作完毕后，可以把流中的数据收集到集合中。 </p></li><li><p>常见方法 </p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>R collect(Collector collector)</td><td>把结果收集到集合中</td></tr></tbody></table></li><li><p>工具类Collectors提供了具体的收集方式</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static Collector toList()</td><td>把元素收集到List集合中</td></tr><tr><td>public static Collector toSet()</td><td>把元素收集到Set集合中</td></tr><tr><td>public static Collector toMap(Function keyMapper,Function valueMapper)</td><td>把元素收集到Map集合中</td></tr></tbody></table></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建List集合对象</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张曼玉&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;王祖贤&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;柳岩&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //需求1：得到名字为3个字的流</span></span><br><span class="line"><span class="comment">        Stream&lt;String&gt; listStream = list.stream().filter(s -&gt; s.length() == 3);</span></span><br><span class="line"><span class="comment">        //需求2：把使用Stream流操作完毕的数据收集到List集合中并遍历</span></span><br><span class="line"><span class="comment">        List&lt;String&gt; names = listStream.collect(Collectors.toList());</span></span><br><span class="line"><span class="comment">        for(String name : names) &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(name);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//创建Set集合对象</span></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        set.add(<span class="number">10</span>);</span><br><span class="line">        set.add(<span class="number">20</span>);</span><br><span class="line">        set.add(<span class="number">30</span>);</span><br><span class="line">        set.add(<span class="number">33</span>);</span><br><span class="line">        set.add(<span class="number">35</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //需求3：得到年龄大于25的流</span></span><br><span class="line"><span class="comment">        Stream&lt;Integer&gt; setStream = set.stream().filter(age -&gt; age &gt; 25);</span></span><br><span class="line"><span class="comment">        //需求4：把使用Stream流操作完毕的数据收集到Set集合中并遍历</span></span><br><span class="line"><span class="comment">        Set&lt;Integer&gt; ages = setStream.collect(Collectors.toSet());</span></span><br><span class="line"><span class="comment">        for(Integer age : ages) &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(age);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//定义一个字符串数组，每一个字符串数据由姓名数据和年龄数据组合而成</span></span><br><span class="line">        String[] strArray = &#123;<span class="string">&quot;林青霞,30&quot;</span>, <span class="string">&quot;张曼玉,35&quot;</span>, <span class="string">&quot;王祖贤,33&quot;</span>, <span class="string">&quot;柳岩,25&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//需求5：得到字符串中年龄数据大于28的流</span></span><br><span class="line">        Stream&lt;String&gt; arrayStream = Stream.of(strArray).filter(s -&gt;</span><br><span class="line">                                                                Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]) &gt; <span class="number">28</span>);</span><br><span class="line">        <span class="comment">//需求6：把使用Stream流操作完毕的数据收集到Map集合中并遍历，字符串中的姓名作键，年龄作值</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = arrayStream.collect(Collectors.toMap(s -&gt;</span><br><span class="line">                                                                        s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>], s -&gt; Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>])));</span><br><span class="line">        Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;,&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://caochenlei.blog.csdn.net/article/details/119992847&quot;&gt;学习Java8这一篇就够了_java8会这些就够了-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面试题：&lt;a href=&quot;https</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://example.com/2024/01/18/Redis/"/>
    <id>http://example.com/2024/01/18/Redis/</id>
    <published>2024-01-18T02:59:04.709Z</published>
    <updated>2024-01-18T03:28:20.014Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://pdai.tech/md/db/nosql-redis/db-redis-overview.html">♥Redis教程 - Redis知识体系详解♥</a></p><h1 id="1、概念和基础"><a href="#1、概念和基础" class="headerlink" title="1、概念和基础"></a>1、概念和基础</h1><h2 id="1-1-Redis概念"><a href="#1-1-Redis概念" class="headerlink" title="1.1 Redis概念"></a>1.1 Redis概念</h2><p>Redis 是一个使用 C 语言写成的，开源的高性能<strong>key-value非关系缓存数据库</strong>。它支持存储的value类型相对更多，包括<strong>string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）</strong>。Redis的数据都基于<strong>缓存</strong>的，所以很快，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。Redis也可以实现数据写入磁盘中，保证了数据的安全不丢失，而且Redis的操作是<strong>原子性</strong>的。</p><ol><li><strong>Redis的应用场景：</strong><br>:::tips</li></ol><ul><li><strong>分布式锁：</strong>通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁</li><li><strong>限流</strong>：一般是通过 Redis + Lua 脚本的方式来实现限流。</li><li><strong>消息队列</strong>：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</li><li><strong>延时队列</strong>：Redisson 内置了延时队列（基于 sorted set 实现的）。</li><li><strong>分布式 Session</strong> ：利用 string 或者 hash 保存 Session 数据，所有的服务器都可以访问。</li><li><strong>复杂业务场景</strong>：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。<br>:::</li></ul><ol start="2"><li><strong>Redis的特点：</strong><br>:::tips</li></ol><ul><li><strong>读写性能优异：</strong>Redis能读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s </li><li><strong>数据类型丰富：</strong>Redis支持二进制案例的 Strings, List, Hash, Set 及 ZSet 数据类型操作</li><li><strong>原子性：</strong>Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行</li><li><strong>丰富的特性：</strong>Redis支持 publish&#x2F;subscribe, 通知, key 过期等特性</li><li><strong>持久化：</strong>Redis支持RDB, AOF等持久化方式</li><li><strong>发布订阅：</strong>Redis支持发布&#x2F;订阅模式</li><li><strong>分布式：</strong>Redis Cluster<br>:::</li></ul><h2 id="1-2-Redis的使用场景⭐"><a href="#1-2-Redis的使用场景⭐" class="headerlink" title="1.2 Redis的使用场景⭐"></a>1.2 Redis的使用场景⭐</h2><p>:::tips</p><ol><li><p>热点数据的缓存</p></li><li><p>限时业务的运用</p></li><li><p>计数器相关问题</p></li><li><p>分布式锁</p></li><li><p>延时操作</p></li><li><p>排行榜相关问题</p></li><li><p>点赞、好友等相互关系存储</p></li><li><p>简单队列<br>:::<br>:::tips</p></li><li><p><strong>热点数据的缓存：</strong>缓存是Redis最常见的应用场景，之所有这么使用，主要是因为Redis读写性能优异。而且逐渐有取代memcached，成为首选服务端缓存的组件。而且，Redis内部是支持事务的，在使用时候能有效保证数据的一致性。</p></li></ol><p>作为缓存使用时，<strong>一般有两种方式保存数据：</strong></p><ul><li>读取前，先去读Redis，如果没有数据，读取数据库，将数据拉入Redis。</li><li>插入数据时，同时写入Redis。</li></ul><p><strong>方案一：实施起来简单。</strong>但是有两个需要注意的地方：</p><ul><li>避免缓存击穿。（数据库没有就需要命中的数据，导致Redis一直没有数据，而一直命中数据库）</li><li>数据的实时性相对会差一点。</li></ul><p><strong>方案二：数据实时性强。</strong>但是开发时不便于统一处理。<br>当然，两种方式根据实际情况来适用。如：方案一适用于对于数据实时性要求不是特别高的场景。方案二适用于字典表、数据量不大的数据存储。<br>:::<br>:::tips</p><ol start="2"><li><p><strong>限时业务的运用：</strong>redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。<br>:::<br>:::tips</p></li><li><p><strong>计数器相关问题：</strong>redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。<br>:::<br>:::tips</p></li><li><p><strong>分布式锁：</strong>这个主要利用redis的setnx命令进行，setnx：”set if not exists”就是如果不存在则成功设置缓存同时返回1，否则返回0 ，这个特性在很多后台中都有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock， 如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。</p></li></ol><p>在分布式锁的场景中，主要用在比如秒杀系统等。<br>:::<br>:::tips</p><ol start="5"><li><strong>延时操作：</strong>比如在订单生产后我们占用了库存，10分钟后去检验用户是否真正购买，如果没有购买将该单据设置无效，同时还原库存。 由于redis自2.8.0之后版本提供Keyspace Notifications功能，允许客户订阅Pub&#x2F;Sub频道，以便以某种方式接收影响Redis数据集的事件。 所以我们对于上面的需求就可以用以下解决方案，我们在订单生产时，设置一个key，同时设置10分钟后过期， 我们在后台实现一个监听器，监听key的实效，监听到key失效时将后续逻辑加上。</li></ol><p>当然我们也可以利用rabbitmq、activemq等消息中间件的延迟队列服务实现该需求。<br>:::<br>:::tips</p><ol start="6"><li><strong>排行榜相关问题：</strong>关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的SortedSet进行热点数据的排序。</li></ol><p>比如点赞排行榜，做一个SortedSet, 然后以用户的openid作为上面的username, 以用户的点赞数作为上面的score, 然后针对每个用户做一个hash, 通过zrangebyscore就可以按照点赞数获取排行榜，然后再根据username获取用户的hash信息，这个当时在实际运用中性能体验也蛮不错的。<br>:::<br>:::tips</p><ol start="7"><li><strong>点赞、好友等相互关系的存储：</strong>Redis 利用集合的一些命令，比如求交集、并集、差集等。</li></ol><p>在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。<br>:::<br>:::tips</p><ol start="8"><li><strong>简单队列：</strong>由于Redis有list push和list pop这样的命令，所以能够很方便的执行队列操作。<br>:::</li></ol><h1 id="2、数据类型"><a href="#2、数据类型" class="headerlink" title="2、数据类型"></a>2、数据类型</h1><h2 id="2-1-5种基本类型⭐⭐"><a href="#2-1-5种基本类型⭐⭐" class="headerlink" title="2.1 5种基本类型⭐⭐"></a>2.1 5种基本类型⭐⭐</h2><p>:::tips<br><strong>String 字符串：</strong>key：value，value可以是字符串、整数或浮点数<br><strong>Hash 散列：</strong> string 类型的 field（字段） 和 value（值） 的映射表，适合用于存储对象<br><strong>List 列表：</strong>链表上的每个节点都包含一个字符串（双端链表）<br><strong>Set 集合：</strong>Set 是 String 类型的无序集合，不能出现重复的数据<br><strong>ZSet 有序集合：</strong>基于Set的基础上，每个元素都会关联一个 double 类型的分数用于排序，有序集合的成员是唯一的, 但分数(score)却可以重复<br>:::<br>首先对redis来说，所有的key（键）都是字符串。我们在谈基础数据结构时，讨论的是存储值的数据类型，主要包括常见的5种数据类型，分别是：String、List、Set、Zset、Hash。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/35382725/1696295177498-b6ce1b39-6d8c-45d6-81cf-6f8e79dd177b.jpeg#averageHue=%23eedfd3&clientId=u0e2b69ca-e6a6-4&from=drop&id=LXEDD&originHeight=392&originWidth=876&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=24782&status=done&style=none&taskId=uccff1844-6f9e-45bb-b2ed-b84d355122a&title=" alt="db-redis-ds-1.jpg"></p><ol><li><strong>String字符串</strong><blockquote><p>String是redis中最基本的数据类型，一个key对应一个value。</p></blockquote></li></ol><p>String类型是二进制安全的，意思是 redis 的 string 可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。</p><ul><li>下图是一个String类型的实例，其中键为hello，值为world</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696307316031-05475f61-52e6-4b43-bace-54f4bd8ddc62.png#averageHue=%23f7f7f7&clientId=u0e2b69ca-e6a6-4&from=drop&height=237&id=X1UVC&originHeight=504&originWidth=814&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=13915&status=done&style=none&taskId=u51cbf96c-ff46-4ce0-a7a0-0356b1954af&title=&width=382.60003662109375" alt="db-redis-ds-3.png"></p><table><thead><tr><th><strong>命令</strong></th><th><strong>简述</strong></th><th><strong>使用</strong></th></tr></thead><tbody><tr><td>get</td><td>获取存储在给定键中的值</td><td>get [name]</td></tr><tr><td>set</td><td>设置存储在给定键中的值</td><td>set [name] [value]</td></tr><tr><td>del</td><td>删除存储在给定键中的值</td><td>del [name]</td></tr><tr><td>incr</td><td>将键存储的值加1</td><td>incr [key]</td></tr><tr><td>decr</td><td>将键存储的值减1</td><td>decr [key]</td></tr><tr><td>incrby</td><td>将键存储的值加上整数xx</td><td>incrby [key] [xx]</td></tr><tr><td>decrby</td><td>将键存储的值减去整数xx</td><td>decrby [key] [xx]</td></tr></tbody></table><p>:::tips</p><ul><li><strong>实战场景</strong><ul><li>**缓存： **经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力</li><li><strong>计数器：</strong>redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。</li><li><strong>session：</strong>常见方案spring session + redis实现session共享，<br> :::</li></ul></li></ul><ol start="2"><li><strong>Hash 散列</strong><blockquote><p>Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p></blockquote></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696308222144-2f132561-1cf6-4778-aaf3-ad5de93ce16f.png#averageHue=%23f0f0f0&clientId=u0e2b69ca-e6a6-4&from=drop&height=278&id=rmjpQ&originHeight=582&originWidth=742&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=29717&status=done&style=none&taskId=uf9f8d621-c73b-41d9-bd0f-dadc4ab55fe&title=&width=354.6000061035156" alt="db-redis-ds-4.png"></p><table><thead><tr><th><strong>命令</strong></th><th><strong>简述</strong></th><th><strong>使用</strong></th></tr></thead><tbody><tr><td>hset</td><td>添加键值对</td><td>hset [hash-key] [sub-key1] [value1]</td></tr><tr><td>hget</td><td>获取指定散列键的值</td><td>hget [hash-key] [key1]</td></tr><tr><td>hgetall</td><td>获取散列中包含的所有键值对</td><td>hgetall [hash-key]</td></tr><tr><td>hdel</td><td>如果给定键存在于散列中，那么就移除这个键</td><td>hdel [hash-key] [sub-key1]</td></tr></tbody></table><p>:::tips</p><ul><li><strong>实战场景</strong></li></ul><p><strong>缓存：</strong> 能直观，相比string更节省空间，的维护缓存信息，如用户信息，视频信息等。<br>:::</p><ol start="3"><li><strong>List 列表</strong><blockquote><p>Redis中的List其实就是链表（Redis用双端链表实现List）</p></blockquote></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696308577013-f7859dd1-d4bd-4308-bdc5-d4ceedb2c9ba.png#averageHue=%23f2f2f2&clientId=u0e2b69ca-e6a6-4&from=drop&height=238&id=d1WLH&originHeight=518&originWidth=768&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=22935&status=done&style=none&taskId=u5c712394-965c-4912-8d20-15a8d050bb6&title=&width=352.60003662109375" alt="db-redis-ds-5.png"></p><table><thead><tr><th><strong>命令</strong></th><th><strong>简述</strong></th><th><strong>使用</strong></th></tr></thead><tbody><tr><td>rpush</td><td>将给定值推入到列表右端</td><td>rpush [key] [value1,value2…]</td></tr><tr><td>lpush</td><td>将给定值推入到列表左端</td><td>lpush [key] [value1,value2…]</td></tr><tr><td>rpop</td><td>从列表的右端弹出一个值，并返回被弹出的值</td><td>rpop [key]</td></tr><tr><td>lpop</td><td>从列表的左端弹出一个值，并返回被弹出的值</td><td>lpop [key]</td></tr><tr><td>lrange</td><td>获取列表在给定范围上的所有值</td><td>lrange [key] [0] [-1]</td></tr><tr><td>lindex</td><td>通过索引获取列表中的元素。你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推</td><td>lindex [key] [index]</td></tr></tbody></table><p>:::tips</p><ul><li><strong>实战场景：</strong><ul><li><strong>消息排队功能：</strong>有人发布微博，用lpush加入时间轴，展示新的列表信息（微博TimeLine）</li><li><strong>消息队列：</strong>利用List的 PUSH 操作，将任务存放在List中，然后工作线程再用 POP 操作将任务取出进行执行。</li></ul></li><li><strong>使用列表的技巧：</strong><ul><li>lpush+lpop&#x3D;Stack(栈)</li><li>lpush+rpop&#x3D;Queue（队列）</li><li>lpush+ltrim&#x3D;Capped Collection（有限集合）</li><li>lpush+brpop&#x3D;Message Queue（消息队列）<br> :::</li></ul></li></ul><ol start="4"><li><strong>Set 集合</strong><blockquote><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p></blockquote></li></ol><p>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696309080082-bdc34775-74ee-4521-a581-50371e7178bc.png#averageHue=%23f3f3f3&clientId=u0e2b69ca-e6a6-4&from=drop&height=267&id=Iuzul&originHeight=544&originWidth=776&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=29112&status=done&style=none&taskId=ud586c38a-9c11-43ba-9435-0e0843266f5&title=&width=380.60003662109375" alt="db-redis-ds-7.png"></p><table><thead><tr><th><strong>命令</strong></th><th><strong>简述</strong></th><th><strong>使用</strong></th></tr></thead><tbody><tr><td>sadd</td><td>向集合添加一个或多个成员</td><td>sadd [key] [value1 value2…]</td></tr><tr><td>scard</td><td>获取集合的成员数</td><td>scard [key]</td></tr><tr><td>smembers</td><td>返回集合中的所有成员</td><td>smembers [key] [member]</td></tr><tr><td>sismember</td><td>判断 member 元素是否是集合 key 的成员</td><td>sismember [key] [member]</td></tr></tbody></table><ul><li><p>更多命令：<a href="https://www.runoob.com/redis/redis-sets.html">Redis 集合(Set) | 菜鸟教程</a><br>:::tips</p></li><li><p><strong>实战场景：</strong></p><ul><li><strong>标签（tag）：</strong>给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。</li><li><strong>点赞，或点踩，收藏等：</strong>可以放到set中实现<br> :::</li></ul></li></ul><ol start="5"><li><strong>ZSet 有序集合</strong><blockquote><p>Redis 具备Set性质，每个元素都会关联一个 double 类型的分数。redis是通过分数来为集合中的成员进行从小到大的排序。</p></blockquote></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696309434467-018929c6-9d9a-424a-996f-23c3afa871b8.png#averageHue=%23ededed&clientId=u0e2b69ca-e6a6-4&from=drop&height=326&id=BPH99&originHeight=542&originWidth=730&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=40422&status=done&style=none&taskId=ufe699e43-7b1e-42d0-b937-00db853d90f&title=&width=439.60003662109375" alt="db-redis-ds-8.png"></p><table><thead><tr><th><strong>命令</strong></th><th><strong>简述</strong></th><th><strong>使用</strong></th></tr></thead><tbody><tr><td>zadd</td><td>将一个带有给定分值的成员添加到有序集合里面</td><td>zadd [zset-key] [78] [member1]</td></tr><tr><td>zrange</td><td>根据元素在有序集合中所处的位置，从有序集合中获取多个元素</td><td>zrange [zset-key] [0] [-1]</td></tr><tr><td>zrem</td><td>如果给定元素成员存在于有序集合中，那么就移除这个元素</td><td>zrem [zset-key] [member1]</td></tr></tbody></table><p>更多命令：<a href="https://www.runoob.com/redis/redis-sorted-sets.html">Redis 有序集合(sorted set) | 菜鸟教程</a><br>:::tips</p><ul><li><strong>实战场景</strong><ul><li><strong>排行榜：</strong>有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行。<br> :::</li></ul></li></ul><h2 id="2-2-3种特殊类型"><a href="#2-2-3种特殊类型" class="headerlink" title="2.2 3种特殊类型"></a>2.2 3种特殊类型</h2><p>:::tips<br><strong>Hyperloglog 基数统计</strong>：非常省内存的去统计各种计数，比如注册 IP 数、每日访问 IP 数、页面实时UV、在线用户数，共同好友数等。<br><strong>Bitmaps 位存储：</strong>统计用户信息，活跃，不活跃！ 登录，未登录！ 打卡，不打卡！ 两个状态<br><strong>Geo 地理位置：</strong>可以推算地理位置的信息: 两地之间的距离, 方圆几里的人<br>:::</p><ol><li><strong>Hyperloglog 基数统计：</strong></li></ol><ul><li><strong>基数概念：</strong><ul><li>A &#x3D; {1, 2, 3, 4, 5}， B &#x3D; {3, 5, 6, 7, 9}；那么基数（不重复的元素）&#x3D; 1, 2, 4, 6, 7, 9； （允许容错，即可以接受一定误差）</li></ul></li><li><strong>基数统计用来解决什么问题？</strong><ul><li>这个结构可以非常省内存的去统计各种计数，比如注册 IP 数、每日访问 IP 数、页面实时UV、在线用户数，共同好友数等。</li></ul></li><li><strong>它的优势体现在哪？</strong><ul><li>一个大型的网站，每天 IP 比如有 100 万，粗算一个 IP 消耗 15 字节，那么 100 万个 IP 就是 15M。而 HyperLogLog 在 Redis 中每个键占用的内容都是 12K，理论存储近似接近 2^64 个值，不管存储的内容是什么，它一个基于基数估算的算法，只能比较准确的估算出基数，可以使用少量固定的内存去存储并识别集合中的唯一元素。而且这个估算的基数并不一定准确，是一个带有 0.81% 标准错误的近似值（对于可以接受一定容错的业务场景，比如IP数统计，UV等，是可以忽略不计的）。<table><thead><tr><th><strong>命令</strong></th><th><strong>简述</strong></th><th><strong>使用</strong></th></tr></thead><tbody><tr><td>pfadd</td><td>创建一组元素</td><td>pfadd [key1] [value1,value2…]</td></tr><tr><td>pfcount</td><td>统计元素的基数数量</td><td>pfcount [key1]</td></tr><tr><td>pfmerge</td><td>合并两组：key1 key2 -&gt; key3 并集</td><td>pfmerge [key3] [key1] [key2]</td></tr></tbody></table></li></ul></li></ul><ol start="2"><li><strong>Bitmaps 位存储：</strong><blockquote><p>Bitmap 即位图数据结构，都是操作二进制位来进行记录，只有0 和 1 两个状态</p></blockquote></li></ol><ul><li><strong>用来解决什么问题？</strong><ul><li>比如：统计用户信息，活跃，不活跃！ 登录，未登录！ <strong>打卡，不打卡！</strong> 两个状态的，都可以使用 Bitmaps！</li><li>如果存储一年的打卡状态需要多少内存呢？ 365 天 &#x3D; 365 bit 1字节 &#x3D; 8bit 46 个字节左右！<table><thead><tr><th><strong>命令</strong></th><th><strong>简述</strong></th><th><strong>使用</strong></th></tr></thead><tbody><tr><td>setbit</td><td>记录位(0&#x2F;1)情况</td><td>setbit [key1] [day1] [0&#x2F;1]</td></tr><tr><td>getbit</td><td>查看(0&#x2F;1)情况</td><td>getbit [key1] [day1]</td></tr><tr><td>bitcount</td><td>统计操作</td><td>bitcount [key1]</td></tr></tbody></table></li></ul></li></ul><ol start="3"><li><strong>Geo 地理位置：</strong><blockquote><p>Redis 的 Geo 在 Redis 3.2 版本就推出了! 这个功能可以推算地理位置的信息: 两地之间的距离, 方圆几里的人</p></blockquote></li></ol><table><thead><tr><th><strong>命令</strong></th><th><strong>简述</strong></th><th><strong>使用</strong></th></tr></thead><tbody><tr><td>geoadd</td><td>添加地理位置 [key] [经度] [维度] [value]</td><td>geoadd [china:city] [118.76] [32.04] [beijing]</td></tr><tr><td>geopos</td><td>获得指定成员的经纬度 [key] [value]</td><td>geopos [china:city] [beijing]</td></tr><tr><td>geodist</td><td>获得指定成员间的距离 [key] [value1] [value2]</td><td>bitcount [china:city] [beijing] [shenzhen]</td></tr><tr><td>georadius</td><td>附近的人：[key] [经度] [纬度] [半径] [单位] [结果经度&#x2F;纬度] [结果距离] [结果数量]</td><td>georadius [china:city] [100] [30] [1000] [km] withcoord withdist [count 2]</td></tr><tr><td>georadiusbymember</td><td>显示与指定成员一定半径范围内的其他成员(参数和上面一样)</td><td>georadiusbymember [china:city] [100] [30] [1000] [km] withcoord withdist [count 2]</td></tr></tbody></table><p>:::tips<br><strong>规则</strong><br>两级无法直接添加，我们一般会下载城市数据(这个网址可以查询 GEO： <a href="http://www.jsons.cn/lngcode)%EF%BC%81">http://www.jsons.cn/lngcode)！</a></p><ul><li>有效的经度从-180度到180度。</li><li>有效的纬度从-85.05112878度到85.05112878度。</li></ul><p>距离单位：m、km、mi 英里、ft 英尺<br>注：底层是由ZSet组成，操作geo<br>:::</p><h2 id="2-3-底层数据结构"><a href="#2-3-底层数据结构" class="headerlink" title="2.3 底层数据结构"></a>2.3 底层数据结构</h2><p><a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-redis-ds.html">Redis进阶 - 数据结构：底层数据结构详解</a><br>在对对象机制（redisObject）有了初步认识之后，我们便可以继续理解如下的底层数据结构部分：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696320469720-9c3c2fd7-976c-41b5-92f8-8fc63fe5b20c.png#averageHue=%23ecd4a3&clientId=u0e2b69ca-e6a6-4&from=drop&id=xcb9r&originHeight=1128&originWidth=1938&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=93402&status=done&style=none&taskId=ub11da376-05a9-413e-985f-8e793c41ce7&title=" alt="db-redis-object-2-3.png"><br><strong>7种基本的数据类型：</strong></p><ul><li>简单动态字符串 - SDS</li><li>快表 - QuickList （&#x3D; LinkedList + ZipList）</li><li>双向链表 - LinkedList</li><li>压缩列表 - ZipList</li><li>字典&#x2F;哈希表 - Dict</li><li>整数集 - IntSet</li><li>跳表 - ZSkipList<table><thead><tr><th>String</th><th>List</th><th>Hash</th><th>Set</th><th>Zset</th></tr></thead><tbody><tr><td>SDS</td><td>QuickList</td><td></td><td></td><td></td></tr><tr><td>(LinkedList&#x2F;ZipList)</td><td>Dict、ZipList</td><td>Dict、Intset</td><td>ZipList、SkipList</td><td></td></tr></tbody></table></li></ul><h1 id="3、SpringBoot集成Redis"><a href="#3、SpringBoot集成Redis" class="headerlink" title="3、SpringBoot集成Redis"></a>3、SpringBoot集成Redis</h1><p><a href="https://pdai.tech/md/spring/springboot/springboot-x-redis-jedis.html">▶SpringBoot集成Redis - 基于RedisTemplate+Jedis的数据操作</a></p><h1 id="4、持久化⭐⭐"><a href="#4、持久化⭐⭐" class="headerlink" title="4、持久化⭐⭐"></a>4、持久化⭐⭐</h1><p><a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-rdb-aof.html">Redis进阶 - 持久化：RDB和AOF机制详解</a></p><ul><li><strong>为什么需要持久化？</strong></li></ul><p>Redis是个基于内存的数据库。那服务一旦宕机，内存中的数据将全部丢失。通常的解决方案是从后端数据库恢复这些数据，但后端数据库有性能瓶颈，如果是大数据量的恢复：</p><ol><li>会对数据库带来巨大的压力</li><li>数据库的性能不如Redis，导致程序响应慢。</li></ol><h2 id="4-1-RDB⭐"><a href="#4-1-RDB⭐" class="headerlink" title="4.1 RDB⭐"></a>4.1 RDB⭐</h2><ul><li><strong>不安全，但性能好 —&gt;博客访问数量</strong><br>:::tips</li></ul><ol><li><p><strong>触发方式：</strong>手动触发&#x2F;自动触发</p></li><li><p><strong>redis.conf中配置RDB</strong></p></li><li><p><strong>RDB优缺点</strong><br>:::<br>RDB（Redis DataBase）：<strong>内存快照；</strong>RDB持久化是把当前进程数据生成快照保存到磁盘上的过程，由于是某一时刻的快照，那么快照中的值要早于或者等于内存中的值。【核心思路是Copy-on-Write】</p></li><li><p><strong>触发方式：</strong>手动触发&#x2F;自动触发</p></li></ol><p><strong>手动触发：</strong></p><ul><li><strong>save命令：</strong>阻塞当前Redis服务器，直到RDB过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用</li><li><strong>bgsave命令：</strong>Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短 √</li></ul><p><strong>自动触发：</strong></p><ul><li><strong>redis.conf中配置save m n</strong>，即在m秒内有n次修改时，自动触发bgsave生成rdb文件；</li><li><strong>主从复制</strong>时，从节点要从主节点进行全量复制时也会触发bgsave操作，生成当时的快照发送到从节点；</li><li><strong>执行debug reload命令</strong>重新加载redis时也会触发bgsave操作；</li><li><strong>默认情况下执行shutdown命令时</strong>，如果没有开启aof持久化，那么也会触发bgsave操作；</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/35382725/1696323733623-d9f7168e-7a14-4d91-a60e-b01e178a3166.jpeg#averageHue=%23f5f7e6&clientId=u0e2b69ca-e6a6-4&from=drop&id=q4Fjz&originHeight=2250&originWidth=4000&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=187137&status=done&style=none&taskId=u4f0c35a7-dcff-4371-9bee-7459c99e003&title=" alt="redis-x-aof-42.jpg"><br>:::tips<br>触发流程如下：</p><ul><li>redis客户端执行bgsave命令或者自动触发bgsave命令；</li><li>主进程判断当前是否已经存在正在执行的子进程，如果存在，那么主进程直接返回；</li><li>如果不存在正在执行的子进程，那么就fork一个新的子进程进行持久化数据，fork过程是阻塞的，fork操作完成后主进程即可执行其他操作；</li><li>子进程先将数据写入到临时的rdb文件中，待快照数据写入完成后再原子替换旧的rdb文件；</li><li>同时发送信号给主进程，通知主进程rdb持久化完成，主进程更新相关的统计信息（info Persitence下的rdb_*相关选项）。<br>:::</li></ul><ol start="2"><li><strong>redis.conf中配置RDB</strong></li></ol><p>快照周期：内存快照虽然可以通过技术人员手动执行SAVE或BGSAVE命令来进行，但生产环境下多数情况都会设置其周期性执行条件。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">周期性执行条件的设置格式为</span></span><br><span class="line">save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认的设置为：</span></span><br><span class="line">save 900 1 # 如果900秒内有1条Key信息发生变化，则进行快照；</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以下设置方式为关闭RDB快照功能</span></span><br><span class="line">save &quot;&quot;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件名称</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件保存路径（默认设置为“./”，也就是Redis服务的主目录）</span></span><br><span class="line">dir /home/work/app/redis/data/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果持久化出错，主进程是否停止写入</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是否压缩（使用LZF压缩算法，建议<span class="built_in">yes</span>）</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导入时是否检查</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">（会多损失10%左右的性能，但获得了更高的数据可靠性，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要追求极致的性能，就可以将这个选项设置为no）</span></span><br><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>RDB优缺点</strong><br>:::tips</li></ol><ul><li><strong>优点</strong><ul><li><strong>空间存储小。</strong>RDB文件是某个时间节点的快照，默认使用LZF算法进行压缩，压缩后的文件体积远远小于内存大小，适用于备份、全量复制等场景；</li><li><strong>数据恢复快。</strong>Redis加载RDB文件恢复数据要远远快于AOF方式；</li></ul></li><li><strong>缺点</strong><ul><li><strong>实时性不够。</strong>无法做到秒级的持久化；</li><li><strong>带宽消耗大。</strong>每次调用bgsave都需要fork子进程，fork子进程属于重量级操作，频繁执行成本较高；</li><li><strong>手动恢复困难。</strong>RDB文件是二进制的，没有可读性；</li><li><strong>版本兼容问题。</strong></li></ul></li></ul><p>针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决<br>:::<br>:::tips<br><strong>相关场景：</strong></p><ul><li><strong>在进行快照操作的这段时间，如果发生服务崩溃怎么办？</strong>—&gt; 失败回滚到上一次备份的版本，成功的话替换原先版本。</li><li><strong>可以每秒做一次快照吗？</strong>—&gt; 可以，但是不建议。虽然 bgsave 执行时不阻塞主线程，但是，如果频繁地执行全量快照，也会带来两方面的开销：<ul><li>一方面，频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。</li><li>另一方面，bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁<strong>阻塞主线程</strong>了。</li></ul></li></ul><p>解决方案：做增量快照，就是指做了一次全量快照后，<strong>后续的快照只对修改的数据进行快照记录</strong>，这样可以避免每次全量快照的开销。<br>:::</p><h2 id="4-2-AOF⭐"><a href="#4-2-AOF⭐" class="headerlink" title="4.2 AOF⭐"></a>4.2 AOF⭐</h2><ul><li><strong>安全，但恢复速度慢 —&gt;用户信息</strong><br>:::tips</li></ul><ol><li><strong>如何实现AOF</strong></li><li><strong>redis.conf中配置AOF</strong></li><li><strong>AOF特点</strong><br>:::<br>AOF (Append-Only File)：<strong>日志重写，</strong>把数据写入内存，然后才记录日志。日志里记录的是Redis收到的每一条命令，这些命令是以文本形式保存。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/35382725/1696324869344-ac86750f-0067-4564-8a8b-392265b2476b.jpeg#averageHue=%23f7f6e1&clientId=u0e2b69ca-e6a6-4&from=drop&height=259&id=g2WHO&originHeight=1789&originWidth=3218&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=90806&status=done&style=none&taskId=u6784ff56-97fa-4242-b213-be52902b6e0&title=&width=466.60003662109375" alt="redis-x-aof-41.jpg"><br>PS：AOF日志采用后日志，即<strong>先写内存，后写日志</strong>。与大多数数据库的前日志（WAL）相反。后写日志的内存有两个好处：</li></ol><ul><li><strong>避免额外的检查开销：</strong>Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。</li><li><strong>不会阻塞当前的写操作。</strong></li></ul><ol><li><strong>如何实现AOF</strong></li></ol><p>AOF日志记录Redis的每个写命令，步骤分为：命令追加（append）、文件写入（write）和文件同步（sync）。</p><ul><li><strong>命令追加</strong> 当AOF持久化功能打开了，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器的 aof_buf 缓冲区。</li><li><strong>文件写入和同步</strong> 关于何时将 aof_buf 缓冲区的内容写入AOF文件中，Redis提供了三种写回策略：</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/35382725/1696325098940-0b02810a-6289-4906-b504-d59ef8311a1c.jpeg#averageHue=%23f0e29e&clientId=u0e2b69ca-e6a6-4&from=drop&id=IZ713&originHeight=682&originWidth=2284&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=129292&status=done&style=none&taskId=u48088c50-d075-414d-8eb5-785e3283c13&title=" alt="redis-x-aof-4.jpg"></p><ul><li><strong>Always，同步写回：</strong>每个写命令执行完，立马同步地将日志写回磁盘；</li><li><strong>Everysec，每秒写回：</strong>每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；</li><li><strong>No，操作系统控制的写回：</strong>每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。</li></ul><ol start="2"><li><strong>redis.conf中配置AOF</strong></li></ol><p>默认情况下，Redis是没有开启AOF的，可以通过配置redis.conf文件来开启AOF持久化，关于AOF的配置如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">appendonly参数开启AOF持久化</span></span><br><span class="line">appendonly no</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AOF持久化的文件名，默认是appendonly.aof</span></span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AOF文件的保存位置和RDB文件的位置相同，都是通过<span class="built_in">dir</span>参数设置的</span></span><br><span class="line">dir ./</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同步策略【⭐】</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">appendfsync always</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">appendfsync no</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">aof重写期间是否同步</span></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重写触发配置</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载aof出错如何处理</span></span><br><span class="line">aof-load-truncated yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件重写策略</span></span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure><p><strong>两个配置项控制AOF重写的触发：</strong></p><ul><li><strong>auto-aof-rewrite-min-size：</strong>表示运行AOF重写时文件的最小大小，默认为64MB</li><li><strong>auto-aof-rewrite-percentage：</strong>这个值的计算方式是，当前aof文件大小和上一次重写后aof文件大小的差值，再除以上一次重写后aof文件大小。也就是当前aof文件比上一次重写后aof文件的增量大小，和上一次重写后aof文件大小的比值</li></ul><ol start="3"><li><strong>AOF特点</strong><br>:::tips<br>现存问题： AOF会记录每个写命令到AOF文件，随着时间越来越长，AOF文件会变得越来越大。如果不加以控制，会对Redis服务器，甚至对操作系统造成影响，而且AOF文件越大，数据恢复也越慢。为了解决AOF文件体积膨胀的问题，Redis提供AOF文件重写机制来对AOF文件进行“瘦身”。<br>:::<br><strong>图例解释AOF重写：</strong></li></ol><ul><li>Redis通过创建一个新的AOF文件来替换现有的AOF，新旧两个AOF文件保存的数据相同，但新AOF文件没有了冗余命令。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/35382725/1696325282327-55069e8a-5794-43f2-ad92-58ba12108ef9.jpeg#averageHue=%23f5f4ec&clientId=u0e2b69ca-e6a6-4&from=paste&id=GnpxS&originHeight=1080&originWidth=3970&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u322ecf1a-6ab4-410e-a25f-e1d80c24cd5&title="><br><strong>总结操作：</strong></p><ul><li>主线程fork出子进程重写aof日志</li><li>子进程重写日志完成后，主线程追加aof日志缓冲</li><li>替换日志文件</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/35382725/1696325413470-fb91004b-6c0b-4d82-ba3a-2b54c19da980.jpeg#averageHue=%23f6f0e3&clientId=u0e2b69ca-e6a6-4&from=drop&id=PclRj&originHeight=1080&originWidth=2308&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=103000&status=done&style=none&taskId=u5fd385f7-1b8c-4cf3-8a1d-0c2df38da1a&title=" alt="redis-x-aof-2.jpg"><br><strong>为什么AOF重写不复用原AOF日志？</strong></p><ol><li>父子进程写同一个文件会产生竞争问题，影响父进程的性能。</li><li>如果AOF重写过程中失败了，相当于污染了原本的AOF文件，无法做恢复数据使用。</li></ol><h2 id="4-3-RDB和AOF混合方式"><a href="#4-3-RDB和AOF混合方式" class="headerlink" title="4.3 RDB和AOF混合方式"></a>4.3 RDB和AOF混合方式</h2><p>Redis 4.0 中提出了一个混合使用** AOF 日志 **和 **内存快照 **的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/35382725/1696325536463-e0bb7428-d0f8-4661-b305-89495eee15b8.jpeg#averageHue=%23f0f3e5&clientId=u0e2b69ca-e6a6-4&from=drop&id=I6Lyq&originHeight=2183&originWidth=3508&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=216639&status=done&style=none&taskId=u894a3a5d-1d08-4749-84bf-62bdba203ae&title=" alt="redis-x-rdb-4.jpg"><br>这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。<br>如图所示，T1 和 T2 时刻的修改，用 AOF 日志记录，等到第二次做全量快照时，就可以清空 AOF 日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了。<br>这个方法既能享受到 RDB 文件快速恢复的好处，又能享受到 AOF 只记录操作命令的简单优势, 实际环境中用的很多。</p><h2 id="4-4-备份恢复"><a href="#4-4-备份恢复" class="headerlink" title="4.4 备份恢复"></a>4.4 备份恢复</h2><p>数据的备份、持久化做完了，我们如何从这些持久化文件中恢复数据呢？如果一台服务器上有既有RDB文件，又有AOF文件，该加载谁呢？</p><ul><li>其实想要从这些文件中恢复数据，只需要重新启动Redis即可。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696325590321-083d885c-68cc-410d-a7aa-cae3509a5217.png#averageHue=%23fafafa&clientId=u0e2b69ca-e6a6-4&from=drop&height=401&id=Gos0o&originHeight=800&originWidth=663&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=14060&status=done&style=none&taskId=u5ccb5b7c-f8c1-4886-acdd-158b00576dc&title=&width=332.6000061035156" alt="redis-x-aof-5.png"></p><ol><li>redis重启时判断是否开启aof，如果开启了aof，那么就优先加载aof文件；</li><li>如果aof存在，那么就去加载aof文件，加载成功的话redis重启成功，如果aof文件加载失败，那么会打印日志表示启动失败，此时可以去修复aof文件后重新启动；</li><li>若aof文件不存在，那么redis就会转而去加载rdb文件，如果rdb文件不存在，redis直接启动成功；</li><li>如果rdb文件存在就会去加载rdb文件恢复数据，如加载失败则打印日志提示启动失败，如加载成功，那么redis重启成功，且使用rdb文件恢复数据；</li></ol><p>那么为什么会优先加载AOF呢？因为AOF保存的数据更完整，通过上面的分析我们知道AOF基本上最多损失1s的数据。</p><h2 id="4-5-性能优化"><a href="#4-5-性能优化" class="headerlink" title="4.5 性能优化"></a>4.5 性能优化</h2><p>RDB的快照、AOF的重写都需要fork，这是重量级操作，会对Redis造成阻塞。<br>:::tips<br>因此为了不影响Redis主进程响应，我们需要<strong>降低阻塞</strong>：</p><ul><li><p>降低fork的频率，比如可以手动来触发RDB生成快照、与AOF重写；</p></li><li><p>控制Redis最大使用内存，防止fork耗时过长；</p></li><li><p>使用更牛逼的硬件；</p></li><li><p>合理配置Linux的内存分配策略，避免因为物理内存不足导致fork失败。<br>:::<br>:::tips<br><strong>线上部署经验：</strong></p></li><li><p>如果Redis中的数据并不是特别敏感或者可以通过其它方式重写生成数据，可以关闭持久化，如果丢失数据可以通过其它途径补回；</p></li><li><p>自己制定策略定期检查Redis的情况，然后可以手动触发备份、重写数据；</p></li><li><p>单机如果部署多个实例，要防止多个机器同时运行持久化、重写操作，防止出现内存、CPU、IO资源竞争，让持久化变为串行；</p></li><li><p>可以加入主从机器，利用一台从机器进行备份处理，其它机器正常响应客户端的命令；</p></li><li><p>RDB持久化与AOF持久化可以同时存在，配合使用。<br>:::</p></li></ul><h1 id="5、事务⭐"><a href="#5、事务⭐" class="headerlink" title="5、事务⭐"></a>5、事务⭐</h1><p><a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-trans.html">Redis进阶 - 事务：Redis事务详解</a></p><ul><li>具体示例看上门文章！<blockquote><p>Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p></blockquote></li></ul><p>总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p><h2 id="5-1-事务命令"><a href="#5-1-事务命令" class="headerlink" title="5.1 事务命令"></a>5.1 事务命令</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>简述</strong></th></tr></thead><tbody><tr><td>multi</td><td><strong>开启事务，</strong>redis会将后续的命令逐个放入队列中，然后使用EXEC命令来原子化执行这个命令系列</td></tr><tr><td>exec</td><td><strong>执行事务</strong>中的所有操作命令</td></tr><tr><td>discard</td><td><strong>取消事务</strong>，放弃执行事务块中的所有命令</td></tr><tr><td>watch</td><td><strong>监视</strong>一个或多个key,如果事务在执行前，这个key(或多个key)被其他命令修改，则事务被中断，不会执行事务中的任何命令</td></tr><tr><td>unwatch</td><td><strong>取消监视</strong>对所有key的监视</td></tr></tbody></table><p>watch的key在multi和exec过程中不能被修改，否则exec后回滚</p><ol><li><strong>执行流程：</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696471620362-ae985f74-8d16-411b-857f-4783def3b4c8.png#averageHue=%23f4f4f4&clientId=ua6f20139-3665-4&from=drop&id=MJFgy&originHeight=389&originWidth=555&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=16928&status=done&style=none&taskId=u7d498b2a-4a7f-4ce1-bcb4-33efaaf439c&title=" alt="db-redis-trans-2.png"></p><ol start="2"><li><strong>事务出现错误的处理：</strong></li></ol><ul><li><strong>语法错误（编译器错误）：</strong>在开启事务后，修改k1值为11，k2值为22，但k2语法错误，最终导致事务提交失败，k1、k2保留原值（回滚）</li><li><strong>运行时错误：</strong>在开启事务后，修改k1值为11，k2值为22，但将k2的类型作为List，在运行时检测类型错误，最终导致事务提交失败，此时事务并没有回滚，而是跳过错误命令继续执行， 结果k1值改变、k2保留原值</li></ul><ol start="3"><li><strong>Redis事务执行步骤</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696472042418-40dd31a4-e1d3-4c0c-a7c4-c72696664bed.png#averageHue=%23f6f6f6&clientId=ua6f20139-3665-4&from=drop&height=446&id=u8bffbbea&originHeight=711&originWidth=681&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=37200&status=done&style=none&taskId=u9ad2eb23-a69c-4fa6-a79e-eea0c713459&title=&width=427" alt="db-redis-trans-1.png"></p><ul><li><strong>开启：</strong>以MULTI开始一个事务</li><li><strong>入队：</strong>将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面</li><li><strong>执行：</strong>由EXEC命令触发事务</li></ul><h2 id="5-2-深层理解-面试题"><a href="#5-2-深层理解-面试题" class="headerlink" title="5.2 深层理解&#x2F;面试题"></a>5.2 深层理解&#x2F;面试题</h2><ol><li><strong>为什么 Redis 不支持回滚？</strong><blockquote><p>为什么 Redis 在事务失败时不进行回滚，而是继续执行余下的命令</p></blockquote></li></ol><p><strong>优点：</strong></p><ul><li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li><li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li></ul><ol start="2"><li><strong>Redis的事务ACID</strong></li></ol><ul><li><strong>原子性atomicity：</strong>运行期的错误是不会回滚的，<strong>Redis的事务是原子性的：所有的命令，要么全部执行，要么全部不执行</strong>。而不是完全成功。</li><li><strong>一致性consistency：</strong>redis事务可以保证命令失败的情况下得以回滚，数据能恢复到没有执行之前的样子，是保证一致性的，除非redis进程意外终结。</li><li><strong>隔离性Isolation：</strong>redis事务是严格遵守隔离性的，原因是redis是单进程单线程模式(v6.0之前），可以保证命令执行过程中不会被其他客户端命令打断。但是，Redis不像其它结构化数据库有隔离级别这种设计。</li><li><strong>持久性Durability</strong></li></ul><p><strong>redis事务是不保证持久性的</strong>，这是因为redis持久化策略中不管是RDB还是AOF都是异步执行的，不保证持久性是出于对性能的考虑。</p><h1 id="6、订阅-发布"><a href="#6、订阅-发布" class="headerlink" title="6、订阅&#x2F;发布"></a>6、订阅&#x2F;发布</h1><p>Redis 发布订阅(pub&#x2F;sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。<br><img src="https://cdn.nlark.com/yuque/0/2023/svg/35382725/1696330572410-d268f51e-4e0b-4b18-a840-08462b4f69b1.svg#clientId=u0e2b69ca-e6a6-4&from=drop&id=uff6bdb13&originHeight=275&originWidth=309&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=4122&status=done&style=none&taskId=u1921ca0a-1e17-4b35-8e53-f09169f07ad&title=" alt="db-redis-sub-2.svg"><br>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：client2 、 client5 和 client1<br>:::tips<br>Redis有两种发布&#x2F;订阅模式：</p><ul><li>基于频道(Channel)的发布&#x2F;订阅</li><li>基于模式(Pattern)的发布&#x2F;订阅<br>:::</li></ul><h2 id="6-1-Channel-频道"><a href="#6-1-Channel-频道" class="headerlink" title="6.1 Channel 频道"></a>6.1 Channel 频道</h2><p>“发布&#x2F;订阅”模式包含两种角色，分别是发布者和订阅者。发布者可以向指定的频道(channel)发送消息; 订阅者可以订阅一个或者多个频道(channel),所有订阅此频道的订阅者都会收到此消息。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696331124200-9f795f88-8aa2-4fb7-94c5-163bfa2f8bb7.png#averageHue=%23f0f0f0&clientId=u0e2b69ca-e6a6-4&from=drop&id=ufef1976e&originHeight=408&originWidth=1344&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=51413&status=done&style=none&taskId=uebcd7b5d-69c1-488d-878a-09011e1cd1d&title=" alt="db-redis-sub-8.png"></p><table><thead><tr><th><strong>命令</strong></th><th><strong>简述</strong></th><th><strong>使用</strong></th></tr></thead><tbody><tr><td>publish</td><td>发布者发布消息</td><td>publish [channel:1] [hi]</td></tr><tr><td>subscribe</td><td>订阅者订阅频道</td><td>subscribe [channel1] [channel2 …]</td></tr><tr><td>unsubscribe</td><td>订阅者取消订阅频道</td><td>unsubscribe [channel1] [channel2 …]</td></tr></tbody></table><p>关于<strong>订阅频道</strong>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; subscribe channel:1</span><br><span class="line">1) &quot;subscribe&quot; // 消息类型</span><br><span class="line">2) &quot;channel:1&quot; // 频道</span><br><span class="line">3) &quot;hi&quot; // 消息内容</span><br></pre></td></tr></table></figure><p><strong>消息类型</strong>的取值：</p><ul><li><strong>subscribe：</strong>第一个值表示<strong>订阅成功的反馈信息</strong>。第二个值是订阅成功的频道名称，第三个是当前客户端订阅的频道数量。</li><li><strong>message：</strong>第一个值表示<strong>接收到的消息</strong>，第二个值表示产生消息的频道名称，第三个值是消息的内容。</li><li><strong>unsubscribe：</strong>第一个值表示<strong>成功取消订阅某个频道</strong>。第二个值是对应的频道名称，第三个值是当前客户端订阅的频道数量，当此值为0时客户端会退出订阅状态，之后就可以执行其他非”发布&#x2F;订阅”模式的命令了。</li></ul><h2 id="6-2-Pattern-模式"><a href="#6-2-Pattern-模式" class="headerlink" title="6.2 Pattern 模式"></a>6.2 Pattern 模式</h2><ul><li>用图例解释什么是基于模式的发布订阅：</li></ul><p>下图展示了一个带有频道和模式的例子， 其中 tweet.shop.* 模式匹配了 tweet.shop.kindle 频道和 tweet.shop.ipad 频道， 并且有不同的客户端分别订阅它们三个：<br><img src="https://cdn.nlark.com/yuque/0/2023/svg/35382725/1696332013355-381b4506-d507-4111-bf26-428c92aeb777.svg#clientId=u0e2b69ca-e6a6-4&from=drop&id=u77dc6549&originHeight=293&originWidth=869&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=8199&status=done&style=none&taskId=u65146414-d82a-4076-9673-7b04058949a&title=" alt="db-redis-sub-5.svg"><br>如果接收到信息的是频道 tweet.shop.ipad ， 那么 client123 和 client256 同样会收到信息：<br><img src="https://cdn.nlark.com/yuque/0/2023/svg/35382725/1696332027870-876bda4b-586d-4152-9e15-b91270a5fc92.svg#clientId=u0e2b69ca-e6a6-4&from=drop&id=u2e50d1a9&originHeight=392&originWidth=869&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=8979&status=done&style=none&taskId=ua5cf41c7-2cf2-477c-aaa9-e29f64c1d0e&title=" alt="db-redis-sub-7.svg"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">psubscribe c? b* d?*</span><br><span class="line"></span><br><span class="line">通配符规则：</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">？ —&gt; 1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">*  —&gt; 0~无限</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">？* —&gt; 1~无限</span></span><br></pre></td></tr></table></figure><ul><li>注：命令跟Channel频道一样<table><thead><tr><th><strong>命令</strong></th><th><strong>简述</strong></th><th><strong>使用</strong></th></tr></thead><tbody><tr><td>publish</td><td>发布者发布消息</td><td>publish [channel:1] [hi]</td></tr><tr><td>subscribe</td><td>订阅者订阅频道</td><td>subscribe [channel1] [channel2 …]</td></tr><tr><td>unsubscribe</td><td>订阅者取消订阅频道</td><td>unsubscribe [channel1] [channel2 …]</td></tr></tbody></table></li></ul><h1 id="7、集群⭐"><a href="#7、集群⭐" class="headerlink" title="7、集群⭐"></a>7、集群⭐</h1><p><a href="https://zhuanlan.zhihu.com/p/349241304">16张图带你吃透Redis架构演进</a></p><h2 id="7-1-主从复制"><a href="#7-1-主从复制" class="headerlink" title="7.1 主从复制"></a>7.1 主从复制</h2><p><strong>概述：</strong>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。<br>:::tips<br><strong>主从复制的作用</strong>主要包括：</p><ul><li><p><strong>数据冗余</strong>：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</p></li><li><p><strong>故障恢复</strong>：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</p></li><li><p><strong>负载均衡</strong>：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</p></li><li><p><strong>高可用基石</strong>：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。<br>:::<br>主从库之间采用的是<strong>读写分离</strong>的方式。</p></li><li><p>读操作：主库、从库都可以接收；</p></li><li><p>写操作：首先到主库执行，然后，主库将写操作同步给从库。</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696472913490-b679ccc4-1fd0-4811-8683-d4c4234bf925.png#averageHue=%23eff8e5&clientId=ua6f20139-3665-4&from=drop&id=u9d56b56c&originHeight=358&originWidth=1046&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=15597&status=done&style=none&taskId=uebe64e75-366c-41fb-8083-8ce1c74988a&title=" alt="db-redis-copy-1.png"><br>:::tips</p><ul><li><strong>全量（同步）复制：</strong>比如第一次同步时</li><li><strong>增量（同步）复制：</strong>只会把主从库网络断连期间主库收到的命令，同步给从库<br>:::</li></ul><ol><li><p><strong>全量复制：</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从数据库 连接 主数据库</span></span><br><span class="line">replicaof 172.16.19.3 6379</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/35382725/1696473373094-3ca3d879-a570-4887-a036-33d72a0b7eb5.jpeg#averageHue=%23eff5e6&clientId=ua6f20139-3665-4&from=drop&id=u2cca9bbd&originHeight=1676&originWidth=3765&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=214493&status=done&style=none&taskId=u2087f755-26db-435e-94f2-3fb67a22a13&title=" alt="db-redis-copy-2.jpg"></p></li><li><p><strong>增量复制：</strong></p></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/35382725/1696473474966-20f34d3e-9c54-4894-a11b-0db3063d0ea5.jpeg#averageHue=%23eff4e5&clientId=ua6f20139-3665-4&from=drop&id=u916c4177&originHeight=1689&originWidth=3328&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=164817&status=done&style=none&taskId=u4cb395c9-392a-43a4-92d2-156b95291a1&title=" alt="db-redis-copy-3.jpg"></p><ul><li>replication buffer 和 repl_backlog_buffer</li></ul><h2 id="7-2-哨兵模式"><a href="#7-2-哨兵模式" class="headerlink" title="7.2 哨兵模式"></a>7.2 哨兵模式</h2><p>:::tips</p><ol><li><p>哨兵集群组建</p></li><li><p>主库下线判定</p></li><li><p>哨兵集群选举</p></li><li><p>新主库选举</p></li><li><p>主库故障转移<br>:::<br>概述：哨兵机制（Redis Sentinel）是实现<strong>主从库自动切换</strong>的关键机制，它有效地解决了主从复制模式下<strong>故障转移</strong>的问题</p></li><li><p><strong>哨兵集群组建</strong></p></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/35382725/1696474816979-ea6a2c39-b61b-4cd5-9f8f-506082ce6294.jpeg#averageHue=%23f8f5e6&clientId=ua6f20139-3665-4&from=drop&id=ud466e6d5&originHeight=1535&originWidth=2822&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=118248&status=done&style=none&taskId=u5a4defaa-eafd-41a8-a398-083da8d1757&title=" alt="db-redis-sen-6.jpg"><br> 在主从集群中，主库上有一个名为__sentinel__:hello的频道，不同哨兵就是通过它来相互发现，实现互相通信的。在下图中，哨兵 1 把自己的 IP（172.16.19.3）和端口（26579）发布到__sentinel__:hello频道上，哨兵 2 和 3 订阅了该频道。那么此时，哨兵 2 和 3 就可以从这个频道直接获取哨兵 1 的 IP 地址和端口号。然后，哨兵 2、3 可以和哨兵 1 建立网络连接。<strong>（发布订阅模式）</strong></p><ul><li><strong>哨兵集群监控的逻辑图：</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696474865995-b94bc97a-472b-4f40-a1a5-44997812cbed.png#averageHue=%23a89578&clientId=ua6f20139-3665-4&from=drop&id=u0dc636d4&originHeight=491&originWidth=673&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=12543&status=done&style=none&taskId=u80384026-f872-44ee-9adc-50e454b4e74&title=" alt="db-redis-sen-1.png"></p><ul><li><strong>监控（Monitoring）</strong>：哨兵会不断地检查主节点和从节点是否运作正常。</li><li><strong>自动故障转移（Automatic failover）</strong>：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。</li><li><strong>配置提供者（Configuration provider）</strong>：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。</li><li><strong>通知（Notification）</strong>：哨兵可以将故障转移的结果发送给客户端。</li></ul><ol start="2"><li><strong>主库下线判定</strong></li></ol><ul><li><strong>主观下线：</strong>任何一个哨兵都是可以监控探测，并作出Redis节点下线的判断；</li><li><strong>客观下线：</strong>有哨兵集群共同决定Redis节点是否下线；</li></ul><p>当某个哨兵（如下图中的哨兵2）判断主库“主观下线”后，就会给其他哨兵发送 is-master-down-by-addr 命令。接着，其他哨兵会根据自己和主库的连接情况，做出 Y 或 N 的响应，Y 相当于赞成票，N 相当于反对票。<br>如果赞成票数（这里是2）是大于等于哨兵配置文件中的** quorum 配置项**（比如这里如果是quorum&#x3D;2）, 则可以判定主库客观下线了。</p><ol start="3"><li><strong>哨兵集群选举</strong></li></ol><p>哨兵的选举机制其实很简单，就是一个<strong>Raft选举算法：</strong> 选举的票数大于等于<strong>num(sentinels)&#x2F;2+1</strong>时，将成为领导者，如果没有超过，继续选举<br>任何一个想成为 Leader 的哨兵，要满足两个条件：</p><ul><li>拿到半数以上的赞成票；</li><li>拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。<br>:::tips<br>这里很多人会搞混 <strong>判定客观下线</strong> 和 <strong>是否能够主从切换（用到选举机制）</strong> 两个概念，我们再看一个例子。<br>Redis 1主4从，5个哨兵，哨兵配置quorum为2，如果3个哨兵故障，当主库宕机时，哨兵能否判断主库“客观下线”？能否自动切换？<br>经过实际测试：<br>1、哨兵集群可以判定主库“主观下线”。由于quorum&#x3D;2，所以当一个哨兵判断主库“主观下线”后，询问另外一个哨兵后也会得到同样的结果，2个哨兵都判定“主观下线”，达到了quorum的值，因此，<strong>哨兵集群可以判定主库为“客观下线”</strong>。<br>2、<strong>但哨兵不能完成主从切换</strong>。哨兵标记主库“客观下线后”，在选举“哨兵领导者”时，一个哨兵必须拿到超过多数的选票(5&#x2F;2+1&#x3D;3票)。但目前只有2个哨兵活着，无论怎么投票，一个哨兵最多只能拿到2票，永远无法达到N&#x2F;2+1选票的结果。<br>:::</li></ul><ol start="4"><li><strong>新主库选举</strong></li></ol><p>主库既然判定客观下线了，那么如何从剩余的从库中选择一个新的主库呢？</p><ul><li>过滤掉不健康的（下线或断线），没有回复过哨兵ping响应的从节点</li><li>选择salve-priority从节点优先级最高（redis.conf）的</li><li>选择复制偏移量最大，只复制最完整的从节点</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/35382725/1696475494001-3af4f82a-9854-43b7-972c-dd13c4330912.jpeg#averageHue=%23e9e6d8&clientId=u682cf368-7b9e-4&from=drop&id=uabd29b8e&originHeight=1743&originWidth=3671&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=135216&status=done&style=none&taskId=uea405e55-04c3-405f-a3ab-d2561f77e26&title=" alt="db-redis-sen-3.jpg"></p><ol start="5"><li><strong>主库故障转移：</strong></li></ol><p>假设：判断主库客观下线了，同时选出sentinel 3是哨兵leader<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696475573882-accf9b40-350b-4903-b191-311bee7b350a.png#averageHue=%23fcfcfb&clientId=u682cf368-7b9e-4&from=drop&id=u213ccbec&originHeight=293&originWidth=569&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=18529&status=done&style=none&taskId=uc82937ad-e398-440e-8152-bbcc949f7b5&title=" alt="db-redis-sen-4.png"><br>将slave-1脱离原从节点（PS: 5.0 中应该是replicaof no one)，升级主节点，将从节点slave-2指向新的主节点通知客户端主节点已更换将原主节点（oldMaster）变成从节点，指向新的主节点<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696475597506-e0a1f1a1-5f8c-4d91-a7bf-5c88f612a475.png#averageHue=%23c8bbad&clientId=u682cf368-7b9e-4&from=drop&id=ua419bf69&originHeight=293&originWidth=558&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=12386&status=done&style=none&taskId=ue3a3516b-1cc7-4dd9-a100-ab3f371cd60&title=" alt="db-redis-sen-5.png"></p><h2 id="7-3-分片技术"><a href="#7-3-分片技术" class="headerlink" title="7.3 分片技术"></a>7.3 分片技术</h2><p><a href="/md/db/nosql-redis/db-redis-x-copy.html">主从复制</a>和<a href="/md/db/nosql-redis/db-redis-x-sentinel.html">哨兵机制</a>保障了高可用，就读写分离而言虽然slave节点扩展了主从的读并发能力，但是<strong>写能力</strong>和<strong>存储能力</strong>是无法进行扩展，就只能是master节点能够承载的上限。如果面对海量数据那么必然需要构建master（主节点分片)之间的集群，同时必然需要吸收高可用（主从复制和哨兵机制）能力，即每个master分片节点还需要有slave节点，这是分布式系统中典型的纵向扩展（集群的分片技术）的体现；所以在Redis 3.0版本中对应的设计就是Redis Cluster。<br><a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-cluster.html">Redis进阶 - 高可拓展：分片技术（Redis Cluster）详解</a></p><h2 id="7-4-缓存穿透-雪崩"><a href="#7-4-缓存穿透-雪崩" class="headerlink" title="7.4 缓存穿透&#x2F;雪崩"></a>7.4 缓存穿透&#x2F;雪崩</h2><p>:::tips</p><ul><li>缓存穿透</li><li>缓存穿击</li><li>缓存雪崩</li><li>缓存污染（&#x2F;满）<ul><li>最大缓存设置</li><li>缓存淘汰机制</li></ul></li><li>缓存和数据库一致性<ul><li>4种相关模式</li><li>方案：队列+重试机制</li><li>方案：异步更新缓存（基于订阅binlog的同步机制）<br> :::</li></ul></li></ul><ol><li><strong>缓存穿透：</strong></li></ol><p>缓存穿透是指<strong>缓存和数据库中都没有的数据</strong>，而用户不断发起请求。由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。<br>在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。<br>:::tips</p><ul><li><strong>解决方案</strong></li></ul><ol><li><p>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截；</p></li><li><p>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</p></li><li><p>布隆过滤器。bloomfilter就类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小<br>:::</p></li><li><p><strong>缓存击穿</strong></p></li></ol><p>缓存击穿是指<strong>缓存中没有但数据库中有的数据</strong>（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。<br>:::tips</p><ul><li><strong>解决方案</strong></li></ul><ol><li><p>设置热点数据永远不过期。</p></li><li><p>接口限流与熔断，降级。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些服务不可用时候，进行熔断，失败快速返回机制。</p></li><li><p>加互斥锁（X锁）<br>:::</p></li><li><p><strong>缓存雪崩</strong></p></li></ol><p>缓存雪崩是指缓存中<strong>数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机</strong>。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。<br>:::tips</p><ul><li><strong>解决方案</strong></li></ul><ol><li><p>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</p></li><li><p>如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。</p></li><li><p>设置热点数据永远不过期。<br>:::</p></li><li><p><strong>缓存污染（&#x2F;满）</strong></p></li></ol><p>缓存污染问题说的是缓存中一些只会被访问一次或者几次的的数据，被访问完后，再也不会被访问到，但这部分数据依然留存在缓存中，消耗缓存空间。<br>缓存污染会随着数据的持续增加而逐渐显露，随着服务的不断运行，缓存中会存在大量的永远不会再次被访问的数据。缓存空间是有限的，如果缓存空间满了，再往缓存里写数据时就会有额外开销，影响Redis性能。这部分额外开销主要是指写的时候判断淘汰策略，根据淘汰策略去选择要淘汰的数据，然后进行删除操作。<br>:::tips</p><ul><li>最大缓存设置多大</li></ul><p>系统的设计选择是一个权衡的过程：大容量缓存是能带来性能加速的收益，但是成本也会更高，而小容量缓存不一定就起不到加速访问的效果。一般来说，<strong>我会建议把缓存容量设置为总数据量的 15% 到 30%，兼顾访问性能和内存空间开销</strong>。<br>对于 Redis 来说，一旦确定了缓存最大容量，比如 4GB，你就可以使用下面这个命令来设定缓存的大小了：<br>:::</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CONFIG SET maxmemory 4gb</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>缓存和数据库一致性</strong></li></ol><p><strong>节选最最常用的Cache Aside Pattern, 总结来说就是</strong></p><ul><li><strong>读的时候</strong>，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696493557293-48bddf13-5f5f-44fd-a6db-e62a9f07931a.png#averageHue=%23f8f8f8&clientId=u682cf368-7b9e-4&from=drop&id=u781e460a&originHeight=188&originWidth=600&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=16678&status=done&style=none&taskId=u2c59ac5b-5e2b-4d69-95d6-9f9e0ebfdfa&title=" alt="db-redis-cache-2.png"></p><ul><li><strong>更新的时候</strong>，先更新数据库，然后再删除缓存。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696493561005-be943958-96b0-4e53-a5ae-689b107dc95a.png#averageHue=%23fafafa&clientId=u682cf368-7b9e-4&from=drop&id=u7cec4719&originHeight=186&originWidth=600&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=15375&status=done&style=none&taskId=u67e22382-5e91-4463-99da-eb48bfd0c18&title=" alt="db-redis-cache-3.png"><br>其具体逻辑如下：</p><ul><li><strong>失效</strong>：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li><li><strong>命中</strong>：应用程序从cache中取数据，取到后返回。</li><li><strong>更新</strong>：先把数据存到数据库中，成功后，再让缓存失效。</li></ul><h1 id="8、性能调优-场景"><a href="#8、性能调优-场景" class="headerlink" title="8、性能调优&#x2F;场景"></a>8、性能调优&#x2F;场景</h1><p><a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-performance.html">Redis进阶 - 性能调优：Redis性能调优详解</a><br>:::tips</p><ul><li>Redis真的变慢了吗？</li><li>使用复杂度过高的命令</li><li>操作bigkey</li><li>集中过期</li><li>实例内存达到上限</li><li>fork耗时严重</li><li>开启内存大页</li><li>开启AOF</li><li>绑定CPU</li><li>使用Swap</li><li>碎片整理</li><li>网络带宽过载<br>:::</li></ul><h1 id="9、面试题"><a href="#9、面试题" class="headerlink" title="9、面试题"></a>9、面试题</h1><p><a href="https://pdai.tech/md/db/nosql-redis/db-redis-y-weibo.html">Redis大厂经验 - 微博：万亿级日访问量下，Redis在微博的9年优化历程</a><br>Redis在微博内部分布在各个应用场景，比如像现在春晚必争的“红包飞”活动，还有像粉丝数、用户数、阅读数、转评赞、评论盖楼、广告推荐、负反馈、音乐榜单等等都有用到Redis。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696494153439-0db68f0e-97a7-452e-adec-b80e950899bd.png#averageHue=%23fdfefc&clientId=u682cf368-7b9e-4&from=drop&id=u6fd8f143&originHeight=742&originWidth=1080&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=99516&status=done&style=none&taskId=u1b779d61-d208-49e5-b917-bc96ef718b0&title=" alt="db-redis-x-weibo-2.png"><br><a href="https://pdai.tech/md/db/nosql-redis/db-redis-z-mianshi.html">Redis面试 - redis问题总结</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://pdai.tech/md/db/nosql-redis/db-redis-overview.html&quot;&gt;♥Redis教程 - Redis知识体系详解♥&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;1、概念和基础&quot;&gt;&lt;a href=&quot;#1、概念和基础&quot; </summary>
      
    
    
    
    
    <category term="redis" scheme="http://example.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="http://example.com/2024/01/18/MySQL/"/>
    <id>http://example.com/2024/01/18/MySQL/</id>
    <published>2024-01-18T02:58:42.405Z</published>
    <updated>2024-01-18T03:28:33.952Z</updated>
    
    <content type="html"><![CDATA[<ul><li>面试题：<a href="https://blog.csdn.net/qq_30999361/article/details/124506169">MySQL面试题（40道含答案）</a></li></ul><p><a href="https://blog.csdn.net/adminpd/article/details/122910606">MySQL数据库面试题总结（2022最新版）</a></p><h1 id="1、SQL基础概念"><a href="#1、SQL基础概念" class="headerlink" title="1、SQL基础概念"></a>1、SQL基础概念</h1><h2 id="1-1-基本概述"><a href="#1-1-基本概述" class="headerlink" title="1.1 基本概述"></a>1.1 基本概述</h2><ol><li><strong>SQL语法体系</strong><br>:::tips</li></ol><ul><li><strong>数据查询语言（DQL）</strong>：select</li><li><strong>数据操作语言（DML）</strong>：delete、insert、update</li><li><strong>数据定义语言（DDL）</strong>：create、drop、alter、truncate</li><li><strong>数据控制语言（DCL）</strong>：grant，revoke，commit，rollback<br>:::</li></ul><ol start="2"><li><p><strong>SQL语法编写规则</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># DQL</span><br><span class="line">(9)select...(10)distinct...</span><br><span class="line">(6)ARG_FUNC(column or expression)</span><br><span class="line">(1)from...</span><br><span class="line">(3)join...(2)on...</span><br><span class="line">(4)where...</span><br><span class="line">(5)group by...</span><br><span class="line">(7)with...(ROLLUP/CUBE)</span><br><span class="line">(8)having...</span><br><span class="line">(11)order by...(ASC/DESC)</span><br><span class="line">(12)limit...</span><br><span class="line">union...</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># DML</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tablename(xx,xx) <span class="keyword">values</span>(<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tablename <span class="keyword">where</span> 条件;</span><br><span class="line"><span class="keyword">update</span> tablename <span class="keyword">set</span> 字段名<span class="operator">=</span>值 <span class="keyword">where</span> 条件;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># DDL</span><br><span class="line">create table 表名(</span><br><span class="line">字段名1 数据类型 [约束], </span><br><span class="line">字段名2 数据类型 [约束], </span><br><span class="line">字段名3 数据类型 [约束]</span><br><span class="line">);</span><br><span class="line">drop table if exists tablename; # 清空数据，并删除表结构</span><br><span class="line">alter table tablename modify column column1 VARCHAR(100); # 修改列</span><br><span class="line">truncate table tablename; # 清空数据，不删除表结构</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># DCL</span><br><span class="line">grant privileges on tablename to user@host [with grant option];</span><br><span class="line">revoke privileges on tablename from user@host;</span><br></pre></td></tr></table></figure></li><li><p><strong>8种基本数据类型</strong></p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>varchar(255)</td><td>【可变长度的字符串】优点：节省空间；缺点：需要动态分配空间，速度慢</td></tr><tr><td>char(255)</td><td>【定长字符串】优点：不需要动态分配空间，速度快；缺点：使用不当可能会导致空间的浪费</td></tr><tr><td>int(11)</td><td>【数字中的整数型。等同于java的int】</td></tr><tr><td>bigint</td><td>【数字中的长整型。等同于java中的long】</td></tr><tr><td>float</td><td>【单精度浮点型数据】</td></tr><tr><td>double</td><td>【双精度浮点型数据】</td></tr><tr><td>date</td><td>%Y-%m-%d【短日期类型】</td></tr><tr><td>datetime</td><td>%Y-%m-%d %h:%i:%s;【长日期类型】</td></tr></tbody></table></li></ol><h2 id="1-2-体系架构"><a href="#1-2-体系架构" class="headerlink" title="1.2 体系架构"></a>1.2 体系架构</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/webp/35382725/1696136475802-2425fe31-986d-472a-82f4-b8072cf66b9a.webp#averageHue=%23ebeee1&clientId=u00942b2a-453e-4&from=drop&height=423&id=u08c0e6b7&originHeight=540&originWidth=720&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=28404&status=done&style=none&taskId=u44453968-5764-4d5f-ad55-88dc9459b59&title=&width=564" alt="v2-b29359b4bc5e849601c5df10a2a8e484_720w.webp"><br>MySQL 从整体来说还是 CS 架构，也就是由客户端（Client）和服务器端（Server）两大部分构成。这里主要分析服务器端架构。服务器端大体可以分为两部分：<strong>服务层</strong>和<strong>存储引擎层</strong>（二者的功能跟日常开发中的 Service 层和与 DAO 层的关系有点像，可以对比理解）。</p><h2 id="1-3-SQL的执行流程⭐"><a href="#1-3-SQL的执行流程⭐" class="headerlink" title="1.3 SQL的执行流程⭐"></a>1.3 SQL的执行流程⭐</h2><p><a href="https://mp.weixin.qq.com/s/q8f6eKBXa38OK-_636mqzQ">一条 SQL是如何执行的？</a><br><strong>SQL运行流程：</strong><br>:::tips<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1698580827104-765110a9-3389-4566-ac2f-4ad3fa6ca087.png#averageHue=%23ebebbc&clientId=ua1c2a9db-7e0f-4&from=paste&height=189&id=qsJ2C&originHeight=403&originWidth=918&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=107225&status=done&style=none&taskId=u9604748e-aa5c-4678-b0e9-51ecfd378fe&title=&width=430.6000061035156" alt="image.png"></p><ol><li>MySQL驱动（Druid、C3P0，DBCP）</li><li>数据库连接池 </li><li>SQL接口</li><li>查询解析器</li><li>查询优化器</li><li>执行器</li><li>存储引擎（INNODB、MYISAM）</li><li>Buffer Pool<ul><li>undo日志：记录数据被修改前的样子</li><li>redo日志：记录数据被修改后的样子</li><li>binlog日志：记录整个操作过程</li></ul></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696660518485-59e34218-bc7f-4723-ab54-8488929cd140.png#averageHue=%23f6e5e5&clientId=uff5592ff-7738-4&from=drop&height=259&id=j1F9f&originHeight=652&originWidth=1051&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=57549&status=done&style=none&taskId=u58090109-1fa3-4207-8197-2cece43cffd&title=&width=417.6000061035156" alt="640.png"><br>:::</p><ol><li>首先，其它编程语言通过SQL支持接口调用MySQL，MySQL收到请求后，会将该请求<strong>暂时放在连接池</strong>，并由管理服务与工具进行管理。</li><li>当该请求从等待队列进入到处理队列时，管理器会将该请求传给SQL接口，SQL接口接收到请求后，它会将请求进行hash处理并与缓存中的数据进行对比，如果匹配则通过<strong>缓存直接返回处理结果</strong>；</li><li><strong>否则，去文件系统查询</strong>：<ol><li>由SQL接口传给后面的<strong>解析器</strong>，解析器会判断SQL语句是否正确，若正确则将其转化为数据结构。</li><li>解析器处理完毕后，便将处理后的请求传给<strong>优化器</strong>，它会产生多种执行计划，最终数据库会<strong>选择最优的方案去执行</strong>。</li><li>确定最优执行计划后，SQL语句由<strong>执行器</strong>交给相应的<strong>存储引擎</strong>处理，存储引擎将会到文件系统中取得相应的数据，并原路返回。</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696557101288-b0ff748b-d6f1-4d56-a47c-e8e112f36b3b.png#averageHue=%23eeeebd&clientId=udaefc12e-09c8-4&from=drop&id=ud632c69c&originHeight=470&originWidth=1080&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=95028&status=done&style=none&taskId=ue0fb5cea-1679-4cf8-a960-3cdbc8f30c2&title=" alt="640.png"></p><ul><li>SQL接口 —&gt; SQL解析器 —&gt; SQL优化器 —&gt; 执行器 —&gt; 存储引擎</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696557307047-2f4e72ea-8a82-4ac2-bdec-2f997f1ab505.png#averageHue=%23f6e5e5&clientId=udaefc12e-09c8-4&from=drop&id=u5d3101eb&originHeight=652&originWidth=1051&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=57549&status=done&style=none&taskId=u9c1db560-635c-416e-996d-7ba35fd288b&title=" alt="640.png"></p><blockquote><p><strong>体系详解</strong></p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/500250022">10分钟了解MySQL体系构架、存储引擎和索引结构</a></p><ol><li><strong>连接层：</strong>提供了应用程序接入MySQL服务的接口。客户端与服务端建立连接，客户端发送SQL到服务端（比如：JDBC、ODBC、.NET…）</li><li><strong>管理工具和服务：</strong>系统管理和控制工具，例如备份恢复、MySQL复制、集群等</li><li><strong>连接池：</strong>由于每次建立连接需要消耗很多时间，连接池的作用就是将这些连接缓存下来，下次可以直接用已经建立好的连接，提升服务器性能</li><li><strong>SQL接口：</strong>接受用户的SQL命令，并且返回用户操作的结果</li><li><strong>解析器：</strong>SQL命令传递到解析器的时候会被分析器验证和解析，MySQL是一个DBMS（数据库管理系统），没法直接理解SQL语句，Parser负责对SQL语句进行解析好让DBMS知道该怎么做</li><li><strong>优化器：</strong>SQL语句在查询之前会使用查询优化器对查询进行优化。它使用的是<strong>“选取-投影-联接”</strong>策略进行查询以此选择一个最优的查询路径<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select uid,name from user where gender = 1;</span><br></pre></td></tr></table></figure></li></ol><ul><li>select 查询先根据 where 语句进行<strong>选取</strong>，而不是先将表全部查询出来以后再进行条件过滤</li><li>select查询先根据 uid 和 name 进行属性<strong>投影</strong>，而不是将属性全部取出以后再进行过滤</li><li>将这两个查询条件<strong>联接</strong>起来生成最终查询结果</li></ul><ol start="7"><li><strong>查询缓存：</strong>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等（MySQL8.0之后不支持）</li><li><strong>存储引擎层：</strong>负责数据的存储和读取，与数据库文件打交道。MySQL区别于其他数据库的最重要的一个特点就是插件式的表存储引擎，注意：<strong>存储引擎是基于表的</strong>。</li></ol><h2 id="1-4-数据库三范式"><a href="#1-4-数据库三范式" class="headerlink" title="1.4 数据库三范式"></a>1.4 数据库三范式</h2><ul><li>数据库三范式：<strong>⭐</strong><ul><li>第一范式：要求任何一张表<strong>必须有主键</strong>，每一个字段<strong>原子性不可再分</strong></li><li>第二范式：第一范式的基础上，要求所有非主键字段<strong>完全依赖</strong>主键，不要产生<strong>部分依赖</strong>（不能存在复合主键）</li><li>第三范式：第二范式的基础上，要求所有非主键字段<strong>直接依赖</strong>主键，不要产生<strong>传递依赖</strong></li></ul></li></ul><p>设计数据库表的时候，按照以上的范式进行，可以避免表中数据的冗余，空间的浪费。<br>:::tips</p><ul><li>一对一，外键唯一</li><li>一对多，两张表，多的表加外键</li><li>多对多，三张表，关系表两个键</li></ul><p>在实际的开发中，可能存在一张表字段太多，太庞大。这个时候要拆分表。<br>:::<br>数据库设计三范式是理论上的，实践和理论有的时候有偏差，最终的目的都是为了满足客户的需求，有的时候会拿冗余换执行速度，因为在sql当中，表和表之间连接次数越多，<strong>效率越低</strong>。（笛卡尔积）<br>有的时候可能会<strong>存在冗余</strong>，但是为了减少表的连接次数，这样做也是合理的，并且对于开发人员来说，sql语句的<strong>编写难度</strong>也会降低。</p><h1 id="2、SQL语法⭐"><a href="#2、SQL语法⭐" class="headerlink" title="2、SQL语法⭐"></a>2、SQL语法⭐</h1><h2 id="2-1-DQL-数据查询"><a href="#2-1-DQL-数据查询" class="headerlink" title="2.1 DQL(数据查询)"></a>2.1 DQL(数据查询)</h2><p>:::tips<br>DQL：数据查询语言（Data Query Language）</p><ol><li><p>条件查询、模糊查询</p></li><li><p>排序查询</p></li><li><p>单行处理函数⭐</p></li><li><p>分组查询⭐</p></li><li><p>连接查询</p></li><li><p>子查询 &#x2F; union联合查询<br>:::</p></li><li><p><strong>条件查询、模糊查询</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">desc dept; # 查询表中的数据结构</span><br><span class="line">where xx = &#x27;xx&#x27; # 等值查询</span><br><span class="line">where xx is not null # 判空查询</span><br><span class="line">where xx not in(800,5000) # 范围查询</span><br><span class="line">where xx between xxx and xxx  # 范围查询</span><br><span class="line">where ename like &#x27;%o_o%&#x27;; # like模糊查询</span><br><span class="line"># _ 表示匹配一个任意字符</span><br><span class="line"># % 表示匹配多个任意字符</span><br><span class="line"># \ 表示转义字符</span><br></pre></td></tr></table></figure></li><li><p><strong>排序查询</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">order by xx; # asc/desc/xx</span><br><span class="line">order by a,b; #先按a排序，再按b排序</span><br></pre></td></tr></table></figure></li><li><p><strong>单行处理函数⭐</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select lower(xx) from xx; # lower 转换小写</span><br><span class="line">select upper(xx) from xx; # upper 转换大写</span><br><span class="line">select xxx from xx where substr(xxx,1,1)=&#x27;x&#x27;; # substr 取子串</span><br><span class="line">select length(xx) from xx; # length 取长度 </span><br><span class="line">select concat(upper(xx),substr(xxx,1,1)) from xx; # concat 字符串的拼接</span><br><span class="line">select xxx from xx where xxx=trim(&#x27; x &#x27;); # trim 去空格</span><br><span class="line">select round(xx.xx,1) from xx; # round 四舍五入(保留一位小数,-1保留到十位)</span><br><span class="line">select round(rand()*100,0) from xx; # rand 生成随机数(一百以内的随机数)</span><br><span class="line">select xx,(xxx+ifnull(xxxx,0))*12 from xx; # ifnull 避免null参与运算(xxxx为null变为0)</span><br><span class="line">select xx,format(xx,&#x27;$999,999&#x27;) from xx; # format 格式化数字</span><br><span class="line"></span><br><span class="line"># case 语法</span><br><span class="line">case..when..then..when..then..else..end【模板】</span><br><span class="line"># 需求：当工作岗位是Manager时工资乘于1.1【老工资和新工资】</span><br><span class="line">select ename,job,sal oldsal,(case job </span><br><span class="line"> when &#x27;MANAGER&#x27; </span><br><span class="line"> then sal*1.1 </span><br><span class="line"> else sal </span><br><span class="line"> end)as newsal from emp;</span><br></pre></td></tr></table></figure></li><li><p><strong>分组函数⭐</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum(列名) 求和  　　　　</span><br><span class="line">max(列名) 最大值 　　　　</span><br><span class="line">min(列名) 最小值 　　　　</span><br><span class="line">avg(列名) 平均值 　　　　</span><br><span class="line">first(列名)   第一条记录   </span><br><span class="line">last(列名)    最后一条记录  </span><br><span class="line">count(列名)   统计记录数   注意和count(*)的区别</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># group by / having</span><br><span class="line"># 需求：</span><br><span class="line">找出每个岗位的平均工资，要求显示平均工资大于1500的，</span><br><span class="line">除manager岗位以外，要求按照平均工资降序排序。</span><br><span class="line">select job,avg(sal) from emp </span><br><span class="line">where job!=&#x27;manager&#x27; </span><br><span class="line">group by job </span><br><span class="line">having avg(sal)&gt;1500 </span><br><span class="line"></span><br><span class="line"># distinct</span><br><span class="line"># 需求：统计一下工作岗位的数量</span><br><span class="line">select count(distinct job) from emp;</span><br></pre></td></tr></table></figure></li><li><p><strong>连接查询</strong></p></li></ol><ul><li><p><strong>内连接（A、B平等，取交集）</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 等值连接(也可以用where，不建议)</span><br><span class="line">select a.xx,b.xx from a</span><br><span class="line">join b on a.xxx=b.xxx;</span><br><span class="line"></span><br><span class="line"># 非等值连接</span><br><span class="line">select a.xx,b.xx from a </span><br><span class="line">join b on a.xx between b.xxx and b.xxx;</span><br><span class="line"></span><br><span class="line"># 自连接(一张表看成两张表 a —&gt; b,c)</span><br><span class="line">select b.xx,c.xx</span><br><span class="line">from a b join a c on b.xx=c.xx;</span><br></pre></td></tr></table></figure></li><li><p><strong>外连接（A、B有主次关系）</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select a.xx,b.xx </span><br><span class="line">from a left/right join b</span><br><span class="line">on a.xxx = b.xxx;</span><br></pre></td></tr></table></figure></li><li><p><strong>多表联查</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select...from A表 </span><br><span class="line">join B表 on A与B的连接关系</span><br><span class="line">join C表 on A与C的连接关系</span><br><span class="line">join D表 left on A与D的连接关系(A为主表)</span><br></pre></td></tr></table></figure></li></ul><ol start="6"><li><strong>子查询 &#x2F; union联合查询</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 子查询</span><br><span class="line">select</span><br><span class="line">..(select)</span><br><span class="line">from </span><br><span class="line">..(select)</span><br><span class="line">where</span><br><span class="line">..(select)</span><br><span class="line"></span><br><span class="line"># union(优点：把乘法变成了加法运算)</span><br><span class="line">select xxx,xxxx from xx where xx=&#x27;aa&#x27;</span><br><span class="line">union</span><br><span class="line">select xxx,xxxx from xx where xx=&#x27;bb&#x27;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-2-DML-数据操作"><a href="#2-2-DML-数据操作" class="headerlink" title="2.2 DML(数据操作)"></a>2.2 DML(数据操作)</h2><p>:::tips<br>DML：数据操作语言（Data Manipulation Language）</p><ol><li><p>insert 插入数据</p></li><li><p>delete 删除数据<br>:::</p></li><li><p><strong>insert 插入数据</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 模板</span><br><span class="line">insert into tablename(xx,xx) values(&#x27;&#x27;,&#x27;&#x27;),(&#x27;&#x27;,&#x27;&#x27;),..;</span><br><span class="line"></span><br><span class="line"># insert插入日期:%Y-%m-%d-%h-%i-%s</span><br><span class="line"># 日期格式化：data_format</span><br><span class="line">select id,date_format(birth,&#x27;%m/%d/%Y&#x27;) </span><br><span class="line">  from user;</span><br><span class="line"># 获得当前时间：now()函数 —— datatime类型</span><br><span class="line">insert into user(id,create_time) </span><br><span class="line">values(2,now());</span><br></pre></td></tr></table></figure></li><li><p><strong>delete 删除数据</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 模板(没有条件，整张表的数据会全部删除！)</span><br><span class="line">delete from 表名 where 条件;</span><br><span class="line"></span><br><span class="line"># delete与truncate</span><br><span class="line">delete语句删除数据的原理？（delete属于DML语句！！！）</span><br><span class="line">表中的数据被删除了，但是这个数据在硬盘上的真实存储空间不会被释放！！！</span><br><span class="line">这种删除缺点是：删除效率比较低。</span><br><span class="line">这种删除优点是：支持回滚，后悔了可以再恢复数据！！！</span><br><span class="line">truncate语句删除数据的原理？（truncate属于DDL语句！）</span><br><span class="line">这种删除效率比较高，表被一次截断，物理删除。</span><br><span class="line">这种删除缺点：不支持回滚。</span><br><span class="line">这种删除优点：快速。</span><br><span class="line">用法：truncate table xxx; </span><br></pre></td></tr></table></figure></li><li><p><strong>update 修改数据</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 模板(没有条件限制会导致所有数据全部更新！)</span><br><span class="line">update 表名 set 字段名1=值1,字段名2=值2,... where 条件;</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-3-DDL-数据定义"><a href="#2-3-DDL-数据定义" class="headerlink" title="2.3 DDL(数据定义)"></a>2.3 DDL(数据定义)</h2><p>:::tips<br>DDL：数据定义语言（Data Definition Language）</p><ol><li><p>create 创建表</p></li><li><p>drop 删除表</p></li><li><p>alter 修改表</p></li><li><p>truncate 删除表数据<br>:::</p></li><li><p><strong>create 创建表</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 模板</span><br><span class="line">create table 表名(</span><br><span class="line">字段名1 数据类型 primary key, </span><br><span class="line">字段名2 数据类型 default &#x27;x&#x27;,  # 默认值</span><br><span class="line">字段名3 数据类型 not null,</span><br><span class="line">字段名4 数据类型 unique,</span><br><span class="line">constraint 字段名5 # 外键</span><br><span class="line">foreign key (字段名5)</span><br><span class="line">references other_table(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 复制全表和部分表</span><br><span class="line">create table b as select * from a;</span><br><span class="line">create table b as select xx,xxx from a where xx=&#x27;xx&#x27;;</span><br><span class="line"></span><br><span class="line"># 创建索引</span><br><span class="line">CREATE INDEX indexName ON table_name (column_name)</span><br></pre></td></tr></table></figure></li><li><p><strong>drop 删除表</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 模板</span><br><span class="line">drop table if exists tablename;</span><br><span class="line"></span><br><span class="line"># 删除索引</span><br><span class="line">drop index [indexName] ON tablename; </span><br></pre></td></tr></table></figure></li><li><p><strong>alter 修改表</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table mytable add column new_column INT; # add 添加列</span><br><span class="line">alter table mytable modify column column1 VARCHAR(100); # modify column 修改表中已存在列的定义(如数据类型、长度等)</span><br><span class="line">alter table mytable change old_column new_column VARCHAR(100); # change 修改列的名称</span><br><span class="line">alter table mytable add index idx_column1 (column1); # add index 添加一个新的索引</span><br><span class="line">alter table mytable add constraint pk_id primary key (id); # add constraint 添加一个新的约束(如主键约束、唯一性约束等)</span><br></pre></td></tr></table></figure></li><li><p><strong>truncate 删除表数据</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 模板</span><br><span class="line">truncate table table_name;</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-4-DCL-数据控制"><a href="#2-4-DCL-数据控制" class="headerlink" title="2.4 DCL(数据控制)"></a>2.4 DCL(数据控制)</h2><p>:::tips<br>DDL：数据定义语言（Data Definition Language）</p><ol><li><p>grant 授予权限</p></li><li><p>revoke 撤销权限<br>:::</p></li><li><p><strong>grant 授予权限</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 模板</span><br><span class="line">grant privileges on tablename to user@host [with grant option];</span><br><span class="line"></span><br><span class="line"># privileges：指定要授予的权限</span><br><span class="line">如 SELECT、INSERT、UPDATE、DELETE、CREATE、ALTER、DROP 等</span><br><span class="line"> 使用 ALL PRIVILEGES 表示授予所有权限</span><br><span class="line"># user@host：指定要授权的用户名和主机</span><br><span class="line">可以使用 ‘%’ 表示匹配任意主机</span><br><span class="line"># with grant option（可选）</span><br><span class="line">允许被授权的用户再次授予所获得的权限给其他用户。</span><br></pre></td></tr></table></figure></li><li><p><strong>revoke 撤销权限</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 模板</span><br><span class="line">revoke privileges on tablename from user@host;</span><br><span class="line"># 规则与grant一致</span><br></pre></td></tr></table></figure></li></ol><h1 id="3、索引"><a href="#3、索引" class="headerlink" title="3、索引"></a>3、索引</h1><h2 id="3-1-基本概念及使用"><a href="#3-1-基本概念及使用" class="headerlink" title="3.1 基本概念及使用"></a>3.1 基本概念及使用</h2><p>:::tips</p><ul><li><strong>概念：索引（index）</strong>是在数据库表的<strong>字段</strong>上添加，是查询优化最重要的手段</li><li><strong>索引的实现原理：</strong>缩小扫描范围，避免全表扫描（平衡搜索二叉树）<br>:::</li></ul><ol><li><strong>索引的概念及原理</strong></li></ol><ul><li><strong>MySQL在查询方面主要就是两种方式：</strong><ul><li>第一种方式：全表扫描（不建议）</li><li>第二种方式：根据<strong>索引检索</strong></li></ul></li><li><strong>什么条件下，我们会考虑给字段添加索引呢？</strong><ul><li>条件1：数据量庞大（到底有多么庞大算庞大，这个需要测试，因为每一个硬件环境不同）</li><li>条件2：该字段经常出现在where的后面，以条件的形式存在，也就是说这个字段总是被扫描。</li><li>条件3：该字段很少的DML(insert delete update)操作。（因为DML之后，索引需要重新排序。）</li></ul></li><li><strong>可以命中索引的关键字：where、join、order by、group by、having、union</strong></li></ul><ol start="2"><li><strong>MySQL索引的7个种类</strong><ul><li><p><strong>PRIMARY 主键索引：</strong>等于unique+not null</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name ADD PRIMARY KEY (column);</span><br></pre></td></tr></table></figure></li><li><p><strong>Normal 普通索引：</strong>大多数情况下都可以使用</p></li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name ADD INDEX index_name (column);</span><br></pre></td></tr></table></figure><ul><li><p><strong>Unique 唯一索引：</strong>表示唯一、不允许重复的索引（身份证），优先考虑</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name ADD UNIQUE (column);</span><br></pre></td></tr></table></figure></li><li><p><strong>Full Text 全文索引：</strong>为了快速检索大文本数据中的关键字的信息。字段长度比较大时，如果创建普通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引，<strong>基于倒排索引</strong>，类似于搜索引擎（ES）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name ADD FULLTEXT (column);</span><br></pre></td></tr></table></figure></li><li><p><strong>Prefix 前缀索引：</strong>在文本类型如BLOB、TEXT或者很长的VARCHAR列上创建索引时，可以使用前缀索引，数据量相比普通索引更小，可以指定索引列的长度，但是数值类型不能指定。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name ADD KEY(column_name(prefix_length));</span><br></pre></td></tr></table></figure></li><li><p>** Composite 组合索引：**指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀原则。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name ADD INDEX index_name (column1, column2, column3);</span><br></pre></td></tr></table></figure></li><li><p><strong>SPATIAL 空间索引：</strong>MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型。MySQL在空间索引这方面遵循OpenGIS几何数据模型规则。</p></li></ul><p>注意：唯一性比较弱的字段上添加索引用处不大。</p><ol start="3"><li><strong>创建索引的原则：</strong><ul><li>优先选择唯一性索引</li><li>为经常需要<strong>排序、分组</strong>和<strong>联合</strong>操作的字段建立索引（order by、group by、union）</li><li>为经常作为<strong>查询条件</strong>的字段建立索引（where、having）</li><li>尽量使用<strong>前缀索引</strong>（比如给身份证的前 10 位添加索引，不能在order by 或 group by出发前缀索引）</li><li>删除不再使用或者很少使用的索引，限制索引的数目</li><li>经常更新修改的字段不要建立索引（因为要重新建立索引表）</li><li>不推荐在同一列建多个索引（浪费空间、难以维护）</li></ul></li><li><strong>索引失效的五种情况：</strong><ul><li><strong>like 模糊查询：</strong>避免’%’开头，因为即使添加了索引，也不会走索引</li><li><strong>or 条件语句：</strong>如果使用or，那么要求or两边的条件字段都要有索引</li><li><strong>复合索引：</strong>使用复合索引的时候，没有使用左侧的列查找，索引失效（从左往右匹配列）</li><li><strong>where中索引进行运算：</strong>例：where sal+1&#x3D;800，索引失效</li><li><strong>where中索引列使用函数：</strong>例：where lower(ename) &#x3D; ‘smith’，索引失效</li></ul></li></ol><h2 id="3-2-分析索引⭐"><a href="#3-2-分析索引⭐" class="headerlink" title="3.2 分析索引⭐"></a>3.2 分析索引⭐</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建索引</span><br><span class="line">create index 索引名 on 表(字段);</span><br><span class="line"># 删除索引</span><br><span class="line">drop index 索引名 on 表;</span><br><span class="line"></span><br><span class="line"># 查看SQL语句是否用了索引来检索</span><br><span class="line">explain select * from 表 where 字段 = &#x27;xx&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696146872701-869c08cc-8af1-4210-9a5a-2135f1380d05.png#averageHue=%23f9eeec&clientId=u00942b2a-453e-4&from=paste&height=80&id=u60667997&originHeight=100&originWidth=956&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=8438&status=done&style=none&taskId=u7a7259d4-a1c0-4bde-87d8-208ee890526&title=&width=764.8" alt="image.png"><br><strong>分析索引的方法（explain）⭐</strong></p><ol><li><strong>type：</strong>该字段显示了连接类型，<strong>const&gt;ref&gt;fulltext&gt;range&gt;index&gt;all（越前查询性能越好）</strong><ul><li><strong>const：主键或唯一索引的等值查询扫描。</strong>最多只返回一行数据，查询速度非常快, 因为它仅仅读取一次</li><li><strong>ref：满足索引的最左前缀规则。</strong>或者索引不是主键也不是唯一索引时才会发生，如果使用的索引只会匹配到少量的行，性能也是不错的</li><li><strong>fulltext：全文索引。</strong></li><li><strong>range：范围扫描。</strong>表示检索了指定范围的行，主要用于有限制的索引扫描。比较常见的范围扫描是带有BETWEEN子句或WHERE子句里有&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、IS NULL、&lt;&#x3D;&gt;、BETWEEN、LIKE、IN()…</li><li><strong>index：全索引扫描。</strong>和ALL类似，只不过index是全盘扫描了索引的数据。当查询仅使用索引中的一部分列时，可使用此类型。</li><li><strong>ALL：全表扫描。</strong>性能最差。</li></ul></li><li><strong>key：MySQL使用的索引。</strong>如果是空的，表示没有使用索引，可能需要添加适当的索引来提高性能。</li><li><strong>rows：MySQL估算扫描的行数。</strong>数值越小越好。</li><li><strong>Extra：附加信息。</strong>例如是否使用了临时表、是否使用了文件排序等，可以帮助你找到潜在的性能问题。</li></ol><h2 id="3-3-Btree索引和hash索引"><a href="#3-3-Btree索引和hash索引" class="headerlink" title="3.3 Btree索引和hash索引"></a>3.3 Btree索引和hash索引</h2><p><a href="https://zhuanlan.zhihu.com/p/394429932">关于MySQL索引原理，讲的最清晰的一篇文章</a></p><ol><li><strong>B+树结构：</strong></li></ol><p><strong>原理：</strong>底层实现原理是多路平衡查找树，对于每一次的查询都是从根节点出发，查询到叶子节点方可以获得所查键值，最后查询判断是否需要回表查询。<br><img src="https://cdn.nlark.com/yuque/0/2023/webp/35382725/1696150355987-2d3a11d4-b0e0-4dba-b4b1-6e3f73a2bac2.webp#averageHue=%23d4d5b7&clientId=u00942b2a-453e-4&from=drop&id=u4745a1d0&originHeight=430&originWidth=720&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=28336&status=done&style=none&taskId=uc74b328a-abf0-4f0e-96fd-61e1480628f&title=" alt="v2-fc8a438223c64fbbc73fa3af64f908c7_720w.webp"><br><strong>B+树的特性：</strong>二叉搜索树的一种，但是他的数据仅仅存储在叶子节点（在这里就是数据页），像这种<strong>索引页+数据页</strong>组成的组成的B+树就是<strong>聚簇索引</strong>(这句话很重要)。</p><ul><li><strong>主键索引：聚簇索引</strong>是 MySQL 基于<strong>主键索引</strong>结构创建的</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/webp/35382725/1696151822432-aae5f08e-292d-4742-94e2-5cc6f68d7f00.webp#averageHue=%23f8f8f6&clientId=u00942b2a-453e-4&from=drop&height=314&id=u69b0a511&originHeight=354&originWidth=720&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=22302&status=done&style=none&taskId=u58c16c60-b0b3-400f-973d-30f73d5a724&title=&width=638" alt="v2-be022a075839126f7d3b1f11f56f8868_720w.webp"></p><ul><li><strong>非主键索引：</strong>叶子节点没包含数据表中行记录就是非聚簇索引（索引和数据是分开的）。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/webp/35382725/1696151844410-15090e13-888e-48a1-9aff-fb5f131c8023.webp#averageHue=%23fbfbfa&clientId=u00942b2a-453e-4&from=drop&height=253&id=u94f01bc4&originHeight=336&originWidth=805&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=16808&status=done&style=none&taskId=uf6c92128-e65e-4c54-953e-767931a1ab9&title=&width=606" alt="v2-c86e72fedbc859501b38cae600054e6d_720w.webp"></p><ul><li><strong>回表：</strong>根据非主键索引查询到的结果并没有查找的字段值，此时就需要再次根据主键从聚簇索引的根节点开始查找，这样再次查找到的记录才是完成的。<ul><li>假设查询语句： student 中还有除了name，age，id 其他的字段，虽然根据 name 很快的定位到了该条记录，但是因为 name+age 不是聚簇索引，此时的 B+ 树的数据页中存放的仅仅是自己关联的索引和主键索引字段，并不会存其他的字段，所以这个时候其他的属性值是获取不到的，这时候该怎么办？</li><li>这种情况下，MySQL 就需要进行<strong>回表查询</strong>了。此时 MySQL 就会根据定位到的某条记录中的 id 再次进行<strong>聚簇索引</strong>查找，也就是说会根据 id 去维护 id 的那么 B+ 树中查找。因为<strong>聚簇索引中数据页记录的是一条记录的完整的记录</strong>，这个过程就叫回表。</li></ul></li></ul><ol start="2"><li><strong>Hash结构：</strong></li></ol><p><strong>原理：</strong>底层就是 Hash 表，进行查询时调用 Hash 函数获取到相应的键值（对应地址），然后回表查询获得实际数据。【数组+链表结构】<br><img src="https://cdn.nlark.com/yuque/0/2023/webp/35382725/1696151534017-c51c0f0c-ffd0-4dd5-9f2d-e5efcbd83917.webp#averageHue=%23b3ddb2&clientId=u00942b2a-453e-4&from=drop&id=u3abfec6a&originHeight=300&originWidth=496&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=15388&status=done&style=none&taskId=u6347a500-6409-4434-8124-561ef3a6516&title=" alt="v2-0a03399cee5614aab4adb8520b3fb6c4_720w.webp"><br>由于Hash索引比较的是进行Hash运算之后的Hash值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的Hash算法处理之后的Hash值的大小关系，并不能保证和Hash运算前完全一样。</p><ol start="3"><li><strong>B+树索引和哈希索引对比⭐</strong></li></ol><ul><li><strong>等值查询：使用哈希索引。</strong>因为只需要经过一次算法即可找到相应的键值，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；</li><li><strong>范围查询：使用B+树索引。</strong>这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；</li><li><strong>排序：使用B+树索引。</strong>哈希索引也没办法利用索引完成，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；</li><li><strong>联合索引：使用B+树索引。</strong>哈希索引也不支持多列联合索引的最左匹配规则；</li><li><strong>关键字检索：使用B+树索引。</strong>B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。</li></ul><h1 id="4、存储"><a href="#4、存储" class="headerlink" title="4、存储"></a>4、存储</h1><h2 id="4-1-存储引擎"><a href="#4-1-存储引擎" class="headerlink" title="4.1 存储引擎"></a>4.1 存储引擎</h2><ul><li>存储引擎的存储是作用在<strong>table</strong>上的</li></ul><p><a href="https://zhuanlan.zhihu.com/p/500250022">10分钟了解MySQL体系构架、存储引擎和索引结构</a></p><ol><li><p><strong>主流的3种数据库存储引擎</strong></p><table><thead><tr><th></th><th><strong>INNODB</strong></th><th><strong>MYISAM</strong></th><th><strong>MEMORY</strong></th></tr></thead><tbody><tr><td><strong>概述</strong></td><td>索引采用B+树，聚簇索引结构，数据和索引在同个文件，叶子节点<strong>存储数据</strong></td><td>索引采用B+树，非聚簇索引结构，数据和索引分开存储，叶子节点<strong>存储数据地址引用</strong></td><td>索引采用Hash，将数据保存在内存中，通过哈希函数将<strong>键值映射到内存的特定地址</strong></td></tr><tr><td><strong>特点</strong></td><td></td><td></td><td></td></tr></tbody></table></li><li><p><strong>行级锁</strong></p></li><li><p><strong>查询&#x2F;插入效率低</strong></p></li><li><p><strong>支持事务</strong></p></li><li><p><strong>支持外键</strong><br> | </p></li><li><p><strong>表级锁</strong></p></li><li><p><strong>查询效率，插入效率高</strong></p></li><li><p><strong>存储空间较小</strong></p></li><li><p><strong>不支持事务，行级锁和外键约束</strong><br> | </p></li><li><p><strong>表级锁</strong></p></li><li><p><strong>查询效率高</strong></p></li><li><p><strong>不支持行级锁，数据有持久化问题、不安全</strong><br> |<br> | <strong>应用</strong> | MySQL5.5以后 | MySQL5.5之前 | Redis【RDB&#x2F;AOF】 |<br> | <strong>业务场景</strong> | 高并发、事务、数据经常修改（银行转账！） | 以查询、插入为主（博客、新闻门户） | 临时存数据，不要求安全性 |</p></li><li><p><strong>常用的存储引擎命令⭐</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW ENGINES  # 命令来查看MySQL提供的引擎</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLE STATUS LIKE &#x27;xx表&#x27;; # 查看数据表默认使用哪个引擎</span><br><span class="line">ALTER TABLE table_name ENGINE=InnoDB; # 更换表存储引擎</span><br></pre></td></tr></table></figure></li></ol><ul><li>若更换数据库的存储引擎的话，已存在的表存储引擎不会受到影响，新创建的存储引擎会受到影响。</li></ul><ol start="3"><li><strong>存储文件</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/webp/35382725/1696159826010-c19ee77f-8fe2-4712-a8e9-24dc3050dd2f.webp#averageHue=%23e4e7e4&clientId=u00942b2a-453e-4&from=drop&id=ai1nN&originHeight=126&originWidth=720&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=14478&status=done&style=none&taskId=u54d98d76-0339-4def-8540-657033dbea8&title=" alt="v2-c3db7a0871ff415695444c88ee00429d_720w.webp"></p><ul><li><strong>存储引擎为MyISAM：</strong><ul><li>*.frm：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等</li><li>*.MYD：MyISAM DATA，用于存储MyISAM表的数据</li><li>*.MYI：MyISAM INDEX，用于存储MyISAM表的索引相关信息</li></ul></li><li><strong>存储引擎为InnoDB：</strong><ul><li>*.frm：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等</li><li>*.ibd：InnoDB DATA，表数据和索引的文件。该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据</li></ul></li></ul><h2 id="4-2-InnoDB详解"><a href="#4-2-InnoDB详解" class="headerlink" title="4.2 InnoDB详解"></a>4.2 InnoDB详解</h2><p>InnoDB 是一个事务安全的存储引擎，它具备<strong>提交、回滚</strong>以及<strong>崩溃恢复的功能</strong>以保护用户数据。InnoDB 的<strong>行级别</strong>锁定保证数据一致性提升了它的多用户并发数以及性能。InnoDB 将用户数据存储在<strong>聚集索引</strong>中以减少基于主键的普通查询所带来的 I&#x2F;O 开销。为了保证数据的完整性，InnoDB 还支持<strong>外键约束</strong>。默认使用B+TREE数据结构存储索引。</p><ol><li><strong>特点</strong></li></ol><ul><li>支持事务，支持4个事务隔离（ACID）级别</li><li>行级锁定（更新时锁定当前行）</li><li>读写阻塞与事务隔离级别相关</li><li>既能缓存索引又能缓存数据</li><li>支持外键</li><li>InnoDB更消耗资源，读取速度没有MyISAM快</li><li>在InnoDB中存在着缓冲管理，通过缓冲池，将索引和数据全部缓存起来，加快查询的速度；</li><li>对于InnoDB类型的表，其数据的物理组织形式是聚簇表。所有的数据按照主键来组织。数据和索引放在一块，都位于B+数的叶子节点上；</li></ul><ol start="2"><li><strong>业务场景</strong></li></ol><ul><li>需要支持事务的场景（银行转账之类）</li><li>适合高并发，行级锁定对高并发有很好的适应能力，但需要确保查询是通过索引完成的</li><li>数据修改较频繁的业务</li></ul><ol start="3"><li><strong>InnoDB引擎调优</strong></li></ol><ul><li>主键尽可能小，否则会给Secondary index带来负担</li><li>避免全表扫描，这会造成锁表</li><li>尽可能缓存所有的索引和数据，减少IO操作</li><li>避免主键更新，这会造成大量的数据移动</li></ul><h1 id="5、事务"><a href="#5、事务" class="headerlink" title="5、事务"></a>5、事务</h1><p><a href="https://www.zhihu.com/tardis/zm/art/43493165?source_id=1005">深入理解数据库事务</a></p><h2 id="5-1-ACID原则⭐"><a href="#5-1-ACID原则⭐" class="headerlink" title="5.1 ACID原则⭐"></a>5.1 ACID原则⭐</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/webp/35382725/1685846651747-9b0ac948-810c-4cba-8af5-cd92f352ef19.webp#averageHue=%23f7ead6&clientId=u4eec948e-37ef-4&from=drop&height=270&id=Lr7wX&originHeight=322&originWidth=622&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=8602&status=done&style=none&taskId=u42189989-2d01-4011-b079-d60339e1378&title=&width=521" alt="v2-e350688eea0fb2c0859b7b8a3abec2c8_r.webp"><br>:::tips</p><ul><li><strong>原子性（Atomicity）: <strong>事务要么全部完成，要么全部取消。 如果事务崩溃，状态回到事务之前</strong>（事务回滚）</strong>【a转账给b，交易只有成功&#x2F;失败】</li><li><strong>一致性（Consistency）: <strong>事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。</strong>（保证AID、数据库完整性约束）</strong></li><li><strong>隔离性（Isolation）: <strong>并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的</strong>（加SX锁）</strong></li><li>**持久性（Durability）: **一旦事务提交，不管发生什么（崩溃或者出错），数据要保存在数据库中</li></ul><p>🌈A、I、D 是手段，C 是目的！事务的目的就是为了数据一致性C！<br>:::</p><h2 id="5-2-事务隔离级别⭐"><a href="#5-2-事务隔离级别⭐" class="headerlink" title="5.2 事务隔离级别⭐"></a>5.2 事务隔离级别⭐</h2><ol><li><strong>四种隔离级别</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696162796229-3c1a4743-1580-4255-b16b-57b336164ac3.png#averageHue=%23dfdcd4&clientId=u00942b2a-453e-4&from=drop&height=226&id=mY1L9&originHeight=305&originWidth=913&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=198006&status=done&style=none&taskId=uc892b70f-ba90-4da6-adae-bb63a9ec6ba&title=&width=678" alt="2019052019551758.png"><br>:::tips</p><ol><li><strong>读未提交（Read uncommitted）：</strong>事务A开启，修改某条数据，事务B第一次读取数据，但事务A后面回滚，事务B第二次读取数据，两次读取数据不一致，出现<strong>脏读现象</strong>（一个事务读取到另一个事务尚未提交的数据）</li></ol><ul><li><strong>解决：</strong>提高事务隔离级别</li></ul><ol start="2"><li><strong>读取已提交（Read committed，Oracle、SQL Server）：</strong>事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果不一致，出现<strong>不可重复读现象</strong>（一个事务中两次读取的数据的内容不一致）</li></ol><ul><li><strong>解决：</strong>加行级锁（SX）</li></ul><ol start="3"><li><strong>可重复读（Repeatable read，MySQL）：</strong>管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，出现<strong>幻读现象</strong>（一个事务中两次读取的数据量不一致）</li></ol><ul><li><strong>解决：</strong>加表级锁（SX）</li></ul><ol start="4"><li><p><strong>可串行化(Serializable）：</strong>两个同时发生的事务绝对隔离，每个事务有自己的”世界”, 串行执行（一般不用，性能太低）<br>:::</p></li><li><p><strong>事务隔离级别使用情况：</strong><br>:::tips</p></li></ol><ul><li>如果对一致性有要求，<strong>比如转账交易，要使用可重复读</strong>，并发性能相对较差。 原因是，为了实现可重复读，在对更新记录加锁时，除了使用记录锁，还可能会使用间隙锁锁住区间(看update语句的where条件)，这会增加其他事务等待时间。</li><li>如果对一致性要求不高，<strong>一般使用读取已提交</strong>, 由于不考虑可重复读，在加锁时一般只加记录锁，不会使用间隙锁，并发性较好，据说使用的最多。<br>:::</li></ul><h2 id="5-3-事务的使用"><a href="#5-3-事务的使用" class="headerlink" title="5.3 事务的使用"></a>5.3 事务的使用</h2><ul><li><p>开启事务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用模板</span><br><span class="line">start transaction;（/begin） # 开启事务</span><br><span class="line">insert into table1 (somevaue); -- 随意写的伪sql</span><br><span class="line">update table2 set aa = aa + 1 where id = 1;</span><br><span class="line">commit;# 提交事务 rollback;# 回滚事务</span><br></pre></td></tr></table></figure></li><li><p>设置隔离级别</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @@tx_isolation; # 查看隔离级别</span><br><span class="line"></span><br><span class="line">set global transaction isolation level read uncommitted; # 1、read uncommited(读未提交)</span><br><span class="line">set global transaction isolation level read committed; # 2、read commited(读已提交)</span><br><span class="line">set global transaction isolation level repeatable read; # 3、repeatable read(可重复读)</span><br><span class="line">set global transaction isolation level serializable; # 4、serializable(序列化)</span><br></pre></td></tr></table></figure></li></ul><h1 id="6、锁"><a href="#6、锁" class="headerlink" title="6、锁"></a>6、锁</h1><h2 id="6-1-锁机制原理⭐"><a href="#6-1-锁机制原理⭐" class="headerlink" title="6.1 锁机制原理⭐"></a>6.1 锁机制原理⭐</h2><p><a href="https://blog.csdn.net/C_J33/article/details/79487941">数据库的锁机制及原理</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1685845375297-a2e300dd-f839-4440-9f13-f5b21ee92475.png#averageHue=%23f5f5f5&clientId=u4eec948e-37ef-4&from=drop&height=471&id=dvgAX&originHeight=609&originWidth=814&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=86535&status=done&style=none&taskId=u662cf72f-11e8-4d1b-a8bc-2514f974840&title=&width=630" alt="Screenshot1520500121.png"></p><ol><li>从主观上划分，又可以分为<strong>乐观锁</strong>和<strong>悲观锁</strong>。</li></ol><ul><li><strong>乐观锁（Optimistic Lock）：</strong>顾名思义，从主观上认定资源是不会被修改的，所以不加锁读取数据，仅当更新时用版本号机制等确认资源是否被修改（<strong>乐观锁适用于多读的应用类型</strong>，可以系统提高吞吐量）</li><li><strong>悲观锁（Pessimistic Lock）：</strong>正如其名，具有强烈的独占和排它特性，每次<strong>读取数据</strong>时都会认为会被其它事务修改，<strong>所以每次操作都需要加上锁</strong>。</li></ul><ol start="2"><li>从锁的粒度划分，可以将锁分为<strong>表锁、行锁</strong>以及<strong>页锁</strong>。</li></ol><ul><li><p><strong>表级锁：是粒度最大的一种锁。</strong>表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lock tables table_name read; # 读锁</span><br><span class="line">lock tables table_name write; # 写锁</span><br></pre></td></tr></table></figure></li><li><p><strong>页级锁：是粒度介于行级锁和表级锁中间的一种锁。</strong>表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折中的页级，一次锁定相邻的一组记录。（页锁在MySQL中是自动实现的，通常不需要手动操作）</p></li><li><p><strong>行级锁：是锁定粒度最细的一种锁。</strong>表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大，并发度也最高。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ... for update; </span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>从使用性质划分，可以分为<strong>共享锁、排它锁</strong>以及<strong>更新锁</strong>。</li></ol><ul><li><p><strong>共享锁（Share Lock）：S 锁，又称读锁，用于所有的只读数据操作。</strong>S 锁并非独占，允许多个并发事务对同一资源加锁，但加 S 锁的同时不允许加 X 锁，即资源不能被修改。S 锁通常读取结束后立即释放，无需等待事务结束。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ... for share;</span><br><span class="line">select ... lock in share mode;</span><br></pre></td></tr></table></figure></li><li><p><strong>排他锁（Exclusive Lock）：X 锁，又称写锁，表示对数据进行写操作。</strong>X 锁仅允许一个事务对同一资源加锁，且直到事务结束才释放，其他任何事务必须等到 X 锁被释放才能对该页进行访问。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ... for update; </span><br></pre></td></tr></table></figure></li><li><p><strong>更新锁：U 锁，用来预定要对资源施加 X 锁，允许其他事务读，但不允许再施加 U 锁或 X 锁。</strong>当被读取的页将要被更新时，则升级为 X 锁，U 锁一直到事务结束时才能被释放。故 U 锁用来避免使用共享锁造成的死锁现象。</p></li></ul><h2 id="6-2-锁的算法-MVCC"><a href="#6-2-锁的算法-MVCC" class="headerlink" title="6.2 锁的算法&#x2F;MVCC"></a>6.2 锁的算法&#x2F;MVCC</h2><ol><li><strong>快照读和当前读概念：</strong></li></ol><ul><li><p><strong>什么是快照读？</strong>快照读，读取的是<strong>快照数据</strong>，不加锁的简单 Select 都属于快照读。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM player WHERE ...</span><br></pre></td></tr></table></figure><p><strong>坏处：读取过期数据。</strong>快照读的结果是一个在事务开始时的数据快照，如果在事务期间有其他事务修改了数据，则可能读取到已经过期的数据，<strong>不适用于需要实时数据的场景。【好处：数据&#x2F;读取一致性强、并发性能高】</strong></p></li><li><p><strong>什么是当前读？</strong>当前读就是读的是<strong>最新数据</strong>,而不是历史的数据，加锁的 SELECT，或者对数据进行增删改都会进行当前读。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM player LOCK IN SHARE MODE;</span><br><span class="line">SELECT FROM player FOR UPDATE;</span><br><span class="line">INSERT INTO player values ...</span><br><span class="line">DELETE FROM player WHERE ...</span><br><span class="line">UPDATE player SET ...</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>InnoDB 中的锁算法？</strong></li></ol><ul><li>Record lock：单个行记录上的锁</li><li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li><li>Next-key lock：record + gap 锁定一个范围，包含记录本身</li></ul><ol start="3"><li><strong>MVCC概念：</strong></li></ol><p>MVCC 的英文全称是 Multiversion Concurrency Control ，中文意思是<strong>多版本并发控制技术</strong>。原理是，通过数据行的多个版本管理来实现数据库的并发控制，简单来说就是<strong>保存数据的历史版本</strong>。可以<strong>通过比较版本号决定数据是否显示出来</strong>。读取数据的时候不需要加锁可以保证事务的隔离效果。【类似乐观锁的概念】<br><strong>MVCC 可以解决什么问题？</strong></p><ul><li><strong>读写之间阻塞的问题。</strong>通过 MVCC 可以让读写互相不阻塞，读不相互阻塞，写不阻塞读，这样可以提升数据并发处理能力。</li><li><strong>降低了死锁的概率。</strong>这个是因为 MVCC 采用了乐观锁的方式，读取数据时，不需要加锁，写操作，只需要锁定必要的行。</li><li><strong>解决了一致性读的问题。</strong>当我们朝向某个数据库在时间点的快照是，只能看到这个时间点之前事务提交更新的结果，不能看到时间点之后事务提交的更新结果。</li></ul><h1 id="7、SQL优化"><a href="#7、SQL优化" class="headerlink" title="7、SQL优化"></a>7、SQL优化</h1><p><strong>步骤：</strong>分析慢查询日志，加索引，减少连表数量，加缓存，改写业务逻辑，分库分表，加机器（无奈之举）。<br><a href="https://zhuanlan.zhihu.com/p/21956773">SQL性能优化的最佳21条经验</a></p><blockquote><p><strong>建议01：</strong></p></blockquote><ol><li><p><strong>当只要一行数据使用limit1：</strong>MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。</p></li><li><p><strong>在索引字段上使用not，&lt;&gt;，!&#x3D;是不会用到索引的：</strong>因此对它的处理只会产生全表扫描。 优化方法： key&lt;&gt;0 改为 key&gt;0 or key&lt;0。（详细看第三章索引失效的原因，SQL优化最重要的一步就是索引优化）</p></li><li><p><strong>MySQL分页offset优化：</strong>由于 MySQL 并不是跳过 offset 的行数，而是取 offset + limit 行，然后丢弃前 offset 行，返回 limit 行，当offset特别大的时候，效率就非常的低下。采用<strong>覆盖索引+延迟关联</strong>技术来减少偏移量的定位进行优化：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##查询语句</span><br><span class="line">select id from product limit 10000000, 10</span><br><span class="line">##优化方式一</span><br><span class="line">SELECT * FROM product WHERE ID &gt; =(select id from product limit 10000000, 1) limit 10</span><br><span class="line">##优化方式二（自连接）</span><br><span class="line">SELECT * FROM product a JOIN (select id from product limit 10000000, 10) b ON a.ID = b.id</span><br></pre></td></tr></table></figure></li><li><p><strong>千万不要ORDER BY RAND()：</strong>这样打乱返回的数据行、随机挑一个数据只让你的数据库的性能呈指数级的下降。</p></li><li><p>**避免 SELECT *：**从数据库里读出越多的数据，那么查询就会变得越慢。并且，如果你的数据库服务器和WEB服务器是两台独立的服务器的话，这还会增加网络传输的负载。所以，你应该养成一个需要什么就取什么的好的习惯。</p></li><li><p><strong>尽量使用ENUM而不是VARCHAR：</strong>ENUM类型是非常快和紧凑的。在实际上，其保存的是TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。至于什么时候用enum呢，可以<strong>使用PROCEDURE ANALYSE()取得建议⭐</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id from xxx PROCEDURE ANALYSE()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696216243383-b39e4e78-8fed-4d6f-9d5e-af476880ff69.png#averageHue=%23f8ebe8&clientId=uf143bdae-1a27-4&from=paste&height=80&id=u1f0c66b1&originHeight=100&originWidth=892&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=8771&status=done&style=none&taskId=u1afefb3d-64ae-4c92-b10a-09acd14fa4b&title=&width=713.6" alt="image.png"></p></li><li><p><strong>尽可能的使用NOT NULL：</strong>除非你有一个很特别的原因去使用NULL值，NULL也需要额外的空间，并且，在你进行比较的时候，你的程序会更复杂。</p></li><li><p><strong>固定长度的表会更快：</strong>固定长度的表<strong>会提高性能</strong>，因为MySQL搜寻得会更快一些，因为这些固定的长度是很容易计算下一个数据的偏移量的，所以读取的自然也会很快。而如果字段不是定长的，那么，每一次要找下一条的话，需要程序找到主键。<strong>固定长度的表也更容易被缓存和重建。</strong>但是，固定长度的字段会浪费一些空间，因为定长的字段无论你用不用，他都是要分配那么多的空间。使用“垂直分割”技术（见下一条），你可以分割你的表成为两个一个是定长的，一个则是不定长的。</p></li><li><p><strong>垂直分割：</strong>“垂直分割”是一种把数据库中的表按列变成几张表的方法，这样可以<strong>降低表的复杂度和字段的数目</strong>，从而达到优化的目的。但是切记，这些被分出去的字段所形成的表，你<strong>不会经常性地去join他们</strong>，不然的话，这样的性能会比不分割时还要差，而且，会是极数级的下降。</p></li><li><p><strong>拆分大的DELETE或INSERT语句：</strong>如果你需要在一个在线的网站上去执行一个大的DELETE或INSERT查询，你需要非常小心，要避免你的操作让你的整个网站停止相应。因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了。如果你有一个大的处理，把其拆分，使用LIMIT条件是一个好的方法。</p></li></ol><blockquote><p><strong>建议02：</strong></p></blockquote><ol start="11"><li><strong>选择正确的存储引擎：</strong></li></ol><ul><li><strong>MyISAM：</strong>适合于一些<strong>需要大量查询的应用</strong>，但其对于有<strong>大量写操作并不是很好</strong>。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM<strong>对于 SELECT COUNT(*) 这类的计算是超快无比的</strong>。（博客、新闻网站）</li><li><strong>InnoDB：</strong>对于一些小的应用，它会比MyISAM还慢，他是它支持“行锁”，于是在<strong>写操作比较多的时候，会更优秀</strong>。并且，他还支持更多的高级应用，比如：事务。（银行）</li></ul><ol start="12"><li><strong>大表查询如何优化：</strong>可以从<strong>分库分表、读写分离</strong>以及<strong>缓存</strong>三个维度下手。</li></ol><p><a href="https://mp.weixin.qq.com/s/7GTiAQof0LtYz6Jjpt-jxQ">一次有意思的 SQL 优化实操，30248.271s 到 0.001s</a></p><h1 id="8、集群"><a href="#8、集群" class="headerlink" title="8、集群"></a>8、集群</h1><p><a href="https://blog.csdn.net/cwb521sxm/article/details/97303289">MySQL主从复制</a></p><h2 id="8-1-主从复制⭐"><a href="#8-1-主从复制⭐" class="headerlink" title="8.1 主从复制⭐"></a>8.1 主从复制⭐</h2><ol><li><strong>概念：</strong>主从复制，是用来建立一个和主数据库完全一样的数据库环境，称为从数据库；主数据库一般是准实时的业务数据库。</li><li><strong>作用：</strong></li></ol><ul><li><strong>做数据的热备</strong>，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。</li><li><strong>架构的扩展。</strong>业务量越来越大，I&#x2F;O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I&#x2F;O访问的频率，提高单个机器的I&#x2F;O性能。</li><li><strong>读写分离，使数据库能支撑更大的并发。</strong>在报表中尤其重要。由于部分报表sql语句非常的慢，导致锁表，影响前台服务。如果前台使用master，报表使用slave，那么报表sql将不会造成前台锁，保证了前台速度。</li></ul><ol start="3"><li><strong>原理：⭐</strong></li></ol><p>数据库有个 binlog 二进制文件，记录了数据可执行的所有 SQL 语句。主从同步的目标就是把主数据库的 binlog 文件中的 SQL 语句复制到从数据库，让其在从数据的 relaylog 文件中再执行一次这些 SQL 语句即可。<br>具体需要三个线程来操作：</p><ul><li><strong>binlog 输出线程</strong>：每当有从库连接到主库的时候，主库都会创建一个线程然后发送 binlog内 容到从库。</li></ul><p>在从库里，当复制开始的时候，从库就会创建两个线程进行处理：</p><ul><li><strong>从库 IO 线程</strong>：当 START SLAVE 语句在从库开始执行之后，从库创建一个 IO 线程，该线程连接到主库并请求主库发送 binlog 里面的更新记录到从库上。从库 IO 线程读取主库的 binlog 输出线程发送的更新并拷贝这些更新到本地文件，其中包括 relaylog 文件。</li><li><strong>从库 SQL 线程</strong>：从库创建一个 SQL 线程，这个线程读取从库 IO 线程写到 relaylog 的更新事件并执行。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696213197860-09bedc32-a3b3-40bc-8f2b-22d9714094be.png#averageHue=%23f5f1ef&clientId=uf143bdae-1a27-4&from=drop&id=u6d88343d&originHeight=301&originWidth=691&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=295463&status=done&style=none&taskId=u014b011e-60ba-45f4-851d-5e1787433a7&title=" alt="93ea08019f694dfeaf56b2424e85a428.png"></p><h2 id="8-2-主从复制的框架"><a href="#8-2-主从复制的框架" class="headerlink" title="8.2 主从复制的框架"></a>8.2 主从复制的框架</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696212983368-3ee13e4c-8efa-4e03-8d1e-c810c9a328e5.png#averageHue=%23faf8f8&clientId=uf143bdae-1a27-4&from=drop&height=286&id=ua39a6d74&originHeight=381&originWidth=771&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=165489&status=done&style=none&taskId=u6ac15ff6-cc21-49e8-9a93-9cfdcd8cc50&title=&width=579.4000244140625" alt="533573387feb4e68af50c1a965caa50e.png"></p><ol><li><strong>一主一从或一主多从</strong></li></ol><p>在主库的请求压力非常大时，可通过配置一主多从复制架构实现读写分离，把大量对实时性要求不是很高的请求通过负载均衡分发到多个从库上去读取数据，降低主库的读取压力。而且在主库出现宕机时，可将一个从库切换为主库继续提供服务。</p><ol start="2"><li><strong>主主复制</strong></li></ol><p>双主复制架构适用于需要进行主从切换的场景。 两个数据库互为主从，当主库宕机恢复后，由于它还是原来从库（现在主库）的从机，所以它还是会复制新的主库上的数据。那么无论主库的角色怎么切换，原来的主库都不会脱离复制环境。</p><ol start="3"><li><strong>多主一从（5.7 开始支持）</strong></li><li><strong>联级复制</strong></li></ol><p>因为每个从库在主库上都会有一个独立的 Binlog Dump 线程来推送 binlog 日志，所以随着从库数量的增加，主库的 IO 压力和网络压力也会随之增加，这时，联级复制架构应运而生。<br>联级复制架构只是在一主多从的基础上，再主库和各个从库之间增加了一个二级主库 Master2，这个二级主库仅仅用来将一级主库推送给它的 Binlog 日志再推送给各个从库，以此来减轻一级主库的推送压力。</p><h2 id="8-3-主从复制的实现-常见问题"><a href="#8-3-主从复制的实现-常见问题" class="headerlink" title="8.3 主从复制的实现&#x2F;常见问题"></a>8.3 主从复制的实现&#x2F;常见问题</h2><p>MySQL 常用的主从复制有两种复制方式，分别是<strong>异步复制</strong>和<strong>半同步复制</strong>：</p><ol><li><strong>异步复制</strong></li></ol><p>MySQL 默认的主从复制方式就是异步复制，因为 Master 根本不考虑数据是否达到了 Slave，或 Slave 是否成功执行。如过需要实现完全同步方式，即 Master 需要等待一个或所有 Slave 执行成功后才响应成功，那集群效率可想而知。故 MySQL 5.6 之后出现了一种折中的方式——半同步。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696213693676-a084f895-edf4-42ed-9540-c887e52b20d0.png#averageHue=%23f7f6f5&clientId=uf143bdae-1a27-4&from=drop&height=288&id=ua91c278e&originHeight=330&originWidth=634&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=78868&status=done&style=none&taskId=u2530082a-c3e0-4da7-b7ab-93f31b81932&title=&width=553" alt="20190725213302866.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 5.5集成到mysql，以插件的形式存在，需要单独安装 </span><br><span class="line">- 确保事务提交后binlog至少传输到一个从库 </span><br><span class="line">- 不保证从库应用完这个事务的binlog </span><br><span class="line">- 性能有一定的降低，响应时间会更长 </span><br><span class="line">- 网络异常或从库宕机，卡主主库，直到超时或从库恢复</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>半同步复制</strong></li></ol><p>一主一从，一主多从情况下，Master 节点只要确认至少有一个 Slave 接受到了事务，即可向发起请求的客户端返回执行成功的操作。同时 Master 是不需要等待 Slave 成功执行完这个事务，Slave 节点接受到这个事务，并成功写入到本地 relay 日志中就算成功。<br>另外，在半同步复制时，如果主库的一个事务提交成功了，在推送到从库的过程当中，从库宕机了或网络故障，导致从库并没有接收到这个事务的Binlog，此时主库会等待一段时间（这个时间由rpl_semi_sync_master_timeout的毫秒数决定），如果这个时间过后还无法推送到从库，那 MySQL 会自动从半同步复制切换为异步复制，当从库恢复正常连接到主库后，主库又会自动切换回半同步复制。<br>半同步复制的“半”体现在，虽然主从库的Binlog是同步的，但主库不会等待从库执行完Relay-log后才返回，而是确认从库接收到Binlog，达到主从Binlog同步的目的后就返回了，所以从库的数据对于主库来说还是有延时的，这个延时就是从库执行Relay-log的时间。所以只能称为半同步。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696213703475-1444e55f-4b02-416f-8e81-7474d21e1e10.png#averageHue=%23f5f3f2&clientId=uf143bdae-1a27-4&from=drop&height=277&id=uf66cb260&originHeight=331&originWidth=626&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=102644&status=done&style=none&taskId=u5f460619-a7d9-46f9-b878-b90fea28146&title=&width=523" alt="20190725213350321.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 事务在主库写完binlog后需要从库返回一个已接受，才放回给客户端；</span><br><span class="line">- 5.5集成到mysql，以插件的形式存在，需要单独安装</span><br><span class="line">- 确保事务提交后binlog至少传输到一个从库</span><br><span class="line">- 不保证从库应用完成这个事务的binlog</span><br><span class="line">- 性能有一定的降低</span><br><span class="line">- 网络异常或从库宕机，卡主库，直到超时或从库恢复 </span><br></pre></td></tr></table></figure><p>此外，还有：并行复制、部分数据复制、联级复制等等…</p><ol start="3"><li><strong>主从中常见问题以及解决？</strong></li></ol><ul><li><strong>主库宕机后，数据可能丢失。</strong>解决方案：<strong>半同步复制，</strong>确保事务提交后 binlog 至少传输到一个从库 ，解决数据丢失的问题。</li><li><strong>从库只有一个sql Thread，主库写压力大，复制很可能延时。</strong>解决方案：<strong>并行复制，</strong>从库多线程apply binlog，解决从库复制延迟的问题。</li></ul><h1 id="9、进阶功能"><a href="#9、进阶功能" class="headerlink" title="9、进阶功能"></a>9、进阶功能</h1><h2 id="9-1-视图"><a href="#9-1-视图" class="headerlink" title="9.1 视图"></a>9.1 视图</h2><ol><li><strong>什么是视图？</strong></li></ol><p>概述：复杂的<strong>多表查询</strong>需要将多个表连接起来进行查询任务。对于复杂的查询事件，每次查询都需要编写<strong>MySQL代码效率低下</strong>。为了解决这个问题，数据库提供了<strong>视图（view）功能</strong>。<br>简而言之：<strong>视图就是虚拟表</strong>，本身不存储数据，而是按照指定的方式进行查询。<br>作用：方便，简化开发，利于维护</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建视图对象(只有DQL语句才能以view的形式创建)</span><br><span class="line">create view 视图名(列1，列2...) as select (列1，列2...) from ...;</span><br><span class="line">create view xx as</span><br><span class="line">select a.xxx,b.xxx from a join b on a.xx = b.xx;</span><br><span class="line"> </span><br><span class="line">create or replace view 视图名 as select [...] from [...];# 修改视图对象</span><br><span class="line">drop view dept2_view; # 删除视图对象</span><br><span class="line">show tables [like...] # 查看数据库已有视图</span><br><span class="line">desc 视图名 / show fields from 视图名 # 查看视图详情</span><br><span class="line"></span><br><span class="line"># 其他操作都跟单表一样</span><br></pre></td></tr></table></figure><ul><li>一般情况下，在创建有条件限制的视图时，加上“WITH CHECK OPTION”命令。</li><li><strong>视图的优点：</strong><ul><li>视图能简化用户操作</li><li>视图使用户能以多种角度看待同一数据</li><li>视图对重构数据库提供了一定程度的逻辑独立性</li><li>视图能够对机密数据提供安全保护</li><li>适当的利用视图可以更清晰地表达查询</li></ul></li></ul><h2 id="9-2-触发器"><a href="#9-2-触发器" class="headerlink" title="9.2 触发器"></a>9.2 触发器</h2><p><a href="https://blog.csdn.net/qq_54169998/article/details/122720159">MySQL触发器的使用、创建、修改及删除</a><br>当我们对一个表进行数据操作时，需要同步对其它的表执行相应的操作，正常情况下，如果我们使用sql语句进行更新，将需要执行多条操作语句！<br>    触发器（TRIGGER）是由事件来触发某个操作。这些事件包括INSERT语句、UPDATE语句和DELETE语句。当数据库系统执行这些事件时，就会激活触发器执行相应的操作。MySQL从5.0.2版本开始支持触发器。</p><ol><li><strong>创建单执行触发器</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建触发器</span><br><span class="line">create trigger trigger_name before|after 触发事件    </span><br><span class="line">on tablename for each row 激活触发器后被执行的语句</span><br></pre></td></tr></table></figure>案例：要求当student表中插入学生数据时，班级表class同步更新班级人数</li></ol><ul><li>insert操作</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696210817751-f245bb0f-7c0b-47a1-81d5-18360c86cd7f.png#averageHue=%23121110&clientId=uf143bdae-1a27-4&from=drop&id=u1ab281f2&originHeight=226&originWidth=1190&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=50887&status=done&style=none&taskId=u8a60effe-00f4-4491-871b-8a075e2afef&title=" alt="2e6aea8e2f0a4c76a7067aab70a0bf4b.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 对于insert事件，使用new才表示插入的记录，因此这里要使用class.id=new.class_id; </span><br><span class="line">create trigger tri_insert_student after insert </span><br><span class="line">    on student for each row </span><br><span class="line">    update class set count=count+1 where class.id=new.class_id;</span><br></pre></td></tr></table></figure><ul><li>delete操作<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 对于delete事件，使用old才表示删除的记录</span><br><span class="line">create trigger tri_delete_student after delete </span><br><span class="line">on student for each row update class set count=count-1 where old.class_id=class.id;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><p><strong>创建多执行触发器</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE trigger trigger_name BEFORE|AFTER 触发事件    </span><br><span class="line">ON TABLE_NAME FOR EACH ROW                                 </span><br><span class="line">    BEGIN                                                        </span><br><span class="line">        激活触发器后被执行的语句1;</span><br><span class="line">激活触发器后被执行的语句2;</span><br><span class="line">    END; </span><br></pre></td></tr></table></figure><p>在MySQL中，一般情况下用“;”符号作为语句的结束符号，可是在创建触发器时，需要用到“;”符号作为执行语句的结束符号。为了解决该问题，可以使用关键字DELIMITER语句。例如，”DELIMITER  $’$”可以将结束符号设置成“$$”。<br>案例：每次student表增删时同步到score表和class表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $$   #将分号“;”声明为“$$”                                                            </span><br><span class="line">create trigger tri_delete_student after delete on student for each row </span><br><span class="line">    BEGIN                                    </span><br><span class="line">        delete from grade where id = OLD.id;  #删除成绩表中的记录                                                        </span><br><span class="line">        update class set count=count-1 where id = OLD.class_id; #更新班级表中的记录   </span><br><span class="line">    END; #分号要有                                   </span><br><span class="line">$$                                       </span><br><span class="line">DELIMITER ;  #再将分号声明回来</span><br></pre></td></tr></table></figure></li><li><p><strong>查看触发器</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TRIGGERS ; # 查看触发器</span><br><span class="line"></span><br><span class="line"># #查询系统表triggers中的触发器</span><br><span class="line">use information_schema;   #选择数据库information_schema                  </span><br><span class="line">select * from triggers;                                                        </span><br><span class="line">select * from triggers where trigger_name=&#x27;tri_delete_student&#x27;; </span><br></pre></td></tr></table></figure></li><li><p><strong>删除触发器</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TRIGGER trigger_name; </span><br></pre></td></tr></table></figure></li></ol><h2 id="9-3-约束"><a href="#9-3-约束" class="headerlink" title="9.3 约束"></a>9.3 约束</h2><p><a href="https://blog.csdn.net/z_johnny/article/details/113820405">MySQL约束总结(CONSTRAINT)</a><br>:::tips<br><strong>6种约束（constraints）：</strong></p><ul><li>非空约束：not null</li><li>唯一性约束： unique</li><li>主键约束：primary key （&#x3D;not null +unique）</li><li>外键约束：foreign key</li><li>默认值约束：default</li><li>检查约束：check（检查字段是否有效，比如年龄，性别）<br>:::</li></ul><ol><li><p>列级约束：NOT NULL | DEFAULT | PRIMARY KEY | UNIQUE | CHECK</p></li><li><p>表级约束：PRIMARY KEY | UNIQUE | CHECK | FOREIGN KEY</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table t_vip(</span><br><span class="line">id int primary key,   ---&gt;添加主键</span><br><span class="line">name varchar(255)</span><br><span class="line">);# 列级约束</span><br><span class="line"> </span><br><span class="line">create table t_vip(</span><br><span class="line">id int,</span><br><span class="line">name varchar(255),</span><br><span class="line">primary key(id)   ---&gt;添加主键</span><br><span class="line">);# 表级约束</span><br></pre></td></tr></table></figure><p><strong>约束的使用规则：</strong></p></li><li><p>创建表时：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table students (</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT, ---&gt;主键</span><br><span class="line">name VARCHAR(20) NOT NULL, ---&gt;非空</span><br><span class="line">age INT DEFAULT 18, ---&gt;默认值</span><br><span class="line">gender CHAR CHECK(gender IN (&#x27;W&#x27;,&#x27;M&#x27;)), ---&gt;检查</span><br><span class="line">phone INT(11) UNIQUE, ---&gt;唯一</span><br><span class="line">tid INT,</span><br><span class="line">CONSTRAINT fk FOREIGN KEY(tid) REFERENCES teachers(id) ---&gt;外键</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>创建表后：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show index from xxx; # 展示表的约束</span><br><span class="line"></span><br><span class="line"># 列操作</span><br><span class="line">alter table info modify column id INT PRIMARY KEY; # 添加列主键约束</span><br><span class="line">alter table info modify column name VARCHAR(20) NOT NULL; # 添加列非空约束（其他同理）</span><br><span class="line">alter table info drop primary key; # 删除列主键约束</span><br><span class="line"></span><br><span class="line"># 表操作</span><br><span class="line">alter table info add PRIMARY KEY(id); # 添加“表”主键约束 </span><br><span class="line">alter table info add UNIQUE(tid); # 添加“表”唯一约束 </span><br><span class="line">alter table info add CONSTRAINT ck CHECK(gender IN (&#x27;W&#x27;,&#x27;M&#x27;)); # 添加“表”检查约束 </span><br><span class="line">alter table info add CONSTRAINT fy FOREIGN KEY(tid) REFERENCES teachers(id); # 添加“表”外键约束</span><br><span class="line"></span><br><span class="line">alter table info modify column name varchar(20) NULL; # 删除列非空约束</span><br><span class="line">alter table info drop PRIMARY KEY; # 删除“表”主键约束</span><br></pre></td></tr></table></figure></li></ol><ul><li><strong>关于外键索引：</strong></li></ul><ol><li>子表中的外键引用的父表中的某个字段，被引用的这个字段不一定是主键，但<strong>至少具有unique约束</strong></li><li>删除表&#x2F;数据的顺序？子表——&gt;父表</li><li>创建表、插入数据的顺序？父表——&gt;子表</li><li>外键值可以为NULL</li></ol><h2 id="9-4-日志"><a href="#9-4-日志" class="headerlink" title="9.4 日志"></a>9.4 日志</h2><p><strong>MySQL有哪些日志文件：</strong></p><ol><li><strong>重做日志（redo log）：物理日志</strong></li></ol><p>**作用是确保事务的持久性。 **redo 日志记录事务执行后的状态，用来恢复未写入 data file 的已提交事务数据。</p><ol start="2"><li><strong>回滚日志（undo log）：逻辑日志</strong></li></ol><p><strong>作用是保证数据的原子性。</strong> 保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。</p><ol start="3"><li><strong>二进制日志（bin log）：逻辑日志</strong></li></ol><p>常用于主从同步或数据同步中，也可用于数据库基于时间点的还原。</p><ol start="4"><li><strong>中继日志（relay log）</strong></li></ol><p>在从节点中存储接收到的 binlog 日志内容，用于主从同步。</p><ol start="5"><li><strong>错误日志（error log）</strong></li></ol><p>记录着 MySQL 启动和停止，以及服务器在运行过程中发生的错误的相关信息。在默认情况下，系统记录错误日志的功能是关闭的，错误信息被输出到标准错误输出。</p><ol start="6"><li><strong>普通查询日志（general query log）</strong></li></ol><p>记录了服务器接收到的每一个命令，无论命令语句是否正确，因此会带来不小开销，所以也是默认关闭的。</p><ol start="7"><li><strong>慢查询日志（slow query log）</strong></li></ol><p>记录执行时间过长和没有使用索引的查询语句（默认 10s），同时只会记录执行成功的语句。</p><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><ul><li>说说MySQL中MVCC机制的原理？</li><li>MySQL的事务原理和实现？</li><li>MySQL数据主从复制的原理？</li><li>MySQL底层数据的存储结构？</li><li>如何使MySQL支持海量数据存储？</li><li>MySQL中的锁机制原理和实现？</li><li>MySQL索引机制？索引中涉及的数据结构和算法？</li><li>MySQL为何使用B+树作为索引结构？</li><li>B+树可以存放多少数据？</li><li>说说MySQL中间隙锁的实现原理？</li><li>InnoDB引擎为何会崩溃？说说其实现原理？</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;面试题：&lt;a href=&quot;https://blog.csdn.net/qq_30999361/article/details/124506169&quot;&gt;MySQL面试题（40道含答案）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.</summary>
      
    
    
    
    
    <category term="mysql" scheme="http://example.com/tags/mysql/"/>
    
  </entry>
  
</feed>
