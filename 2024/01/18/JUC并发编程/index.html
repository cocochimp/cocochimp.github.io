<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JUC并发编程 | cocochimpBlog</title><meta name="author" content="cocochimp"><meta name="copyright" content="cocochimp"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="面试题：Java并发编程面试题（123道含答案）  JUC - 类汇总和学习指南 1、Locks 锁 1.1 Lock接口1.2 ReentrantLock 重入锁1.3 ReadWriteLock 读写锁1.4 Condition1.5 LockSupport1.6 AQS2、Tools 工具类  标志为绿色的内容  2.1 CountDownLatch其实就是一个减法计数器，对于计数器归零之">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC并发编程">
<meta property="og:url" content="http://example.com/2024/01/18/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="cocochimpBlog">
<meta property="og:description" content="面试题：Java并发编程面试题（123道含答案）  JUC - 类汇总和学习指南 1、Locks 锁 1.1 Lock接口1.2 ReentrantLock 重入锁1.3 ReadWriteLock 读写锁1.4 Condition1.5 LockSupport1.6 AQS2、Tools 工具类  标志为绿色的内容  2.1 CountDownLatch其实就是一个减法计数器，对于计数器归零之">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/juc.png">
<meta property="article:published_time" content="2024-01-18T03:00:43.042Z">
<meta property="article:modified_time" content="2024-01-18T03:09:50.128Z">
<meta property="article:author" content="cocochimp">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/juc.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/01/18/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JUC并发编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-18 11:09:50'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="cocochimpBlog" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/picture/"><i class="fa-fw iconfont icon-tupian"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-touxiang"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/juc.png')"><nav id="nav"><span id="blog-info"><a href="/" title="cocochimpBlog"><span class="site-name">cocochimpBlog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/picture/"><i class="fa-fw iconfont icon-tupian"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-touxiang"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JUC并发编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-18T03:00:43.042Z" title="发表于 2024-01-18 11:00:43">2024-01-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-18T03:09:50.128Z" title="更新于 2024-01-18 11:09:50">2024-01-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>58分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JUC并发编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><ul>
<li>面试题：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_30999361/article/details/124545403">Java并发编程面试题（123道含答案）</a></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://pdai.tech/md/java/thread/java-thread-x-juc-overview.html">JUC - 类汇总和学习指南</a></p>
<h1 id="1、Locks-锁"><a href="#1、Locks-锁" class="headerlink" title="1、Locks 锁"></a>1、Locks 锁</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696994312722-08a830ea-3580-4cb7-ae08-fa458b1da016.png#averageHue=%23f0ecec&clientId=ud6f5435f-a1f8-4&from=paste&height=457&id=u37ebfb29&originHeight=571&originWidth=1007&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=118568&status=done&style=none&taskId=ud5ca5b42-025a-4a7c-bdba-ba243e6386e&title=&width=805.6" alt="image.png"></p>
<h2 id="1-1-Lock接口"><a href="#1-1-Lock接口" class="headerlink" title="1.1 Lock接口"></a>1.1 Lock接口</h2><h2 id="1-2-ReentrantLock-重入锁"><a href="#1-2-ReentrantLock-重入锁" class="headerlink" title="1.2 ReentrantLock 重入锁"></a>1.2 ReentrantLock 重入锁</h2><h2 id="1-3-ReadWriteLock-读写锁"><a href="#1-3-ReadWriteLock-读写锁" class="headerlink" title="1.3 ReadWriteLock 读写锁"></a>1.3 ReadWriteLock 读写锁</h2><h2 id="1-4-Condition"><a href="#1-4-Condition" class="headerlink" title="1.4 Condition"></a>1.4 Condition</h2><h2 id="1-5-LockSupport"><a href="#1-5-LockSupport" class="headerlink" title="1.5 LockSupport"></a>1.5 LockSupport</h2><h2 id="1-6-AQS"><a href="#1-6-AQS" class="headerlink" title="1.6 AQS"></a>1.6 AQS</h2><h1 id="2、Tools-工具类"><a href="#2、Tools-工具类" class="headerlink" title="2、Tools 工具类"></a>2、Tools 工具类</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696994322635-a3a6631b-3bb2-4cad-a832-ac1dd6107ef1.png#averageHue=%23f0ecec&clientId=ud6f5435f-a1f8-4&from=paste&height=457&id=u6666b0c0&originHeight=571&originWidth=1007&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=118568&status=done&style=none&taskId=u3f7f3fed-b002-4978-83ca-ef7f1dbfe3e&title=&width=805.6" alt="image.png"></p>
<ul>
<li>标志为绿色的内容</li>
</ul>
<h2 id="2-1-CountDownLatch"><a href="#2-1-CountDownLatch" class="headerlink" title="2.1 CountDownLatch"></a>2.1 CountDownLatch</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686474741620-08518dd6-d0e6-4b66-9a06-67a6f13d777e.png#averageHue=%23f6f1f1&clientId=udaf2058c-f549-4&id=LUeC3&originHeight=677&originWidth=1222&originalType=binary&ratio=1&rotation=0&showTitle=false&size=86017&status=done&style=none&taskId=u9d80393e-1e6f-4ac4-a510-a7abc282c8f&title=" alt="image.png"><br><strong>其实就是一个减法计数器，对于计数器归零之后再进行后面的操作，这是一个计数器！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是一个计数器  减法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//总数是6</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; Go out&quot;</span>);</span><br><span class="line">                countDownLatch.countDown(); <span class="comment">//每个线程都数量-1</span></span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();  <span class="comment">//等待计数器归零  然后向下执行</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;close door&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要方法：</p>
<ul>
<li>countDown 减一操作；</li>
<li>await 等待计数器归零。</li>
</ul>
<p>await等待计数器为0，就唤醒，再继续向下运行。</p>
<h2 id="2-2-CyclickBarrier"><a href="#2-2-CyclickBarrier" class="headerlink" title="2.2 CyclickBarrier"></a>2.2 CyclickBarrier</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686474741624-6d8e53c9-4773-4d3a-be9f-101e33c0c889.png#averageHue=%23f6f3f3&clientId=udaf2058c-f549-4&id=qtOGp&originHeight=206&originWidth=1168&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24223&status=done&style=none&taskId=u91b4ad1e-535e-44dd-a4d2-5c2e5ab4976&title=" alt="image.png"><br>其实就是一个加法计数器；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主线程</span></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">7</span>,()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;召唤神龙~&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//子线程</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 收集了第 &#123;&quot;</span>+ finalI+<span class="string">&quot;&#125; 颗龙珠&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await(); <span class="comment">//加法计数 等待</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-Semaphore"><a href="#2-3-Semaphore" class="headerlink" title="2.3 Semaphore"></a>2.3 Semaphore</h2><p>Semaphore（信号量）：多个共享资源互斥的使用！ 并发限流，控制最大的线程数！<br>抢车位：3个车位 6辆车：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//停车位为3个</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire(); <span class="comment">//得到</span></span><br><span class="line">                    <span class="comment">//抢到车位</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 抢到了车位&#123;&quot;</span>+ finalI +<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>); <span class="comment">//停车2s</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 离开车位&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();<span class="comment">//释放</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>:::tips<br><strong>原理：</strong><br>semaphore.acquire()获得资源，如果资源已经使用完了，就等待资源释放后再进行使用！<br>semaphore.release()释放，会将当前的信号量释放+1，然后唤醒等待的线程！<br>:::</p>
<h1 id="3、Collections-并发集合"><a href="#3、Collections-并发集合" class="headerlink" title="3、Collections 并发集合"></a>3、Collections 并发集合</h1><h2 id="3-1-ConcurrentHashMap"><a href="#3-1-ConcurrentHashMap" class="headerlink" title="3.1 ConcurrentHashMap"></a>3.1 ConcurrentHashMap</h2><h2 id="3-2-CopyOnWriteArrayList"><a href="#3-2-CopyOnWriteArrayList" class="headerlink" title="3.2 CopyOnWriteArrayList"></a>3.2 CopyOnWriteArrayList</h2><h2 id="3-3-BlockingQueue"><a href="#3-3-BlockingQueue" class="headerlink" title="3.3 BlockingQueue"></a>3.3 BlockingQueue</h2><h2 id="3-4-ConcurrentLinkedQueue"><a href="#3-4-ConcurrentLinkedQueue" class="headerlink" title="3.4 ConcurrentLinkedQueue"></a>3.4 ConcurrentLinkedQueue</h2><h2 id="3-5-Fork-Join"><a href="#3-5-Fork-Join" class="headerlink" title="3.5 Fork&#x2F;Join"></a>3.5 Fork&#x2F;Join</h2><p><strong>在JDK1.7中对并发框架进行扩充，引入了java.util.concurrent.forkjoin包。</strong><br><strong>Frok&#x2F;Join模式是处理并行编程的一种经典方法。</strong><br><strong>下面是Fork&#x2F;Join模式的示意图：</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697182246402-8e07aa72-e243-4533-a516-62a8fd1b45ff.png#averageHue=%23e9efe4&clientId=u82ebc67f-374a-4&from=paste&id=uf6f26667&originHeight=216&originWidth=572&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u5b41ed28-dd54-48db-93af-97bbbb59fd7&title="></p>
<blockquote>
<p>1、什么是ForkJoin？</p>
</blockquote>
<p>ForkJoin 在JDK1.7，并行执行任务！提高效率~。在大数据量速率会更快！<br>大数据中：<strong>MapReduce 核心思想-&gt;把大任务拆分为小任务！</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696999198865-e8f69dca-10bd-4e59-a00d-baace0c620a2.png#averageHue=%23fefffe&clientId=ud6f5435f-a1f8-4&id=xbyQx&originHeight=540&originWidth=590&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u960028e8-f1b9-4a69-b0cd-36b22e32f5c&title="></p>
<blockquote>
<p>2、<strong>ForkJoin 特点： 工作窃取！</strong></p>
</blockquote>
<p>实现原理是：<strong>双端队列</strong>！从上面和下面都可以去拿到任务进行执行！<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696999198860-1aeee17e-68d1-4086-86d0-1cf6f55655ed.png#averageHue=%23eff1ef&clientId=ud6f5435f-a1f8-4&id=ntQAX&originHeight=513&originWidth=325&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue5444664-624c-4b0f-bcc1-0ae5cc58fad&title="></p>
<blockquote>
<p>3、如何使用ForkJoin?</p>
</blockquote>
<ul>
<li>1、通过<strong>ForkJoinPool</strong>来执行</li>
<li>2、计算任务 <strong>execute(ForkJoinTask&lt;?&gt; task)</strong></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696999198894-90363f7c-f016-4be1-bd37-09c69064f043.png#averageHue=%23f2f0eb&clientId=ud6f5435f-a1f8-4&id=hOBD4&originHeight=308&originWidth=722&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud2216785-88f6-4466-a9e4-36e902dd3f0&title="></p>
<ul>
<li>3、计算类要去继承ForkJoinTask；</li>
</ul>
<p><strong>ForkJoin的计算类！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ogj.forkjoin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinDemo</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> star;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//临界值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> temp=<span class="number">1000000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ForkJoinDemo</span><span class="params">(<span class="type">long</span> star, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.star = star;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Long</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>((end-star)&lt;temp)&#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Long</span> <span class="variable">i</span> <span class="operator">=</span> star; i &lt; end; i++) &#123;</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            System.out.println(sum);</span></span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//使用forkJoin 分而治之 计算</span></span><br><span class="line">            <span class="comment">//计算平均值</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">middle</span> <span class="operator">=</span> (star+ end)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">ForkJoinDemo</span> <span class="variable">forkJoinDemoTask1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(star, middle);</span><br><span class="line">            forkJoinDemoTask1.fork();  <span class="comment">//拆分任务，把线程任务压入线程队列</span></span><br><span class="line">            <span class="type">ForkJoinDemo</span> <span class="variable">forkJoinDemoTask2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(middle, end);</span><br><span class="line">            forkJoinDemoTask2.fork();  <span class="comment">//拆分任务，把线程任务压入线程队列</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">taskSum</span> <span class="operator">=</span> forkJoinDemoTask1.join() + forkJoinDemoTask2.join();</span><br><span class="line">            <span class="keyword">return</span> taskSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试类！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ogj.forkjoin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.LongStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        test1();</span><br><span class="line">        test2();</span><br><span class="line">        test3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通计算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">star</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">20_0000_0000</span>; i++) &#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span>+<span class="string">&quot;时间：&quot;</span>+(end-star));</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用ForkJoin</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">star</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(<span class="number">0L</span>, <span class="number">20_0000_0000L</span>);</span><br><span class="line">        ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">aLong</span> <span class="operator">=</span> submit.get();</span><br><span class="line">        System.out.println(aLong);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span>+<span class="string">&quot;时间：&quot;</span>+(end-star));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用Stream 并行流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">star</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//Stream并行流()</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> LongStream.range(<span class="number">0L</span>, <span class="number">20_0000_0000L</span>).parallel().reduce(<span class="number">0</span>, Long::sum);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span>+<span class="string">&quot;时间：&quot;</span>+(end-star));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696999198909-28972d4f-5a54-4772-b85f-00df07fae079.png#averageHue=%233b3630&clientId=ud6f5435f-a1f8-4&id=NvnAk&originHeight=279&originWidth=699&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6e858ad1-c7e6-4e4f-85c4-dd56fdc9d2f&title="><br><strong>.parallel().reduce(0, Long::sum)使用一个并行流去计算整个计算，提高效率。</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696999198964-c384a954-a5f4-415d-bd93-a0a3bed04bdd.png#averageHue=%23fbfafa&clientId=ud6f5435f-a1f8-4&id=FAdNk&originHeight=317&originWidth=694&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ucca0d959-a338-438f-8aaf-fe59c010d07&title="><br><strong>reduce方法的优点：</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696999199905-e95e1874-6b08-47ce-be8a-bcdb40726019.png#averageHue=%23fdfbfb&clientId=ud6f5435f-a1f8-4&id=M28c0&originHeight=709&originWidth=1094&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u583cc531-6502-4dd5-a209-13cf7359a0f&title="></p>
<h1 id="4、Executors-线程池"><a href="#4、Executors-线程池" class="headerlink" title="4、Executors 线程池"></a>4、Executors 线程池</h1><ul>
<li>建议</li>
</ul>
<p><strong>注：线程池这块的拒绝策略、核心参数配置什么的，如果你不了解，实际项目中使用线程池可能就用的不是很明白，容易出现问题。</strong><br>线程池配置无界队列了之后，拒绝策略其实就失去了意义，因为无论有多少任务提交到线程池，都会被放入队列中等待执行，不会触发拒绝策略。不过，这样可能堆积大量的请求，从而导致 OOM。因此，一般不推荐使用误解队列。<br>:::tips<br>假设不是无界队列的话，如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，ThreadPoolTaskExecutor 定义一些拒绝策略:</p>
<ul>
<li>ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException来拒绝新任务的处理。</li>
<li>ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li>
<li>ThreadPoolExecutor.DiscardPolicy：不处理新任务，直接丢弃掉。</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy：此策略将丢弃最早的未处理的任务请求。<br>:::</li>
</ul>
<h2 id="4-1-Executor"><a href="#4-1-Executor" class="headerlink" title="4.1 Executor"></a>4.1 Executor</h2><h2 id="4-2-ThreadPoolExecutor"><a href="#4-2-ThreadPoolExecutor" class="headerlink" title="4.2 ThreadPoolExecutor"></a>4.2 ThreadPoolExecutor</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/610096853">一文搞懂ThreadPoolExecutor</a></p>
<h2 id="4-3-FutureTask"><a href="#4-3-FutureTask" class="headerlink" title="4.3 FutureTask"></a>4.3 FutureTask</h2><h1 id="5、Atomic-原子类"><a href="#5、Atomic-原子类" class="headerlink" title="5、Atomic 原子类"></a>5、Atomic 原子类</h1><h2 id="5-1-基本类型"><a href="#5-1-基本类型" class="headerlink" title="5.1 基本类型"></a>5.1 基本类型</h2><h2 id="5-2-Array"><a href="#5-2-Array" class="headerlink" title="5.2 Array"></a>5.2 Array</h2><h2 id="5-3-Reference"><a href="#5-3-Reference" class="headerlink" title="5.3 Reference"></a>5.3 Reference</h2><h2 id="5-4-FieldUpdator"><a href="#5-4-FieldUpdator" class="headerlink" title="5.4 FieldUpdator"></a>5.4 FieldUpdator</h2><h1 id="1、JUC体系结构"><a href="#1、JUC体系结构" class="headerlink" title="1、JUC体系结构"></a>1、JUC体系结构</h1><h2 id="1-1-JUC的概念"><a href="#1-1-JUC的概念" class="headerlink" title="1.1 JUC的概念"></a>1.1 JUC的概念</h2><p>学习方法：源码+官方文档</p>
<blockquote>
<p>JUC是 java util concurrent</p>
</blockquote>
<ul>
<li>面试高频问JUC~！</li>
</ul>
<p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727195421667.png#id=utfxj&originHeight=398&originWidth=839&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>java.util 是Java的一个工具包~<br><strong>业务：普通的线程代码 Thread</strong><br><strong>Runnable：</strong> 没有返回值、效率相比于<strong>Callable</strong> 相对较低！<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727195447249.png#id=I2ztm&originHeight=886&originWidth=1273&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="1-2-线程和进程"><a href="#1-2-线程和进程" class="headerlink" title="1.2 线程和进程"></a>1.2 线程和进程</h2><blockquote>
<p>1、概述</p>
</blockquote>
<p><strong>进程：一个程序，QQ.EXE Music.EXE；数据+代码+pcb</strong><br>一个进程可以包含多个线程，至少包含一个线程！<br>Java默认有几个线程？<strong>2个线程！</strong> main线程、GC线程<br><strong>线程：开了一个进程Typora，写字，等待几分钟会进行自动保存(线程负责的)</strong><br>对于Java而言：Thread、Runnable、Callable进行开启线程的，我们之前。<br><strong>提问？JAVA真的可以开启线程吗？ 开不了的！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * This method is not invoked for the main method thread or &quot;system&quot;</span></span><br><span class="line"><span class="comment">        * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">        * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * A zero status value corresponds to state &quot;NEW&quot;.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">        * so that it can be added to the group&#x27;s list of threads</span></span><br><span class="line"><span class="comment">        * and the group&#x27;s unstarted count can be decremented. */</span></span><br><span class="line">       group.add(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">       <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           start0();</span><br><span class="line">           started = <span class="literal">true</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                   group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">               <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                 it will be passed up the call stack */</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//这是一个C++底层，Java是没有权限操作底层硬件的</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>Java是没有权限去开启线程、操作硬件的，这是一个native的一个本地方法，它调用的底层的C++代码。</p>
<blockquote>
<p>2、并发、并行</p>
</blockquote>
<p><strong>并发：</strong> 多线程操作同一个资源。</p>
<ul>
<li>CPU 只有一核，模拟出来多条线程，天下武功，唯快不破。那么我们就可以使用CPU快速交替，来模拟多线程。</li>
</ul>
<p><strong>并行：</strong> 多个人一起行走</p>
<ul>
<li>CPU多核，多个线程可以同时执行。 我们可以使用线程池！<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取cpu的核数</span></span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
并发编程的本质：<strong>充分利用CPU的资源！</strong></li>
</ul>
<blockquote>
<p>3、线程有几个状态？</p>
</blockquote>
<p>线程的状态：6个状态<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686474410156-2c42c511-caa1-47e2-a7ed-0917176b6e4e.png#averageHue=%23f8f6f6&clientId=udaf2058c-f549-4&from=drop&id=u19181597&originHeight=616&originWidth=965&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=173974&status=done&style=none&taskId=uec8f7401-4b38-4e9e-b2b4-94fa8158254&title=" alt="78c61007d62ab122867e5dd437fb4687_r.png"></p>
<ul>
<li>Runnable：就绪态</li>
<li>Blocked：阻塞态</li>
<li>Running：运行态</li>
</ul>
<blockquote>
<p>4、wait&#x2F;sleep的区别</p>
</blockquote>
<p><strong>1、来自不同的类</strong><br>wait &#x3D;&gt; Object<br>sleep &#x3D;&gt; Thread<br>一般情况企业中使用休眠是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TimeUnit.DAYS.sleep(<span class="number">1</span>); <span class="comment">//休眠1天</span></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>); <span class="comment">//休眠1s</span></span><br></pre></td></tr></table></figure>
<p><strong>2、关于锁的释放</strong><br>wait 会释放锁；<br>sleep睡觉了，不会释放锁；<br><strong>3、使用的范围是不同的</strong><br>wait 必须在同步代码块中；<br>sleep 可以在任何地方睡；<br><strong>4、是否需要捕获异常</strong><br>wait是不需要捕获异常；<br>sleep必须要捕获异常；</p>
<h1 id="2、锁"><a href="#2、锁" class="headerlink" title="2、锁"></a>2、锁</h1><h2 id="2-1-Lock锁【-】"><a href="#2-1-Lock锁【-】" class="headerlink" title="2.1 Lock锁【*】"></a>2.1 Lock锁【*】</h2><blockquote>
<p>1、传统的Synchronized</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真正的多线程开发</span></span><br><span class="line"><span class="comment"> * 线程就是一个单独的资源类，没有任何的附属操作！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//多线程操作</span></span><br><span class="line">        <span class="comment">//并发：多线程操作同一个资源类，把资源类丢入线程</span></span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//@FunctionalInterface 函数式接口 jdk1.8之后 lambda表达式</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">40</span>;i++)&#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">40</span>;i++)&#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">40</span>;i++)&#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//资源类</span></span><br><span class="line"><span class="comment">//属性+方法</span></span><br><span class="line"><span class="comment">//oop</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number=<span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//卖票的方式</span></span><br><span class="line">    <span class="comment">// synchronized 本质：队列，锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 卖出了第&quot;</span>+number+<span class="string">&quot; 张票,剩余：&quot;</span>+number+<span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">            number--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2、Lock接口</p>
</blockquote>
<p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727195732117.png#id=Mw0g4&originHeight=886&originWidth=1458&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ul>
<li>接口实现类</li>
</ul>
<p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/2020080112041218.png#id=AljRy&originHeight=202&originWidth=905&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ul>
<li>源码：</li>
</ul>
<p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727195818181.png#id=SUKwQ&originHeight=378&originWidth=1014&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>公平锁：</strong> 十分公平，必须先来后到~；<br><strong>非公平锁：</strong> 十分不公平，可以插队；**(默认为非公平锁)**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//多线程操作</span></span><br><span class="line">        <span class="comment">//并发：多线程操作同一个资源类，把资源类丢入线程</span></span><br><span class="line">        <span class="type">Ticket2</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket2</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">40</span>;i++) ticket.sale(); &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">40</span>;i++) ticket.sale(); &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">40</span>;i++) ticket.sale(); &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lock三部曲</span></span><br><span class="line"><span class="comment">//1、    Lock lock=new ReentrantLock();</span></span><br><span class="line"><span class="comment">//2、    lock.lock() 加锁</span></span><br><span class="line"><span class="comment">//3、    finally=&gt; 解锁：lock.unlock();</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket2</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number=<span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    Lock lock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//卖票的方式</span></span><br><span class="line">    <span class="comment">// 使用Lock 锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//业务代码</span></span><br><span class="line">            <span class="keyword">if</span>(number&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 卖出了第&quot;</span>+number+<span class="string">&quot; 张票,剩余：&quot;</span>+number+<span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">                number--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3、Synchronized 和 Lock区别</p>
</blockquote>
<ul>
<li>1、Synchronized 内置的Java关键字，Lock是一个Java类 </li>
<li>2、Synchronized 无法判断获取锁的状态，Lock可以判断 </li>
<li>3、Synchronized 会自动释放锁，lock必须要手动加锁和手动释放锁！<strong>可能会遇到死锁</strong> </li>
<li>4、Synchronized 线程1(获得锁-&gt;阻塞)、线程2(等待)；<br>lock就不一定会一直等待下去，<strong>lock会有一个trylock去尝试获取锁</strong>，不会造成长久的等待。 </li>
<li>5、Synchronized 是可重入锁，不可以中断的，非公平的；Lock，可重入的，可以判断锁，可以自己设置公平锁和非公平锁； </li>
<li>6、Synchronized 适合锁少量的代码同步问题，Lock适合锁大量的同步代码； <blockquote>
<p>锁到底是什么？ 如何判断锁的是谁？</p>
</blockquote>
</li>
</ul>
<p>锁是实现同步互斥的一种机制。</p>
<h2 id="2-2-公平锁-非公平锁"><a href="#2-2-公平锁-非公平锁" class="headerlink" title="2.2 公平锁&#x2F;非公平锁"></a>2.2 公平锁&#x2F;非公平锁</h2><p><strong>公平锁</strong>：非常公平；不能插队的，必须先来后到；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment"> * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>非公平锁</strong>：非常不公平，允许插队的，可以改变顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment"> * given fairness policy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-可重入锁"><a href="#2-3-可重入锁" class="headerlink" title="2.3 可重入锁"></a>2.3 可重入锁</h2><p>可重入锁(递归锁)<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686474593869-7b554d58-272b-4d80-a9dd-85416afff56a.png#averageHue=%23bcb9b7&clientId=udaf2058c-f549-4&id=RsRYg&originHeight=308&originWidth=519&originalType=binary&ratio=1&rotation=0&showTitle=false&size=49396&status=done&style=none&taskId=ua074200a-f757-459e-bbc1-7596a366736&title=" alt="image.png"></p>
<blockquote>
<p>1、Synchronized锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sms</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt; sms&quot;</span>);</span><br><span class="line">        call();<span class="comment">//这里也有一把锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt; call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2、lock锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//lock</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone2</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone2</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone2</span>&#123;</span><br><span class="line"></span><br><span class="line">    Lock lock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sms</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock(); <span class="comment">//细节：这个是两把锁，两个钥匙</span></span><br><span class="line">        <span class="comment">//lock锁必须配对，否则就会死锁在里面</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt; sms&quot;</span>);</span><br><span class="line">            call();<span class="comment">//这里也有一把锁</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt; call&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>lock锁必须配对，相当于lock和 unlock 必须数量相同；</li>
<li>在外面加的锁，也可以在里面解锁；在里面加的锁，在外面也可以解锁；</li>
</ul>
<h2 id="2-4-自旋锁"><a href="#2-4-自旋锁" class="headerlink" title="2.4 自旋锁"></a>2.4 自旋锁</h2><ul>
<li>spinlock<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>自我设计自旋锁：</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinlockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int 0</span></span><br><span class="line">    <span class="comment">//thread null</span></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference=<span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myLock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(thread.getName()+<span class="string">&quot;===&gt; mylock&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自旋锁</span></span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="literal">null</span>,thread))&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; ==&gt; 自旋中~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myunlock</span><span class="params">()</span>&#123;</span><br><span class="line">        Thread thread=Thread.currentThread();</span><br><span class="line">        System.out.println(thread.getName()+<span class="string">&quot;===&gt; myUnlock&quot;</span>);</span><br><span class="line">        atomicReference.compareAndSet(thread,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSpinLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ReentrantLock</span> <span class="variable">reentrantLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        reentrantLock.unlock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用CAS实现自旋锁</span></span><br><span class="line">        SpinlockDemo spinlockDemo=<span class="keyword">new</span> <span class="title class_">SpinlockDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            spinlockDemo.myLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                spinlockDemo.myunlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            spinlockDemo.myLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                spinlockDemo.myunlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
运行结果：<br><strong>t2进程必须等待t1进程Unlock后，才能Unlock，在这之前进行自旋等待</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686474594443-68dbe5c6-9e50-460f-a167-64e646713df0.png#averageHue=%233f3831&clientId=udaf2058c-f549-4&id=rq5D1&originHeight=555&originWidth=1759&originalType=binary&ratio=1&rotation=0&showTitle=false&size=837615&status=done&style=none&taskId=u0ffc500d-ff84-4205-8b90-979707ec6c2&title=" alt="image.png"></li>
</ul>
<h2 id="2-5-死锁"><a href="#2-5-死锁" class="headerlink" title="2.5 死锁"></a>2.5 死锁</h2><blockquote>
<p>1、死锁是什么？</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686474593909-c7738312-3c47-4114-bea3-b3d8d9227e12.png#averageHue=%23c4c8c2&clientId=udaf2058c-f549-4&id=d8Aoq&originHeight=226&originWidth=356&originalType=binary&ratio=1&rotation=0&showTitle=false&size=53596&status=done&style=none&taskId=u140ef82d-38a0-4d24-a9cc-af789a43e6f&title=" alt="image.png"><br>死锁测试，怎么排除死锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ogj.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String lockA= <span class="string">&quot;lockA&quot;</span>;</span><br><span class="line">        String lockB= <span class="string">&quot;lockB&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>(lockA,lockB),<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>(lockB,lockA),<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lockA;</span><br><span class="line">    <span class="keyword">private</span> String lockB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String lockA, String lockB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lockA = lockA;</span><br><span class="line">        <span class="built_in">this</span>.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; lock&quot;</span>+lockA+<span class="string">&quot;===&gt;get&quot;</span>+lockB);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; lock&quot;</span>+lockB+<span class="string">&quot;===&gt;get&quot;</span>+lockA);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2、解决问题</p>
</blockquote>
<p><strong>1、使用jps定位进程号，jdk的bin目录下： 有一个jps</strong><br>命令：<code>jps -l</code><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686474594034-8ac72bce-9b63-4703-8414-2df036fe183b.png#averageHue=%23494239&clientId=udaf2058c-f549-4&id=Jr8GT&originHeight=305&originWidth=856&originalType=binary&ratio=1&rotation=0&showTitle=false&size=210104&status=done&style=none&taskId=u757b59d0-39f4-4e43-80bb-83516a44b22&title=" alt="image.png"><br><strong>2、使用</strong><code>**jstack**</code>** 进程进程号 找到死锁信息**<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686474594325-33d8872c-48d5-4c1c-86e0-b221ada432f5.png#averageHue=%23453e36&clientId=udaf2058c-f549-4&id=QKtMQ&originHeight=660&originWidth=1024&originalType=binary&ratio=1&rotation=0&showTitle=false&size=617200&status=done&style=none&taskId=u79f160c6-a322-4d06-950e-36243da8366&title=" alt="image.png"><br><strong>一般情况信息在最后：</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686474595487-e6e6ff86-d250-4a09-9454-a471180a7a43.png#averageHue=%23493d35&clientId=udaf2058c-f549-4&id=KzHpQ&originHeight=616&originWidth=964&originalType=binary&ratio=1&rotation=0&showTitle=false&size=495542&status=done&style=none&taskId=u114997c2-1ec1-444d-a76e-6c79e047fc7&title=" alt="image.png"></p>
<h2 id="2-6-读写锁"><a href="#2-6-读写锁" class="headerlink" title="2.6 读写锁"></a>2.6 读写锁</h2><p>先对于不加锁的情况：<br>如果我们做一个我们自己的cache缓存。分别有写入操作、读取操作；<br>我们采用五个线程去写入，使用十个线程去读取。<br>我们来看一下这个的效果，如果我们不加锁的情况！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ogj.rw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyCache_ReadWriteLock</span> <span class="variable">mycache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCache_ReadWriteLock</span>();</span><br><span class="line">        <span class="comment">//开启5个线程 写入数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">5</span> ; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                mycache.put(String.valueOf(finalI),String.valueOf(finalI));</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开启10个线程去读取数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">o</span> <span class="operator">=</span> mycache.get(String.valueOf(finalI));</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCache_ReadWriteLock</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String,String&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用读写锁</span></span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock readWriteLock=<span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="comment">//普通锁</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key,String value)</span>&#123;</span><br><span class="line">        <span class="comment">//写入</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 线程 开始写入&quot;</span>);</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 线程 写入OK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        <span class="comment">//得到</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 线程 开始读取&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">o</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 线程 读取OK&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Thread-0 线程 开始写入</span><br><span class="line">Thread-4 线程 开始写入  <span class="comment"># 插入了其他的线程进行写入</span></span><br><span class="line">Thread-4 线程 写入OK</span><br><span class="line">Thread-3 线程 开始写入</span><br><span class="line">Thread-1 线程 开始写入</span><br><span class="line">Thread-2 线程 开始写入</span><br><span class="line">Thread-1 线程 写入OK</span><br><span class="line">Thread-3 线程 写入OK</span><br><span class="line">Thread-0 线程 写入OK   <span class="comment"># 对于这种情况会出现 数据不一致等情况</span></span><br><span class="line">Thread-2 线程 写入OK</span><br><span class="line">Thread-5 线程 开始读取</span><br><span class="line">Thread-6 线程 开始读取</span><br><span class="line">Thread-6 线程 读取OK</span><br><span class="line">Thread-7 线程 开始读取</span><br><span class="line">Thread-7 线程 读取OK</span><br><span class="line">Thread-5 线程 读取OK</span><br><span class="line">Thread-8 线程 开始读取</span><br><span class="line">Thread-8 线程 读取OK</span><br><span class="line">Thread-9 线程 开始读取</span><br><span class="line">Thread-9 线程 读取OK</span><br><span class="line">Thread-10 线程 开始读取</span><br><span class="line">Thread-11 线程 开始读取</span><br><span class="line">Thread-12 线程 开始读取</span><br><span class="line">Thread-12 线程 读取OK</span><br><span class="line">Thread-10 线程 读取OK</span><br><span class="line">Thread-14 线程 开始读取</span><br><span class="line">Thread-13 线程 开始读取</span><br><span class="line">Thread-13 线程 读取OK</span><br><span class="line">Thread-11 线程 读取OK</span><br><span class="line">Thread-14 线程 读取OK</span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br></pre></td></tr></table></figure>
<p>所以如果我们不加锁的情况，多线程的读写会造成数据不可靠的问题。<br>我们也可以采用<strong>synchronized</strong>这种重量锁和轻量锁 <strong>lock</strong>去保证数据的可靠。<br>但是这次我们采用更细粒度的锁：<strong>ReadWriteLock</strong> 读写锁来保证<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686482351456-b9b0209f-f928-4b31-8608-d9547230560c.png#averageHue=%23f3f2f2&clientId=uc59d1b67-bcbd-4&id=D3Gpl&originHeight=865&originWidth=1151&originalType=binary&ratio=1&rotation=0&showTitle=false&size=99893&status=done&style=none&taskId=ucfeb32ac-c2e3-46ef-974e-d0aa69c3ab0&title=" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ogj.rw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyCache_ReadWriteLock</span> <span class="variable">mycache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCache_ReadWriteLock</span>();</span><br><span class="line">        <span class="comment">//开启5个线程 写入数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">5</span> ; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                mycache.put(String.valueOf(finalI),String.valueOf(finalI));</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开启10个线程去读取数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">o</span> <span class="operator">=</span> mycache.get(String.valueOf(finalI));</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCache_ReadWriteLock</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String,String&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用读写锁</span></span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock readWriteLock=<span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="comment">//普通锁</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key,String value)</span>&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//写入</span></span><br><span class="line">            <span class="comment">//业务流程</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 线程 开始写入&quot;</span>);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 线程 写入OK&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.writeLock().unlock(); <span class="comment">//解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        String o=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//得到</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 线程 开始读取&quot;</span>);</span><br><span class="line">            o = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 线程 读取OK&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Thread-0 线程 开始写入</span><br><span class="line">Thread-0 线程 写入OK</span><br><span class="line">Thread-1 线程 开始写入</span><br><span class="line">Thread-1 线程 写入OK</span><br><span class="line">Thread-2 线程 开始写入</span><br><span class="line">Thread-2 线程 写入OK</span><br><span class="line">Thread-3 线程 开始写入</span><br><span class="line">Thread-3 线程 写入OK</span><br><span class="line">Thread-4 线程 开始写入</span><br><span class="line">Thread-4 线程 写入OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上 整个过程没有再出现错乱的情况，对于读取，我们运行多个线程同时读取，</span></span><br><span class="line"><span class="comment"># 因为这样不会造成数据不一致问题，也能在一定程度上提高效率</span></span><br><span class="line">Thread-9 线程 开始读取</span><br><span class="line">Thread-9 线程 读取OK</span><br><span class="line">Thread-10 线程 开始读取</span><br><span class="line">Thread-5 线程 开始读取</span><br><span class="line">Thread-11 线程 开始读取</span><br><span class="line">Thread-11 线程 读取OK</span><br><span class="line">Thread-10 线程 读取OK</span><br><span class="line">Thread-7 线程 开始读取</span><br><span class="line">Thread-7 线程 读取OK</span><br><span class="line">Thread-6 线程 开始读取</span><br><span class="line">Thread-5 线程 读取OK</span><br><span class="line">Thread-14 线程 开始读取</span><br><span class="line">Thread-8 线程 开始读取</span><br><span class="line">Thread-14 线程 读取OK</span><br><span class="line">Thread-6 线程 读取OK</span><br><span class="line">Thread-13 线程 开始读取</span><br><span class="line">Thread-12 线程 开始读取</span><br><span class="line">Thread-13 线程 读取OK</span><br><span class="line">Thread-8 线程 读取OK</span><br><span class="line">Thread-12 线程 读取OK</span><br></pre></td></tr></table></figure>


<h1 id="3、四大函数式接口【-】"><a href="#3、四大函数式接口【-】" class="headerlink" title="3、四大函数式接口【**】"></a>3、四大函数式接口【**】</h1><p>新时代的程序员：<strong>lambda表达式、链式编程、函数式接口、Stream流式计算</strong></p>
<ul>
<li>函数式接口：只有一个方法的接口<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//超级多的@FunctionalInterface</span></span><br><span class="line"><span class="comment">//简化编程模型，在新版本的框架底层大量应用</span></span><br><span class="line"><span class="comment">//foreach()的参数也是一个函数式接口，消费者类的函数式接口</span></span><br></pre></td></tr></table></figure>
<img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686474878495-b726c054-4533-4596-b26c-76515c28da01.png#averageHue=%23fbf6f6&clientId=udaf2058c-f549-4&id=YqH2n&originHeight=883&originWidth=368&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43569&status=done&style=none&taskId=u6f5e2cac-2d9a-4b67-baa6-965097413f0&title=" alt="image.png"><br>函数型接口可以使用lambda表达式；<br><strong>代码测试：</strong><blockquote>
<p>1、Function函数型接口</p>
</blockquote>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686474878625-10bab090-7c46-4766-8171-06fccc388663.png#averageHue=%233f352f&clientId=udaf2058c-f549-4&id=ZXqLh&originHeight=323&originWidth=650&originalType=binary&ratio=1&rotation=0&showTitle=false&size=194893&status=done&style=none&taskId=u2046f529-e083-488d-8cd9-52aabf2ce09&title=" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function函数型接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Function&lt;String,String&gt; function = (str) -&gt;&#123;<span class="keyword">return</span> str;&#125;;</span><br><span class="line">        System.out.println(function.apply(<span class="string">&quot;starasdas&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2、Predicate断定型接口</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686474879209-57ad5c72-cf6d-4517-b08e-8737423364a5.png#averageHue=%2339322d&clientId=udaf2058c-f549-4&id=DSmQO&originHeight=574&originWidth=772&originalType=binary&ratio=1&rotation=0&showTitle=false&size=429281&status=done&style=none&taskId=u64a55449-e768-4de3-a0eb-0c2ac8c53d1&title=" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 断定型接口：有一个输入参数，返回值只能是 布尔值！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//判断字符串是否为空</span></span><br><span class="line">        Predicate&lt;String&gt; predicate = (str)-&gt;&#123;<span class="keyword">return</span> str.isEmpty();&#125;;</span><br><span class="line">        System.out.println(predicate.test(<span class="string">&quot;11&quot;</span>));</span><br><span class="line">        System.out.println(predicate.test(<span class="string">&quot;&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3、Consummer 消费型接口</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686474879306-a314a3cb-a98d-465f-84a6-803d37ea601b.png#averageHue=%233a322b&clientId=udaf2058c-f549-4&id=Uj5aH&originHeight=454&originWidth=882&originalType=binary&ratio=1&rotation=0&showTitle=false&size=381463&status=done&style=none&taskId=u51c7fa20-065a-4407-9cd4-19e874cdd7e&title=" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费型接口 没有返回值！只有输入！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Consumer&lt;String&gt; consumer = (str)-&gt;&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;;</span><br><span class="line">        consumer.accept(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>4、Supplier供给型接口</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686474879459-381479b4-6242-4c2e-8d0c-a15636196286.png#averageHue=%233e362e&clientId=udaf2058c-f549-4&id=rp0Ma&originHeight=334&originWidth=680&originalType=binary&ratio=1&rotation=0&showTitle=false&size=197256&status=done&style=none&taskId=ube9aacf8-dce7-4748-898c-0adfd4c1ab8&title=" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 供给型接口，只返回，不输入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Supplier&lt;String&gt; supplier = ()-&gt;&#123;<span class="keyword">return</span> <span class="string">&quot;1024&quot;</span>;&#125;;</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="5、生产者和消费者【-】"><a href="#5、生产者和消费者【-】" class="headerlink" title="5、生产者和消费者【*】"></a>5、生产者和消费者【*】</h1><p><strong>Synchronized wait notify</strong>可以实现，该方法是传统版本；<br>我们这次使用lock版本</p>
<blockquote>
<p>1、Synchronized版本</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                data.increment();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                data.decrement();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>&#123;</span><br><span class="line">    <span class="comment">//数字  资源类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//+1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span>(number!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//等待操作</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;&quot;</span>+number);</span><br><span class="line">        <span class="comment">//通知其他线程 我+1完毕了</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//等待操作</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;&quot;</span>+number);</span><br><span class="line">        <span class="comment">//通知其他线程  我-1完毕了</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>问题存在，A线程B线程，现在如果我有四个线程A B C D！</strong></p>
</blockquote>
<p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727200107238.png#id=cMHFY&originHeight=798&originWidth=927&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>解决方案</strong>： <strong>if 改为while即可，防止虚假唤醒</strong><br>这样就不存在问题了：<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727200208118.png#id=nNsEc&originHeight=998&originWidth=1065&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<blockquote>
<p>2、<strong>JUC版本的生产者和消费者问题</strong></p>
</blockquote>
<p><strong>await、signal 替换 wait、notify</strong><br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727200241338.png#id=mBFNs&originHeight=290&originWidth=763&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>通过Lock找到Condition<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727200309313.png#id=StwyU&originHeight=645&originWidth=692&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data2</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data2</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            data.increment();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            data.decrement();</span><br><span class="line">        &#125;&#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            data.increment();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            data.decrement();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data2</span>&#123;</span><br><span class="line">    <span class="comment">//数字  资源类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//lock锁</span></span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//+1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span>  &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//业务</span></span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//等待操作</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;&quot;</span>+number);</span><br><span class="line">            <span class="comment">//通知其他线程 我+1完毕了</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span>  &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//业务</span></span><br><span class="line">            <span class="keyword">while</span> (number==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//等待操作</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;&quot;</span>+number);</span><br><span class="line">            <span class="comment">//通知其他线程 我+1完毕了</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>3、<strong>Condition的优势</strong>：精准的通知和唤醒的线程！</p>
</blockquote>
<p><strong>如果我们要指定通知的下一个进行顺序怎么办呢？ 我们可以使用Condition来指定通知进程~</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A 执行完 调用B</span></span><br><span class="line"><span class="comment"> * B 执行完 调用C</span></span><br><span class="line"><span class="comment"> * C 执行完 调用A</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data3</span> <span class="variable">data3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data3</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                data3.printA();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                data3.printB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                data3.printC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data3</span>&#123;</span><br><span class="line">    <span class="comment">//资源类</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//1A 2B 3C</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//业务 判断 -&gt; 执行 -&gt; 通知</span></span><br><span class="line">            <span class="keyword">while</span>(number!=<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//操作</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;,AAAAA&quot;</span>);</span><br><span class="line">            <span class="comment">//唤醒指定的线程</span></span><br><span class="line">            number=<span class="number">2</span>;</span><br><span class="line">            condition2.signal(); <span class="comment">// 唤醒2</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//业务 判断 -&gt; 执行 -&gt; 通知</span></span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">2</span>)&#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;,BBBBB&quot;</span>);</span><br><span class="line">            <span class="comment">//唤醒3</span></span><br><span class="line">            number=<span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printC</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//业务 判断 -&gt; 执行 -&gt; 通知</span></span><br><span class="line">            <span class="keyword">while</span>(number!=<span class="number">3</span>)&#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;,CCCCC&quot;</span>);</span><br><span class="line">            <span class="comment">//唤醒1</span></span><br><span class="line">            number=<span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727200424210.png#id=lLlA4&originHeight=571&originWidth=772&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h1 id="6、线程池【-】"><a href="#6、线程池【-】" class="headerlink" title="6、线程池【*】"></a>6、线程池【*】</h1><p>线程池：<strong>三大方法、7大参数、4种拒绝策略</strong></p>
<blockquote>
<p>1、池化技术</p>
</blockquote>
<p>程序的运行，本质：占用系统的资源！我们需要去优化资源的使用 &#x3D;&#x3D;&#x3D;&gt; 池化技术<br>线程池、JDBC的连接池、内存池、对象池 等等。。。。<br>资源的创建、销毁十分消耗资源<br><strong>池化技术</strong>：事先准备好一些资源，如果有人要用，就来我这里拿，用完之后还给我，以此来提高效率。<br><strong>线程池的好处：</strong><br>1、降低资源的消耗；<br>2、提高响应的速度；<br>3、方便管理；<br><strong>线程复用、可以控制最大并发数、管理线程；</strong></p>
<blockquote>
<p>2、线程池：三大方法</p>
</blockquote>
<ul>
<li><strong>ExecutorService threadPool &#x3D; Executors.newSingleThreadExecutor();&#x2F;&#x2F;单个线程</strong></li>
<li><strong>ExecutorService threadPool2 &#x3D; Executors.newFixedThreadPool(5); &#x2F;&#x2F;创建一个固定的线程池的大小</strong></li>
<li><strong>ExecutorService threadPool3 &#x3D; Executors.newCachedThreadPool(); &#x2F;&#x2F;可伸缩的</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//工具类 Executors 三大方法；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();<span class="comment">//单个线程</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool2</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>); <span class="comment">//创建一个固定的线程池的大小</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool3</span> <span class="operator">=</span> Executors.newCachedThreadPool(); <span class="comment">//可伸缩的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程池用完必须要关闭线程池</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">100</span> ; i++) &#123;</span><br><span class="line">                <span class="comment">//通过线程池创建线程</span></span><br><span class="line">                threadPool.execute(()-&gt;&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+ <span class="string">&quot; ok&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>3、7大参数</p>
</blockquote>
<p>源码分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本质：三种方法都是开启的<strong>ThreadPoolExecutor</strong></p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数解释</th>
</tr>
</thead>
<tbody><tr>
<td>int <strong>corePoolSize</strong></td>
<td>核心线程池大小</td>
</tr>
<tr>
<td>int <strong>maximumPoolSize</strong></td>
<td>最大的线程池大小</td>
</tr>
<tr>
<td>long <strong>keepAliveTime</strong></td>
<td>超时了没有人调用就会释放</td>
</tr>
<tr>
<td>TimeUnit <strong>unit</strong></td>
<td>超时单位</td>
</tr>
<tr>
<td>BlockingQueue <strong>workQueue</strong></td>
<td>阻塞队列</td>
</tr>
<tr>
<td>ThreadFactory <strong>threadFactory</strong></td>
<td>线程工厂 创建线程的 一般不用动</td>
</tr>
<tr>
<td>RejectedExecutionHandler <strong>handler</strong></td>
<td>拒绝策略</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,  //核心线程池大小</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize, //最大的线程池大小</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,  //超时了没有人调用就会释放</span></span><br><span class="line"><span class="params">                          TimeUnit unit, //超时单位</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue, //阻塞队列</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory, //线程工厂 创建线程的 一般不用动</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler //拒绝策略</span></span><br><span class="line"><span class="params">                         )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686475029099-68638ed8-1652-41ba-8b79-f50b54e18c6e.png#averageHue=%23f5f6f2&clientId=udaf2058c-f549-4&id=se32r&originHeight=276&originWidth=817&originalType=binary&ratio=1&rotation=0&showTitle=false&size=190948&status=done&style=none&taskId=u7cd9458a-45fd-4122-aced-75595e6b133&title=" alt="image.png"><br>阿里巴巴的Java操作手册中明确说明：对于Integer.MAX_VALUE初始值较大，所以一般情况我们要使用底层的<strong>ThreadPoolExecutor</strong>来创建线程池。</p>
<blockquote>
<p>4、业务图</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686475029084-98a6441f-9f57-475f-a19b-39f399df799a.png#averageHue=%23f8f8f5&clientId=udaf2058c-f549-4&id=MfniU&originHeight=502&originWidth=808&originalType=binary&ratio=1&rotation=0&showTitle=false&size=171268&status=done&style=none&taskId=ub983dc16-bc22-4ee7-a0fa-ead5f4d3c4e&title=" alt="image.png"></p>
<blockquote>
<p>手动创建线程池</p>
</blockquote>
<p><code>**// todo:P24**</code></p>
<blockquote>
<p>5、拒绝策略4种</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686475029626-070dc59b-5ff0-40ea-ad07-49dbf7b162f8.png#averageHue=%2339342f&clientId=udaf2058c-f549-4&id=wxZll&originHeight=560&originWidth=1239&originalType=binary&ratio=1&rotation=0&showTitle=false&size=500427&status=done&style=none&taskId=ube24affe-5581-4430-875c-6cc9d9fac9d&title=" alt="image.png"><br><strong>（1）new ThreadPoolExecutor.AbortPolicy()：</strong> &#x2F;&#x2F;该拒绝策略为：银行满了，还有人进来，不处理这个人的，并抛出异常<br>超出最大承载，就会抛出异常：队列容量大小+maxPoolSize<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686475030605-7dcd953f-8bc0-4886-abd9-12c1c869b24e.png#averageHue=%233d3732&clientId=udaf2058c-f549-4&id=Ex1vP&originHeight=955&originWidth=1891&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1496156&status=done&style=none&taskId=u0bb42443-4acb-4498-b03e-2a3e5143d1a&title=" alt="image.png"></p>
<p><strong>（2）new ThreadPoolExecutor.CallerRunsPolicy()：</strong> &#x2F;&#x2F;该拒绝策略为：哪来的去哪里 main线程进行处理<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686475032072-e7288218-05ef-451f-b33d-14ca650382a7.png#averageHue=%233d3732&clientId=udaf2058c-f549-4&id=AYe4n&originHeight=925&originWidth=1795&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1405455&status=done&style=none&taskId=uca01df48-af62-4f4e-aab3-24082da189a&title=" alt="image.png"></p>
<p><strong>（3）new ThreadPoolExecutor.DiscardPolicy():</strong> &#x2F;&#x2F;该拒绝策略为：队列满了,丢掉异常，不会抛出异常。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686475032476-3bfe7a9a-37e7-4669-895b-68cdc0a668fa.png#averageHue=%23403934&clientId=udaf2058c-f549-4&id=IFuZB&originHeight=952&originWidth=1573&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1299306&status=done&style=none&taskId=u26275dd3-c3ce-4e0d-9571-8702223e70b&title=" alt="image.png"></p>
<p><strong>（4）new ThreadPoolExecutor.DiscardOldestPolicy()：</strong> &#x2F;&#x2F;该拒绝策略为：队列满了，尝试去和最早的进程竞争，不会抛出异<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686475032835-38e439f4-68c0-43fb-b399-2718efdbb131.png#averageHue=%233e3832&clientId=udaf2058c-f549-4&id=JtBr9&originHeight=998&originWidth=1709&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1413894&status=done&style=none&taskId=u9d2f8a9b-dc70-4f22-b511-d83c1b545af&title=" alt="image.png"></p>
<blockquote>
<p>6、小结和拓展</p>
</blockquote>
<p>如何去设置线程池的最大大小如何去设置<br>CPU密集型和IO密集型！<br><strong>1、CPU密集型：电脑的核数是几核就选择几；选择maximunPoolSize的大小</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686475032119-03822b00-8386-4e77-9104-12f2abd7adbc.png#averageHue=%233b3530&clientId=udaf2058c-f549-4&id=dhsHH&originHeight=274&originWidth=1036&originalType=binary&ratio=1&rotation=0&showTitle=false&size=277251&status=done&style=none&taskId=u789238c2-927d-4cf4-b0e2-bcc51896c06&title=" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们可以使用代码来来获取逻辑处理器数量。</span></span><br><span class="line">Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></table></figure>
<p>于是<strong>cpu密集型</strong>的写法如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1686475033453-024dda41-95db-4cd6-9c17-941bf30e550c.png#averageHue=%233c3630&clientId=udaf2058c-f549-4&id=s6dJo&originHeight=321&originWidth=1123&originalType=binary&ratio=1&rotation=0&showTitle=false&size=349672&status=done&style=none&taskId=u49220ca9-37c5-4b27-a9c9-a82472918e9&title=" alt="image.png"></p>
<p><strong>2、I&#x2F;O密集型：</strong><br>在程序中有15个大型任务，io十分占用资源；I&#x2F;O密集型就是判断我们程序中十分耗I&#x2F;O的线程数量，大约是最大I&#x2F;O数的一倍到两倍之间。</p>
<h1 id="7、常见问题"><a href="#7、常见问题" class="headerlink" title="7、常见问题"></a>7、常见问题</h1><h2 id="7-1-8锁现象【-】"><a href="#7-1-8锁现象【-】" class="headerlink" title="7.1 8锁现象【*】"></a>7.1 8锁现象【*】</h2><blockquote>
<p>1、<strong>如何判断锁的是谁！锁到底锁的是谁？</strong></p>
</blockquote>
<p>锁会锁住：<strong>对象、Class</strong><br><strong>深刻理解我们的锁</strong></p>
<ol>
<li><strong>问题1：</strong></li>
</ol>
<p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727200505228.png#id=AwZiG&originHeight=752&originWidth=944&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>结果是：先发短信，如何再打电话！<br><strong>为什么？ 如果你认为是顺序在前？ 这个答案是错误的！</strong></p>
<ol start="2">
<li><strong>问题2：</strong></li>
</ol>
<p><strong>我们再来看：我们让发短信 延迟4s</strong><br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727200541706.png#id=Hl47l&originHeight=727&originWidth=917&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>现在结果是什么呢？<br>结果：<strong>还是先发短信，然后再打电话！</strong><br><strong>why？</strong><br>原因：并不是顺序执行！是因为synchronized 锁的对象是方法的调用！对于两个方法用的是同一个锁，谁先拿到谁先执行！另外一个则等待！</p>
<ol start="3">
<li><strong>问题3：</strong></li>
</ol>
<p><strong>如果我们添加一个普通方法，那么先执行哪一个呢？</strong><br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727200635437.png#id=vDHU6&originHeight=776&originWidth=751&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>答案是：<em><em>先执行hello，然后再执行发短信！</em>_原因是hello是一个</em>_普通方法<strong>，</strong>不受synchronized锁的影响**，但是我发现，如果我把发短信里面的延迟4秒去掉，那么就会顺序执行，先执行发短信然后再执行hello，原因应该是顺序执行的原因吧,不是太理解。</p>
<ol start="4">
<li><strong>问题4：</strong></li>
</ol>
<p><strong>如果我们使用的是两个对象，一个调用发短信，一个调用打电话，那么整个顺序是怎么样的呢？</strong><br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727200753229.png#id=Zq2hy&originHeight=740&originWidth=756&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>答案是：先打电话，后发短信。原因：<strong>在发短信方法中延迟了4s，又因为synchronized锁的是对象，但是我们这使用的是两个对象，所以每个对象都有一把锁，所以不会造成锁的等待。正常执行</strong></p>
<ol start="5">
<li><strong>问题5，6：</strong></li>
</ol>
<p><strong>如果我们把synchronized的方法加上static变成静态方法！那么顺序又是怎么样的呢？</strong><br>（1）我们先来使用一个对象调用两个方法！<br>答案是：<strong>先发短信,后打电话</strong><br>（2）如果我们使用两个对象调用两个方法！<br>答案是：<strong>还是先发短信，后打电话</strong><br>原因是什么呢？ <strong>为什么加了static就始终前面一个对象先执行呢！为什么后面会等待呢？</strong><br>原因是：<strong>对于static静态方法来说，对于整个类Class来说只有一份，对于不同的对象使用的是同一份方法，相当于这个方法是属于这个类的，如果静态static方法使用synchronized锁定，那么这个synchronized锁会锁住整个对象！不管多少个对象，对于静态的锁都只有一把锁，谁先拿到这个锁就先执行，其他的进程都需要等待！</strong></p>
<ol start="6">
<li><strong>问题7：</strong></li>
</ol>
<p><strong>如果我们使用一个静态同步方法、一个同步方法、一个对象调用顺序是什么？</strong><br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727200947247.png#id=lSCWH&originHeight=624&originWidth=925&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>明显答案是：先打电话，后发短信了。<br><strong>因为一个锁的是Class类模板，一个锁的是对象调用者。后面那个打电话不需要等待发短信，直接运行就可以了。</strong></p>
<ol start="7">
<li><strong>问题8：</strong></li>
</ol>
<p>如果我们使用一个静态同步方法、一个同步方法、两个对象调用顺序是什么呢？<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727201304983.png#id=MOkKT&originHeight=628&originWidth=868&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>当然答案是：先打电话、后发短信！<br>因为两个对象，一样的原因：<strong>两把锁锁的不是同一个东西，所以后面的第二个对象不需要等待第一个对象的执行。</strong></p>
<blockquote>
<p>2、小结</p>
</blockquote>
<p><strong>new</strong> 出来的 this 是具体的一个对象<br><strong>static Class</strong> 是唯一的一个模板</p>
<h2 id="7-2-集合类不安全"><a href="#7-2-集合类不安全" class="headerlink" title="7.2 集合类不安全"></a>7.2 集合类不安全</h2><blockquote>
<p>1、List不安全</p>
</blockquote>
<p>我们来看一下List这个集合类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java.util.ConcurrentModificationException 并发修改异常！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Object&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                arrayList.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(arrayList);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会造成：<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727201349859.png#id=Kd5lF&originHeight=374&originWidth=855&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>ArrayList 在并发情况下是不安全的！</strong></p>
<ul>
<li>解决方案：</li>
</ul>
<p><strong>1、切换成Vector就是线程安全的啦！</strong><br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727201419457.png#id=baEHd&originHeight=857&originWidth=1272&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>2、使用Collections.synchronizedList(new ArrayList&lt;&gt;());</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Object&gt; arrayList = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                arrayList.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(arrayList);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3、使用JUC中的包：List arrayList &#x3D; new CopyOnWriteArrayList&lt;&gt;();</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Object&gt; arrayList = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                arrayList.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(arrayList);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CopyOnWriteArrayList</strong>：写入时复制！ <strong>COW 计算机程序设计领域的一种优化策略</strong><br>多个线程调用的时候，list，读取的时候，固定的，写入（存在覆盖操作）；在写入的时候避免覆盖，造成数据错乱的问题；</p>
<blockquote>
<p>2、<strong>CopyOnWriteArrayList</strong>比<strong>Vector</strong>厉害在哪里？</p>
</blockquote>
<p><strong>Vector</strong>底层是使用<strong>synchronized</strong>关键字来实现的：效率特别低下。<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727201526105.png#id=adQwB&originHeight=557&originWidth=1279&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>CopyOnWriteArrayList</strong>使用的是Lock锁，效率会更加高效！<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727201546295.png#id=bnRJl&originHeight=456&originWidth=1014&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<blockquote>
<p>3、Set不安全</p>
</blockquote>
<p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727201604399.png#id=JMm7g&originHeight=384&originWidth=597&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>和List、Set同级的还有一个BlockingQueue 阻塞队列；<br><strong>Set和List同理可得:</strong> 多线程情况下，普通的Set集合是线程不安全的；<br>解决方案还是两种：</p>
<ul>
<li>使用Collections工具类的<strong>synchronized</strong>包装的Set类</li>
<li>使用CopyOnWriteArraySet 写入复制的<strong>JUC</strong>解决方案<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同理：java.util.ConcurrentModificationException</span></span><br><span class="line"><span class="comment">// 解决方案：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Set&lt;String&gt; hashSet = Collections.synchronizedSet(new HashSet&lt;&gt;()); //解决方案1</span></span><br><span class="line">        Set&lt;String&gt; hashSet = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();<span class="comment">//解决方案2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                hashSet.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(hashSet);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>HashSet底层是什么？</strong><br>hashSet底层就是一个<strong>HashMap</strong>；<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//add 本质其实就是一个map的key，map的key是无法重复的，所以使用的就是map存储</span></span><br><span class="line"><span class="comment">//hashSet就是使用了hashmap key不能重复的原理</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//PRESENT是什么？ 是一个常量  不会改变的常量  无用的占位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>4、Map不安全</p>
</blockquote>
<p>回顾map的基本操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//map 是这样用的吗？  不是，工作中不使用这个</span><br><span class="line">//默认等价什么？ new HashMap&lt;&gt;(16,0.75);</span><br><span class="line">Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">//加载因子、初始化容量</span><br></pre></td></tr></table></figure>
<p>默认<strong>加载因子是0.75</strong>,默认的<strong>初始容量是16</strong><br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727201710950.png#id=NQtfi&originHeight=544&originWidth=904&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>同样的HashMap基础类也存在<strong>并发修改异常</strong>！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//map 是这样用的吗？  不是，工作中不使用这个</span></span><br><span class="line">        <span class="comment">//默认等价什么？ new HashMap&lt;&gt;(16,0.75);</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//加载因子、初始化容量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                map.put(Thread.currentThread().getName(),UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>结果同样的出现了：<strong>异常java.util.ConcurrentModificationException 并发修改异常</strong><br><strong>解决方案：</strong></p>
<ul>
<li><strong>使用Collections.synchronizedMap(new HashMap&lt;&gt;());处理</strong>；</li>
<li><strong>使用ConcurrentHashMap进行并发处理</strong></li>
</ul>
<p>TODO:研究ConcurrentHashMap底层原理：<br>这里我们可以直接去研究一下，这个也是相当重要的。</p>
<h2 id="7-3-Callable-简单"><a href="#7-3-Callable-简单" class="headerlink" title="7.3 Callable(简单)"></a>7.3 Callable(简单)</h2><p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727201823382.png#id=fHqV5&originHeight=599&originWidth=1225&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>1、可以有返回值；</strong><br><strong>2、可以抛出异常；</strong><br><strong>3、方法不同，run()&#x2F;call()</strong></p>
<blockquote>
<p>1、代码测试</p>
</blockquote>
<p>传统使用线程方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>()).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<strong>Callable</strong>进行多线程操作：<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727201858566.png#id=vcgHa&originHeight=433&originWidth=847&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>Calleable 泛型T就是<strong>call运行方法的返回值类型</strong>；<br>但是<strong>如何使用</strong>呢？<br><strong>Callable怎么放入到Thread里面呢？</strong><br>源码分析：<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727201934861.png#id=egkRP&originHeight=796&originWidth=1120&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>对于Thread运行，只能传入Runnable类型的参数；<br>我们这是Callable 怎么办呢？<br>看JDK api文档：<br>在Runnable里面有一个叫做FutureTask的实现类，我们进去看一下。<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727202005417.png#id=Huec4&originHeight=845&originWidth=972&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>FutureTask中可以接受Callable参数；<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727202022160.png#id=mji8H&originHeight=484&originWidth=632&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>这样我们就可以先把Callable 放入到FutureTask中， 如何再把FutureTask 放入到Thread就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="comment">//            new Thread(new Runnable()).start();</span></span><br><span class="line"><span class="comment">//            new Thread(new FutureTask&lt;&gt;( Callable)).start();</span></span><br><span class="line">            MyThread thread= <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">            <span class="comment">//适配类：FutureTask</span></span><br><span class="line">            FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(thread);</span><br><span class="line">            <span class="comment">//放入Thread使用</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask,String.valueOf(i)).start();</span><br><span class="line">            <span class="comment">//获取返回值</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;返回值：&quot;</span>+ s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Call:&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;String&quot;</span>+Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以使用Callable来进行多线程编程了，并且我们发现可以有返回值，并且可以抛出异常。<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727202113698.png#id=ygC4v&originHeight=507&originWidth=1023&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>注意两个重点：<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727202135656.png#id=G1nkM&originHeight=560&originWidth=1202&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="7-4-阻塞队列"><a href="#7-4-阻塞队列" class="headerlink" title="7.4 阻塞队列"></a>7.4 阻塞队列</h2><ul>
<li>阻塞队列</li>
</ul>
<p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727202624665.png#id=kd4ld&originHeight=394&originWidth=766&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>阻塞队列jdk1.8文档解释：<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727202645162.png#id=LiCSl&originHeight=302&originWidth=781&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<blockquote>
<p><strong>1、BlockingQueue</strong></p>
</blockquote>
<p>blockingQueue 是Collection的一个子类；<br>什么情况我们会使用 阻塞队列呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">多线程并发处理、线程池！</span><br></pre></td></tr></table></figure>
<p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727202709411.png#id=MnwFt&originHeight=486&originWidth=577&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>整个阻塞队列的家族如下：Queue以下实现的有Deque、AbstaractQueue、BlockingQueue；<br>BlockingQueue以下有Link链表实现的阻塞队列、也有Array数组实现的阻塞队列</p>
<blockquote>
<p><strong>2、如何使用阻塞队列呢？【*】</strong></p>
</blockquote>
<p>操作：添加、移除<br>但是实际我们要学的有：<br><strong>四组API</strong></p>
<table>
<thead>
<tr>
<th>方式</th>
<th>抛出异常</th>
<th>不会抛出异常，有返回值</th>
<th>阻塞 等待</th>
<th>超时 等待</th>
</tr>
</thead>
<tbody><tr>
<td>添加</td>
<td>add</td>
<td>offer</td>
<td>put</td>
<td>offer(timenum，timeUnit)</td>
</tr>
<tr>
<td>移除</td>
<td>remove</td>
<td>poll</td>
<td>take</td>
<td>poll(timenum，timeUnit)</td>
</tr>
<tr>
<td>判断队列首</td>
<td>element</td>
<td>peek</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//需要初始化队列的大小</span></span><br><span class="line">        <span class="type">ArrayBlockingQueue</span> <span class="variable">blockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">&quot;c&quot;</span>));</span><br><span class="line">        <span class="comment">//抛出异常：java.lang.IllegalStateException: Queue full</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.add(&quot;d&quot;));</span></span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">        <span class="comment">//如果多移除一个</span></span><br><span class="line">        <span class="comment">//这也会造成 java.util.NoSuchElementException 抛出异常</span></span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">    &#125;</span><br><span class="line">=======================================================================================</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不抛出异常，有返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ArrayBlockingQueue</span> <span class="variable">blockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">&quot;c&quot;</span>));</span><br><span class="line">        <span class="comment">//添加 一个不能添加的元素 使用offer只会返回false 不会抛出异常</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">&quot;d&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        <span class="comment">//弹出 如果没有元素 只会返回null 不会抛出异常</span></span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">    &#125;</span><br><span class="line">=======================================================================================</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待 一直阻塞</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ArrayBlockingQueue</span> <span class="variable">blockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一直阻塞 不会返回</span></span><br><span class="line">        blockingQueue.put(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        blockingQueue.put(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        blockingQueue.put(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果队列已经满了， 再进去一个元素  这种情况会一直等待这个队列 什么时候有了位置再进去，程序不会停止</span></span><br><span class="line"><span class="comment">//        blockingQueue.put(&quot;d&quot;);</span></span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        <span class="comment">//如果我们再来一个  这种情况也会等待，程序会一直运行 阻塞</span></span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">    &#125;</span><br><span class="line">=======================================================================================</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待 超时阻塞</span></span><br><span class="line"><span class="comment">     *  这种情况也会等待队列有位置 或者有产品 但是会超时结束</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ArrayBlockingQueue</span> <span class="variable">blockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        blockingQueue.offer(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        blockingQueue.offer(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        blockingQueue.offer(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;开始等待&quot;</span>);</span><br><span class="line">        blockingQueue.offer(<span class="string">&quot;d&quot;</span>,<span class="number">2</span>, TimeUnit.SECONDS);  <span class="comment">//超时时间2s 等待如果超过2s就结束等待</span></span><br><span class="line">        System.out.println(<span class="string">&quot;结束等待&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;===========取值==================&quot;</span>);</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;开始等待&quot;</span>);</span><br><span class="line">        blockingQueue.poll(<span class="number">2</span>,TimeUnit.SECONDS); <span class="comment">//超过两秒 我们就不要等待了</span></span><br><span class="line">        System.out.println(<span class="string">&quot;结束等待&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>3、同步队列SynchronousQueue</strong></p>
</blockquote>
<p>同步队列 没有容量，也可以视为<strong>容量为1的队列</strong>；<br>进去一个元素，必须等待取出来之后，才能再往里面放入一个元素；<br><strong>put</strong>方法 和 <strong>take</strong>方法；<br><strong>Synchronized</strong> 和 其他的<strong>BlockingQueue</strong> 不一样 它不存储元素；<br>put了一个元素，就必须从里面先take出来，否则不能再put进去值！<br>并且SynchronousQueue 的take是使用了<strong>lock锁保证线程安全</strong>的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronousQueueDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; synchronousQueue = <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//研究一下 如果判断这是一个同步队列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用两个进程</span></span><br><span class="line">        <span class="comment">// 一个进程 放进去</span></span><br><span class="line">        <span class="comment">// 一个进程 拿出来</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; Put 1&quot;</span>);</span><br><span class="line">                synchronousQueue.put(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; Put 2&quot;</span>);</span><br><span class="line">                synchronousQueue.put(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; Put 3&quot;</span>);</span><br><span class="line">                synchronousQueue.put(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; Take &quot;</span>+synchronousQueue.take());</span><br><span class="line"><span class="comment">//                TimeUnit.SECONDS.sleep(3);</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; Take &quot;</span>+synchronousQueue.take());</span><br><span class="line"><span class="comment">//                TimeUnit.SECONDS.sleep(3);</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; Take &quot;</span>+synchronousQueue.take());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727202913340.png#id=y6u7y&originHeight=289&originWidth=623&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="7-6-异步回调"><a href="#7-6-异步回调" class="headerlink" title="7.6 异步回调"></a>7.6 异步回调</h2><blockquote>
<p>1、Future 设计的初衷：对将来的某个事件结果进行建模！</p>
</blockquote>
<p>其实就是前端 –&gt; 发送ajax异步请求给后端<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727204140269.png#id=ICghW&originHeight=299&originWidth=1042&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>但是我们平时都使用<strong>CompletableFuture</strong></p>
<blockquote>
<p>2、没有返回值的runAsync异步回调</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 发起 一个 请求</span></span><br><span class="line"></span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//发起一个异步任务</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;.....&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//输出执行结果</span></span><br><span class="line">        System.out.println(future.get());  <span class="comment">//获取执行结果</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3、有返回值的异步回调supplyAsync</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有返回值的异步回调</span></span><br><span class="line">CompletableFuture&lt;Integer&gt; completableFuture=CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> i=<span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(completableFuture.whenComplete((t, u) -&gt; &#123;</span><br><span class="line">    <span class="comment">//success 回调</span></span><br><span class="line">    System.out.println(<span class="string">&quot;t=&gt;&quot;</span> + t); <span class="comment">//正常的返回结果</span></span><br><span class="line">    System.out.println(<span class="string">&quot;u=&gt;&quot;</span> + u); <span class="comment">//抛出异常的 错误信息</span></span><br><span class="line">&#125;).exceptionally((e) -&gt; &#123;</span><br><span class="line">    <span class="comment">//error回调</span></span><br><span class="line">    System.out.println(e.getMessage());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">404</span>;</span><br><span class="line">&#125;).get());</span><br></pre></td></tr></table></figure>
<p><strong>whenComplete</strong>: 有两个参数，一个是t 一个是u<br>T：是代表的 <strong>正常返回的结果</strong>；<br>U：是代表的 <strong>抛出异常的错误信息</strong>；<br>如果发生了异常，get可以获取到<strong>exceptionally</strong>返回的值；</p>
<h2 id="7-7-JMM"><a href="#7-7-JMM" class="headerlink" title="7.7 JMM"></a>7.7 JMM</h2><blockquote>
<p>1、请你谈谈你对Volatile 的理解</p>
</blockquote>
<p><strong>Volatile</strong> 是 Java 虚拟机提供 <strong>轻量级的同步机制</strong></p>
<ol>
<li>保证可见性</li>
<li>不保证原子性</li>
<li>禁止指令重排</li>
</ol>
<blockquote>
<p>2、什么是JMM？</p>
</blockquote>
<p>JMM：JAVA内存模型，不存在的东西，是一个概念，也是一个约定！<br><strong>关于JMM的一些同步的约定：</strong><br>1、线程解锁前，必须把共享变量<strong>立刻</strong>刷回主存；<br>2、线程加锁前，必须<strong>读取主存</strong>中的最新值到工作内存中；<br>3、加锁和解锁是同一把锁；<br>线程中分为 <strong>工作内存、主内存</strong></p>
<p><strong>8种操作</strong>:</p>
<ul>
<li><strong>Read（读取）</strong>：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用；</li>
<li><strong>load（载入）</strong>：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中；</li>
<li><strong>Use（使用）</strong>：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令；</li>
<li><strong>assign（赋值）</strong>：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中；</li>
<li><strong>store（存储）</strong>：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用；</li>
<li><strong>write（写入）</strong>：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中；</li>
<li><strong>lock（锁定）</strong>：作用于主内存的变量，把一个变量标识为线程独占状态；</li>
<li><strong>unlock（解锁）</strong>：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定；</li>
</ul>
<p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727204419162.png#id=R0IPX&originHeight=355&originWidth=575&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/2020072720445830.png#id=UU8JP&originHeight=386&originWidth=698&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><strong>JMM对这8种操作给了相应的规定</strong>：</p>
<ul>
<li>不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write</li>
<li>不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存</li>
<li>不允许一个线程将没有assign的数据从工作内存同步回主内存</li>
<li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过assign和load操作</li>
<li>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁</li>
<li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值</li>
<li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量</li>
<li>对一个变量进行unlock操作之前，必须把此变量同步回主内存</li>
</ul>
<p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/2020072720445830.png#id=Vgu7l&originHeight=386&originWidth=698&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>遇到问题：<strong>程序不知道主存中的值已经被修改过了！；</strong></p>
<h2 id="7-8-Volatile"><a href="#7-8-Volatile" class="headerlink" title="7.8 Volatile"></a>7.8 Volatile</h2><blockquote>
<p>1、保证可见性</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JMMDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不加volatile 程序会死循环</span></span><br><span class="line">    <span class="comment">// 加了volatile是可以保证可见性的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//main线程</span></span><br><span class="line">        <span class="comment">//子线程1</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (number==<span class="number">0</span>)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//子线程2</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (number==<span class="number">0</span>)&#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        number=<span class="number">1</span>;</span><br><span class="line">        System.out.println(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2、不保证原子性</p>
</blockquote>
<p>原子性：不可分割；<br>线程A在执行任务的时候，不能被打扰的，也不能被分割的，要么同时成功，要么同时失败。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不保证原子性</span></span><br><span class="line"><span class="comment"> * number &lt;=2w</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VDemo02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        number++; </span><br><span class="line">        <span class="comment">//++ 不是一个原子性操作，是两个~3个操作</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//理论上number  === 20000</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">1000</span> ; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//main  gc</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;,num=&quot;</span>+number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如果不加lock和synchronized ，怎么样保证原子性？</strong><br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727204535517.png#id=fTxT1&originHeight=616&originWidth=999&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>解决方法：使用JUC下的原子包下的class；<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727204554558.png#id=XRD3j&originHeight=623&originWidth=360&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VDemo02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">AtomicInteger</span> <span class="variable">number</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//        number++;</span></span><br><span class="line">        number.incrementAndGet();  <span class="comment">//底层是CAS保证的原子性</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//理论上number  === 20000</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">1000</span> ; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//main  gc</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;,num=&quot;</span>+number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些类的底层都直接和操作系统挂钩！是在内存中修改值。<br>Unsafe类是一个很特殊的存在；</p>
<blockquote>
<p>3、禁止指令重排</p>
</blockquote>
<p><strong>什么是指令重排？</strong><br>我们写的程序，计算机并不是按照我们自己写的那样去执行的<br>源代码–&gt;编译器优化重排–&gt;指令并行也可能会重排–&gt;内存系统也会重排–&gt;执行<br><strong>处理器在进行指令重排的时候，会考虑数据之间的依赖性！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">1</span>; <span class="comment">//1</span></span><br><span class="line"><span class="type">int</span> y=<span class="number">2</span>; <span class="comment">//2</span></span><br><span class="line">x=x+<span class="number">5</span>;   <span class="comment">//3</span></span><br><span class="line">y=x*x;   <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们期望的执行顺序是 1_2_3_4  可能执行的顺序会变成2134 1324</span></span><br><span class="line"><span class="comment">//可不可能是 4123？ 不可能的</span></span><br></pre></td></tr></table></figure>
<p>可能造成的影响结果：前提：a b x y这四个值 默认都是0</p>
<table>
<thead>
<tr>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody><tr>
<td>x&#x3D;a</td>
<td>y&#x3D;b</td>
</tr>
<tr>
<td>b&#x3D;1</td>
<td>a&#x3D;2</td>
</tr>
</tbody></table>
<p>正常的结果： x &#x3D; 0; y &#x3D;0;</p>
<table>
<thead>
<tr>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody><tr>
<td>x&#x3D;a</td>
<td>y&#x3D;b</td>
</tr>
<tr>
<td>b&#x3D;1</td>
<td>a&#x3D;2</td>
</tr>
</tbody></table>
<p>可能在线程A中会出现，先执行b&#x3D;1,然后再执行x&#x3D;a；<br>在B线程中可能会出现，先执行a&#x3D;2，然后执行y&#x3D;b；<br>那么就有可能结果如下：x&#x3D;2; y&#x3D;1.<br><strong>volatile可以避免指令重排：</strong><br><strong>volatile中会加一道内存的屏障，这个内存屏障可以保证在这个屏障中的指令顺序。</strong><br>内存屏障：CPU指令。作用：<br>1、保证特定的操作的执行顺序；<br>2、可以保证某些变量的内存可见性（利用这些特性，就可以保证volatile实现的可见性）<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727204653125.png#id=uJUZ5&originHeight=361&originWidth=251&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<blockquote>
<p>总结</p>
</blockquote>
<ul>
<li><strong>volatile可以保证可见性；</strong></li>
<li><strong>不能保证原子性</strong></li>
<li><strong>由于内存屏障，可以保证避免指令重排的现象产生</strong></li>
</ul>
<p>面试官：那么你知道在哪里用这个内存屏障用得最多呢？<strong>单例模式</strong></p>
<h2 id="7-9-玩转单例模式"><a href="#7-9-玩转单例模式" class="headerlink" title="7.9 玩转单例模式"></a>7.9 玩转单例模式</h2><p>饿汉式、DCL懒汉式</p>
<blockquote>
<p>1、饿汉式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hungry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可能会浪费空间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] data1=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] data2=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] data3=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] data4=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Hungry</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Hungry</span> <span class="variable">hungry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hungry</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2、懒汉式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉式单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyMan</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">key</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazyMan</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LazyMan.class)&#123;</span><br><span class="line">            <span class="keyword">if</span> (key==<span class="literal">false</span>)&#123;</span><br><span class="line">                key=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;不要试图使用反射破坏异常&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyMan lazyMan;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//双重检测锁模式 简称DCL懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazyMan <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//需要加锁</span></span><br><span class="line">        <span class="keyword">if</span>(lazyMan==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyMan.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(lazyMan==<span class="literal">null</span>)&#123;</span><br><span class="line">                    lazyMan=<span class="keyword">new</span> <span class="title class_">LazyMan</span>();</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 1、分配内存空间</span></span><br><span class="line"><span class="comment">                     * 2、执行构造方法，初始化对象</span></span><br><span class="line"><span class="comment">                     * 3、把这个对象指向这个空间</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     *  就有可能出现指令重排问题</span></span><br><span class="line"><span class="comment">                     *  比如执行的顺序是1 3 2 等</span></span><br><span class="line"><span class="comment">                     *  我们就可以添加volatile保证指令重排问题</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyMan;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//单线程下 是ok的</span></span><br><span class="line">    <span class="comment">//但是如果是并发的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="comment">//Java中有反射</span></span><br><span class="line"><span class="comment">//        LazyMan instance = LazyMan.getInstance();</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">key</span> <span class="operator">=</span> LazyMan.class.getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        key.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        Constructor&lt;LazyMan&gt; declaredConstructor = LazyMan.class.getDeclaredConstructor(<span class="literal">null</span>);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>); <span class="comment">//无视了私有的构造器</span></span><br><span class="line">        <span class="type">LazyMan</span> <span class="variable">lazyMan1</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line">        key.set(lazyMan1,<span class="literal">false</span>);</span><br><span class="line">        <span class="type">LazyMan</span> <span class="variable">instance</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(instance);</span><br><span class="line">        System.out.println(lazyMan1);</span><br><span class="line">        System.out.println(instance == lazyMan1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3、静态内部类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Holder</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Holder <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.holder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Holder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Holder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>单例不安全, 因为反射</li>
</ul>
<blockquote>
<p>4、枚举</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//enum 是什么？ enum本身就是一个Class 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingle</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> EnumSingle <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        <span class="type">EnumSingle</span> <span class="variable">instance1</span> <span class="operator">=</span> EnumSingle.INSTANCE;</span><br><span class="line">        Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class,<span class="type">int</span>.class);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//java.lang.NoSuchMethodException: com.ogj.single.EnumSingle.&lt;init&gt;()</span></span><br><span class="line"></span><br><span class="line">        <span class="type">EnumSingle</span> <span class="variable">instance2</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line">        System.out.println(instance1);</span><br><span class="line">        System.out.println(instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用枚举，我们就可以防止反射破坏了。<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727204727492.png#id=vR1kn&originHeight=163&originWidth=1112&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>枚举类型使用JAD最终反编译后源码：<br>如果我们看idea 的文件：会发现idea骗了我们，居然告诉我们是有有参构造的，我们使用jad进行反编译。<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727204751957.png#id=QlIu2&originHeight=621&originWidth=1416&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/2020072720480950.png#id=wLHfc&originHeight=872&originWidth=1739&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">EnumSingle</span> <span class="keyword">extends</span> <span class="title class_">Enum</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EnumSingle[] values()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (EnumSingle[])$VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EnumSingle <span class="title function_">valueOf</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (EnumSingle)Enum.valueOf(com/ogj/single/EnumSingle, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">EnumSingle</span><span class="params">(String s, <span class="type">int</span> i)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EnumSingle <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EnumSingle INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EnumSingle $VALUES[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> <span class="title class_">EnumSingle</span>(<span class="string">&quot;INSTANCE&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        $VALUES = (<span class="keyword">new</span> <span class="title class_">EnumSingle</span>[] &#123;</span><br><span class="line">            INSTANCE</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-11-深入理解CAS"><a href="#7-11-深入理解CAS" class="headerlink" title="7.11 深入理解CAS"></a>7.11 深入理解CAS</h2><blockquote>
<p>1、什么是CAS？</p>
</blockquote>
<p>大厂必须深入研究底层！！！！<strong>修内功！操作系统、计算机网络原理、组成原理、数据结构</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">casDemo</span> &#123;</span><br><span class="line">    <span class="comment">//CAS : compareAndSet 比较并交换</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">2020</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//boolean compareAndSet(int expect, int update)</span></span><br><span class="line">        <span class="comment">//期望值、更新值</span></span><br><span class="line">        <span class="comment">//如果实际值 和 我的期望值相同，那么就更新</span></span><br><span class="line">        <span class="comment">//如果实际值 和 我的期望值不同，那么就不更新</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2020</span>, <span class="number">2021</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为期望值是2020  实际值却变成了2021  所以会修改失败</span></span><br><span class="line">        <span class="comment">//CAS 是CPU的并发原语</span></span><br><span class="line">        atomicInteger.getAndIncrement(); <span class="comment">//++操作</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2020</span>, <span class="number">2021</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727214229852.png#id=hDCKc&originHeight=236&originWidth=763&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<blockquote>
<p>2、Unsafe类</p>
</blockquote>
<p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727214247117.png#id=MGPCU&originHeight=279&originWidth=658&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727214300255.png#id=pt7BL&originHeight=308&originWidth=564&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>总结：</strong><br>CAS：比较当前工作内存中的值 和 主内存中的值，如果这个值是期望的，那么则执行操作！如果不是就一直循环，使用的是自旋锁。<br><strong>缺点：</strong></p>
<ul>
<li>循环会耗时；</li>
<li>一次性只能保证一个共享变量的原子性；</li>
<li>它会存在ABA问题</li>
</ul>
<blockquote>
<p>3、CAS：ABA问题？(狸猫换太子)</p>
</blockquote>
<p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727214320203.png#id=XGlzW&originHeight=241&originWidth=456&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>线程1：期望值是1，要变成2；<br>线程2：两个操作：</p>
<ul>
<li>1、期望值是1，变成3</li>
<li>2、期望是3，变成1</li>
</ul>
<p>所以对于线程1来说，A的值还是1，所以就出现了问题，骗过了线程1；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">casDemo</span> &#123;</span><br><span class="line">    <span class="comment">//CAS : compareAndSet 比较并交换</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">2020</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2020</span>, <span class="number">2021</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//boolean compareAndSet(int expect, int update)</span></span><br><span class="line">        <span class="comment">//期望值、更新值</span></span><br><span class="line">        <span class="comment">//如果实际值 和 我的期望值相同，那么就更新</span></span><br><span class="line">        <span class="comment">//如果实际值 和 我的期望值不同，那么就不更新</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2021</span>, <span class="number">2020</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为期望值是2020  实际值却变成了2021  所以会修改失败</span></span><br><span class="line">        <span class="comment">//CAS 是CPU的并发原语</span></span><br><span class="line"><span class="comment">//        atomicInteger.getAndIncrement(); //++操作</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2020</span>, <span class="number">2021</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-12-原子引用"><a href="#7-12-原子引用" class="headerlink" title="7.12 原子引用"></a>7.12 原子引用</h2><blockquote>
<p>1、解决ABA问题，对应的思想：就是使用了<strong>乐观锁~</strong></p>
</blockquote>
<p>带版本号的 原子操作！<br><strong>Integer 使用了对象缓存机制，默认范围是-128~127，推荐使用静态工厂方法valueOf获取对象实例，而不是new，因为valueOf使用缓存，而new一定会创建新的对象分配新的内存空间。</strong><br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727214340236.png#id=P0rSr&originHeight=157&originWidth=713&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>所以如果遇到，使用大于128的时候，<strong>使用原子引用的时候，如果超过了这个值，那么就不会进行版本上升！</strong><br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727214355541.png#id=GCd4O&originHeight=848&originWidth=1722&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>那么如果我们使用小于128的时候：<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/2020072721441445.png#id=FqTsM&originHeight=867&originWidth=1695&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>正常业务操作中，我们一般使用的是一个个对象，一般情况不会遇到这种情况。</p>
<h1 id="【拓展】"><a href="#【拓展】" class="headerlink" title="【拓展】"></a>【拓展】</h1><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1698075772940-56fcfcbd-06de-4cd8-95cd-d80605fe861c.png#averageHue=%23f7f6f6&clientId=ue1746809-e584-4&from=paste&height=326&id=u659424f2&originHeight=407&originWidth=681&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=100199&status=done&style=none&taskId=u78a0cfee-16e4-4427-bd73-273fcc15ffb&title=&width=544.8" alt="image.png"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">cocochimp</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/01/18/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">http://example.com/2024/01/18/JUC并发编程/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">cocochimpBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JUC/">JUC</a></div><div class="post_share"><div class="social-share" data-image="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/juc.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/18/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="23种设计模式"><img class="cover" src="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">23种设计模式</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/18/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="JVM虚拟机"><img class="cover" src="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/JVM.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM虚拟机</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">cocochimp</div><div class="author-info__description">to be a cool man!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/cocochimp" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://gitee.com/cocochimp" target="_blank" title="Gitee"><i class="fab fa-github-alt"></i></a><a class="social-icon" href="https://blog.csdn.net/m0_51634403" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="mailto:2427886409@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E3%80%81Locks-%E9%94%81"><span class="toc-number">1.</span> <span class="toc-text">1、Locks 锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Lock%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 Lock接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-ReentrantLock-%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 ReentrantLock 重入锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-ReadWriteLock-%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 ReadWriteLock 读写锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-Condition"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 Condition</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-LockSupport"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 LockSupport</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-AQS"><span class="toc-number">1.6.</span> <span class="toc-text">1.6 AQS</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81Tools-%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">2、Tools 工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-CountDownLatch"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 CountDownLatch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-CyclickBarrier"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 CyclickBarrier</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-Semaphore"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 Semaphore</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E3%80%81Collections-%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88"><span class="toc-number">3.</span> <span class="toc-text">3、Collections 并发集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-ConcurrentHashMap"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 ConcurrentHashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-CopyOnWriteArrayList"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 CopyOnWriteArrayList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-BlockingQueue"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 BlockingQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-ConcurrentLinkedQueue"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 ConcurrentLinkedQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-Fork-Join"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 Fork&#x2F;Join</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E3%80%81Executors-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">4.</span> <span class="toc-text">4、Executors 线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Executor"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 Executor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-ThreadPoolExecutor"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 ThreadPoolExecutor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-FutureTask"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 FutureTask</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E3%80%81Atomic-%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">5.</span> <span class="toc-text">5、Atomic 原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 基本类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-Array"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-Reference"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 Reference</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-FieldUpdator"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 FieldUpdator</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E3%80%81JUC%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">6.</span> <span class="toc-text">1、JUC体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-JUC%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.</span> <span class="toc-text">1.1 JUC的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="toc-number">6.2.</span> <span class="toc-text">1.2 线程和进程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81%E9%94%81"><span class="toc-number">7.</span> <span class="toc-text">2、锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Lock%E9%94%81%E3%80%90-%E3%80%91"><span class="toc-number">7.1.</span> <span class="toc-text">2.1 Lock锁【*】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%85%AC%E5%B9%B3%E9%94%81-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">7.2.</span> <span class="toc-text">2.2 公平锁&#x2F;非公平锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">7.3.</span> <span class="toc-text">2.3 可重入锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">7.4.</span> <span class="toc-text">2.4 自旋锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E6%AD%BB%E9%94%81"><span class="toc-number">7.5.</span> <span class="toc-text">2.5 死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">7.6.</span> <span class="toc-text">2.6 读写锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E3%80%81%E5%9B%9B%E5%A4%A7%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E3%80%90-%E3%80%91"><span class="toc-number">8.</span> <span class="toc-text">3、四大函数式接口【**】</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E3%80%90-%E3%80%91"><span class="toc-number">9.</span> <span class="toc-text">5、生产者和消费者【*】</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E3%80%90-%E3%80%91"><span class="toc-number">10.</span> <span class="toc-text">6、线程池【*】</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E3%80%81%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">11.</span> <span class="toc-text">7、常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-8%E9%94%81%E7%8E%B0%E8%B1%A1%E3%80%90-%E3%80%91"><span class="toc-number">11.1.</span> <span class="toc-text">7.1 8锁现象【*】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="toc-number">11.2.</span> <span class="toc-text">7.2 集合类不安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-Callable-%E7%AE%80%E5%8D%95"><span class="toc-number">11.3.</span> <span class="toc-text">7.3 Callable(简单)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">11.4.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">11.5.</span> <span class="toc-text">7.4 阻塞队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-1"><span class="toc-number">11.6.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83"><span class="toc-number">11.7.</span> <span class="toc-text">7.6 异步回调</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7-JMM"><span class="toc-number">11.8.</span> <span class="toc-text">7.7 JMM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-8-Volatile"><span class="toc-number">11.9.</span> <span class="toc-text">7.8 Volatile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-9-%E7%8E%A9%E8%BD%AC%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.10.</span> <span class="toc-text">7.9 玩转单例模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-11-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CAS"><span class="toc-number">11.11.</span> <span class="toc-text">7.11 深入理解CAS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-12-%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8"><span class="toc-number">11.12.</span> <span class="toc-text">7.12 原子引用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%80%90%E6%8B%93%E5%B1%95%E3%80%91"><span class="toc-number">12.</span> <span class="toc-text">【拓展】</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">12.1.</span> <span class="toc-text">ThreadLocal</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/18/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="23种设计模式"><img src="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="23种设计模式"/></a><div class="content"><a class="title" href="/2024/01/18/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="23种设计模式">23种设计模式</a><time datetime="2024-01-18T03:00:54.577Z" title="发表于 2024-01-18 11:00:54">2024-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/18/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="JUC并发编程"><img src="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/juc.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC并发编程"/></a><div class="content"><a class="title" href="/2024/01/18/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="JUC并发编程">JUC并发编程</a><time datetime="2024-01-18T03:00:43.042Z" title="发表于 2024-01-18 11:00:43">2024-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/18/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="JVM虚拟机"><img src="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/JVM.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM虚拟机"/></a><div class="content"><a class="title" href="/2024/01/18/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="JVM虚拟机">JVM虚拟机</a><time datetime="2024-01-18T03:00:28.866Z" title="发表于 2024-01-18 11:00:28">2024-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="Java多线程"><img src="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java多线程"/></a><div class="content"><a class="title" href="/2024/01/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="Java多线程">Java多线程</a><time datetime="2024-01-18T03:00:10.504Z" title="发表于 2024-01-18 11:00:10">2024-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/18/Java%E9%9B%86%E5%90%88/" title="Java集合"><img src="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/Java%E9%9B%86%E5%90%88.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java集合"/></a><div class="content"><a class="title" href="/2024/01/18/Java%E9%9B%86%E5%90%88/" title="Java集合">Java集合</a><time datetime="2024-01-18T02:59:47.232Z" title="发表于 2024-01-18 10:59:47">2024-01-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By cocochimp</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div></body></html>