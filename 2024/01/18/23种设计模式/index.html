<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>23种设计模式 | cocochimpBlog</title><meta name="author" content="cocochimp"><meta name="copyright" content="cocochimp"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="面试题：设计模式面试题（14道含答案） 目标：掌握常见的设计模式，包括单例模式、工厂模式、装饰器模式、代理模式等，以提高代码的可维护性和可扩展性。 【重点&#x2F;常看】快速记忆23种设计模式 深造地址：23种常见设计模式详解 拓展：Java程序员必备常用的八种设计模式讲解  1、OOP七大原则 开闭原则【*】：对拓展开放，对修改关闭；对修改关闭是说，我们辛辛苦苦加班写出来的代码，该实现的功能">
<meta property="og:type" content="article">
<meta property="og:title" content="23种设计模式">
<meta property="og:url" content="http://example.com/2024/01/18/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="cocochimpBlog">
<meta property="og:description" content="面试题：设计模式面试题（14道含答案） 目标：掌握常见的设计模式，包括单例模式、工厂模式、装饰器模式、代理模式等，以提高代码的可维护性和可扩展性。 【重点&#x2F;常看】快速记忆23种设计模式 深造地址：23种常见设计模式详解 拓展：Java程序员必备常用的八种设计模式讲解  1、OOP七大原则 开闭原则【*】：对拓展开放，对修改关闭；对修改关闭是说，我们辛辛苦苦加班写出来的代码，该实现的功能">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png">
<meta property="article:published_time" content="2024-01-18T03:00:54.577Z">
<meta property="article:modified_time" content="2024-01-18T03:27:23.266Z">
<meta property="article:author" content="cocochimp">
<meta property="article:tag" content="设计模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/01/18/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '23种设计模式',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-18 11:27:23'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="cocochimpBlog" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/picture/"><i class="fa-fw iconfont icon-tupian"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-touxiang"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png')"><nav id="nav"><span id="blog-info"><a href="/" title="cocochimpBlog"><span class="site-name">cocochimpBlog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/picture/"><i class="fa-fw iconfont icon-tupian"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-touxiang"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">23种设计模式</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-18T03:00:54.577Z" title="发表于 2024-01-18 11:00:54">2024-01-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-18T03:27:23.266Z" title="更新于 2024-01-18 11:27:23">2024-01-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">22.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>78分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="23种设计模式"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><ul>
<li>面试题：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_30999361/article/details/124637874">设计模式面试题（14道含答案）</a></li>
<li>目标：掌握常见的设计模式，包括单例模式、工厂模式、装饰器模式、代理模式等，以提高代码的可维护性和可扩展性。</li>
<li>【重点&#x2F;常看】<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/128145128">快速记忆23种设计模式</a></li>
<li>深造地址：<a target="_blank" rel="noopener" href="https://blog.csdn.net/su2231595742/article/details/121708085">23种常见设计模式详解</a></li>
<li>拓展：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/93908252">Java程序员必备常用的八种设计模式讲解</a></li>
</ul>
<h1 id="1、OOP七大原则"><a href="#1、OOP七大原则" class="headerlink" title="1、OOP七大原则"></a>1、OOP七大原则</h1><ol>
<li><strong>开闭原则【*】：对拓展开放，对修改关闭；</strong>对修改关闭是说，我们辛辛苦苦加班写出来的代码，该实现的功能和该修复的 bug 都完成了，别人可不能说改就改；对扩展开放就比较好理解了，也就是说在我们写好的代码基础上，很容易实现扩展。</li>
<li><strong>里氏替换原则</strong>：继承必须确保超类所拥有的性质在子类中仍然成立。</li>
<li><strong>依赖倒置原则</strong>：<strong>面向接口编程，而不是面向实现</strong>。这个很重要，也是优雅的、可扩展的代码的第一步，这就不需要多说了吧。</li>
<li><strong>单一职责原则</strong>：每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来。【将对象解耦，提高内聚性】</li>
<li><strong>接口隔离原则</strong>：要为各个类建立它们需要的专用接口。</li>
<li><strong>迪米特法则</strong>：只与你的直接朋友交谈，不跟“陌生人”说话。</li>
<li><strong>合成复用原则</strong>：尽量先试用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</li>
</ol>
<h1 id="2、创建型模式"><a href="#2、创建型模式" class="headerlink" title="2、创建型模式"></a>2、创建型模式</h1><p>创建型模式的作用就是创建对象，说到创建一个对象，最熟悉的就是 new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要给客户端提供更加友好的创建对象的方式，尤其是那种我们定义了类，但是需要提供给其他开发者用的时候。</p>
<ol>
<li>简单工厂模式最简单； </li>
<li>工厂模式在简单工厂模式的基础上增加了选择工厂的维度，需要第一步选择合适的工厂； </li>
<li>抽象工厂模式有产品族的概念，如果各个产品是存在兼容性问题的，就要用抽象工厂模式。 </li>
<li>单例模式就不说了，为了保证全局使用的是同一对象，一方面是安全性考虑，一方面是为了节省资源； </li>
<li>建造者模式专门对付属性很多的那种类，为了让代码更优美； </li>
<li>原型模式用得最少，了解和 Object 类中的 clone() 方法相关的知识即可。</li>
</ol>
<h2 id="2-1-单例模式【-】"><a href="#2-1-单例模式【-】" class="headerlink" title="2.1 单例模式【**】"></a>2.1 单例模式【**】</h2><blockquote>
<p>一个班级只有一个班主任</p>
</blockquote>
<ol>
<li><strong>【概念】：</strong>确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</li>
</ol>
<ul>
<li>如何确保一个类只有一个实例?<ul>
<li><strong>构造方法</strong>不能 public, 不能被外界实例化使用：private修饰</li>
<li>这个实例是当前类的<strong>类成员变量</strong>（类静态变量），用static修饰</li>
</ul>
</li>
<li>如何向整个系统提供这个实例？<ul>
<li>使用方法向外界提供这个实例</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688796888722-92a305f7-4d7f-4699-96c2-bda876ddfbb0.png#averageHue=%23efefef&clientId=uaef691d9-ff29-4&from=drop&id=u7a87046c&originHeight=328&originWidth=960&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32470&status=done&style=none&taskId=uaeddf1c9-0c1c-43fd-ad9b-0fd62f0f3fa&title=" alt="2020040715570631.png"></p>
<ol start="2">
<li><strong>【使用场景】：</strong>工具类模式<ul>
<li>序列号生成器、Web页面计数器等</li>
<li>访问IO、数据库资源，使用单例模式减少资源的消耗</li>
</ul>
</li>
<li><strong>【优缺点】：</strong></li>
</ol>
<ul>
<li><strong>优点：</strong><ul>
<li>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 </li>
<li>2、避免对资源的多重占用（比如写文件操作）。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>【特点】：</strong><blockquote>
<p>根据对象实例化时机不同可以分为：<strong>饿汉式</strong>和<strong>懒汉式</strong></p>
</blockquote>
</li>
</ol>
<ul>
<li><p><strong>饿汉式：</strong></p>
<ul>
<li><strong>对象实例化后会一直被使用</strong>，且创建实例不会造成大量资源浪费。</li>
<li>代码实现简单，<strong>不需要处理多线程同步问题</strong>。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">//类加载就进行实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>懒汉式：</strong>在第一次使用时实例化</p>
<ul>
<li><strong>实例化这个对象比较耗费资源</strong>，例如数据库连接池对象，需要在需要时才创建实例。</li>
<li>不需要在程序刚启动的时候就创建实例，仅<strong>需要在需要时才创建实例</strong>。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">//new对象的时候：分配内存——&gt;初始化对象——&gt;指向刚分配的地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一次使用getInstance()成员方法的时候进行实例化</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//双层检查锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>嵌套类最经典，以后大家就用它吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton3</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton3</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，很多人都会把这个<strong>嵌套类</strong>说成是<strong>静态内部类</strong>，严格地说，内部类和嵌套类是不一样的，它们能访问的外部类权限也是不一样的。<br>最后，我们说一下枚举，枚举很特殊，它在类加载的时候会初始化里面的所有的实例，而且 JVM 保证了它们不会再被实例化，所以它天生就是单例的。</p>
</li>
</ul>
<p>双重检查加锁(DCL)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数私有，禁止外部实例化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>:::tips<br>现在我们分析一下为什么要在变量singleton之间加上volatile关键字。要理解这个问题，先要了解对象的构造过程，实例化一个对象其实可以分为三个步骤：</p>
<ul>
<li>分配内存空间</li>
<li>初始化对象</li>
<li>将内存空间的地址赋值给对应的引用</li>
</ul>
<p>但是由于操作系统可以对指令进行重排序，所以上面的过程也可能会变成如下过程：</p>
<ul>
<li>分配内存空间。</li>
<li>将内存空间的地址赋值给对应的引用。</li>
<li>初始化对象</li>
</ul>
<p>如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量。<br>:::</p>
<h2 id="2-2-简单工厂模式-x"><a href="#2-2-简单工厂模式-x" class="headerlink" title="2.2 简单工厂模式(x)"></a>2.2 简单工厂模式(x)</h2><blockquote>
<p>静态工厂模式【类创建型模式—&gt;工厂类】</p>
</blockquote>
<ul>
<li><strong>目的：实现创建者和调用者的分离。</strong></li>
<li><strong>核心性质：实例化对象不使用new，用工厂方法代替</strong></li>
</ul>
<ol>
<li><strong>【概念】：</strong>在简单工厂模式中，可以根据<strong>参数的不同返回不同类的实例</strong>。简单工厂模式专门定义一个类来负责创建其他类的实例被创建的实例通常都具有共同的父类。</li>
</ol>
<ul>
<li>【核心思想】有一个专门的类**(工厂类)**来负责创建实例的过程。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688696245855-88a2b5d1-f5ff-42ae-a7b3-daa5ca6bdcaf.png#averageHue=%23efefec&clientId=uee24b681-3279-4&from=drop&height=389&id=ud4fcbf4d&originHeight=506&originWidth=553&originalType=binary&ratio=1&rotation=0&showTitle=false&size=63449&status=done&style=none&taskId=ubb8d83af-ba69-4062-9e10-e43bb7b3046&title=&width=425" alt="20200707204516186.png"></p>
<ul>
<li>Factory(工厂):核心部分，负责实现创建所有产品的内部逻辑，工厂类可以被外界直接调用，创建所需对象工厂类是整个模式的关键；</li>
<li>Product(抽象类产品)：工厂类所创建的所有对象的父类，封装了产品对象的公共方法，所有的具体产品为其子类对象；</li>
<li>ProductA、ProductB…(具体产品)：简单工厂模式的创建目标，所有被创建的对象都是某个具体类的实例。它要实现抽象产品中声明的抽象方法</li>
</ul>
<ol start="2">
<li><strong>【使用场景】：</strong>JDK工具类DataFormat、IO等需要根据不同参数返回不同类的实例对象的类方法<ul>
<li>工厂类负责创建的对象比较少；</li>
<li>客户只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心；</li>
</ul>
</li>
<li><strong>【优缺点】：</strong></li>
</ol>
<ul>
<li><strong>优点：</strong><ul>
<li>用户不需要关注创建对象的细节（你只管调用这个方法就行了）</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>创建对象的工厂类在需要变更时会变得很麻烦（专业一点就是简单工厂模式不够灵活）【<strong>违反开闭原则</strong>，不能做到灵活扩展<strong>】</strong></li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>【特点】：</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Food <span class="title function_">makeFood</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;noodle&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">Food</span> <span class="variable">noodle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LanZhouNoodle</span>();</span><br><span class="line">            noodle.addSpicy(<span class="string">&quot;more&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> noodle;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;chicken&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">Food</span> <span class="variable">chicken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HuangMenChicken</span>();</span><br><span class="line">            chicken.addCondiment(<span class="string">&quot;potato&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> chicken;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<em>其中，LanZhouNoodle 和 HuangMenChicken 都继承自 Food。</em><br>简单地说，简单工厂模式通常就是这样，一个工厂类 xxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。<br>我们强调<strong>职责单一</strong>原则，一个类只提供一种功能，FoodFactory 的功能就是只要负责生产各种 Food。</li>
</ol>
<h2 id="2-3-工厂模式【-】"><a href="#2-3-工厂模式【-】" class="headerlink" title="2.3 工厂模式【*】"></a>2.3 工厂模式【*】</h2><blockquote>
<p>您需要一辆汽车，可以直接从汽车工厂里面提货（不在意产品族）</p>
</blockquote>
<ol>
<li><strong>【概念】：</strong></li>
</ol>
<p>定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688697120002-ee251c83-6697-432b-86bc-1e634534cf74.png#averageHue=%23f4f4f4&clientId=uee24b681-3279-4&from=drop&id=uaa523b71&originHeight=340&originWidth=750&originalType=binary&ratio=1&rotation=0&showTitle=false&size=65610&status=done&style=none&taskId=ufa0648d2-73e9-4e9e-a976-3e158fdde50&title=" alt="20200713212158676.png"></p>
<ul>
<li>AbstractFactory抽象工厂类：工厂方法模式的核心类，提供创建具体产品的接口，由具体工厂类实现；</li>
<li>Factory具体工厂类：继承于抽象工厂，实现创建对应具体产品对象的方式；</li>
<li>Product抽象产品类：是具体产品类的继承的父类或实现的接口。</li>
<li>ConcreteProductX具体产品类：工厂类所创建的对象就是此具体产品实例。</li>
</ul>
<ol start="2">
<li><strong>【使用场景】：</strong>JDK的Collection集合类</li>
</ol>
<ul>
<li>客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688697573963-65c59680-bb9a-4438-9d9b-fa988dd698fc.png#averageHue=%23353432&clientId=uee24b681-3279-4&from=paste&height=427&id=u0cd4183d&originHeight=427&originWidth=725&originalType=binary&ratio=1&rotation=0&showTitle=false&size=80171&status=done&style=none&taskId=u9c08d40b-d113-48c9-af12-f0c8cd875ef&title=&width=725" alt="image.png"></p>
<ol start="3">
<li><strong>【优缺点】：</strong></li>
</ol>
<ul>
<li><strong>优点：</strong><ul>
<li><strong>开放封闭原则：</strong> 新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可</li>
<li><strong>单一职责原则</strong> ：每个具体工厂类只负责创建对应的产品，简单工厂中的工厂类存在复杂的switch逻辑判断</li>
<li><strong>屏蔽产品类：</strong> 产品类的实现如何变化，调用者都不需要关心，它只需要关心产品的接口，只要接口保持不变，系统中的上层模块就不要发生变化，因为产品类的实例化工作是由工厂类负责，一个产品对象具体由哪一个产品生成是由工厂类决定的。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>【开销增大，系统复杂度增加】</strong>如果产品种类过多，需要生产大量的工厂类。</li>
<li>一个具体工厂只能创建一种具体产品</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>【特点】：</strong></li>
</ol>
<ul>
<li><p>工厂模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line">    Food <span class="title function_">makeFood</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChineseFoodFactory</span> <span class="keyword">implements</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeFood</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChineseFoodA</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChineseFoodB</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanFoodFactory</span> <span class="keyword">implements</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeFood</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanFoodA</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanFoodB</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">APP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 先选择一个具体的工厂</span></span><br><span class="line">        <span class="type">FoodFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChineseFoodFactory</span>();</span><br><span class="line">        <span class="comment">// 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象</span></span><br><span class="line">        <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> factory.makeFood(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>核心在于，我们需要在第一步选好我们需要的工厂</strong>。比如，我们有 LogFactory 接口，实现类有 FileLogFactory 和 KafkaLogFactory，分别对应将日志写入文件和写入 Kafka 中，显然，我们客户端第一步就需要决定到底要实例化 FileLogFactory 还是 KafkaLogFactory，这将决定之后的所有的操作。<br><img src="https://www.javadoop.com/blogimages/design-pattern/factory-1.png#id=fZfIL&originHeight=1154&originWidth=1542&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
</li>
</ul>
<h2 id="2-4-抽象工厂模式"><a href="#2-4-抽象工厂模式" class="headerlink" title="2.4 抽象工厂模式"></a>2.4 抽象工厂模式</h2><blockquote>
<p>您需要一辆汽车，可以直接从汽车工厂里面提货（在意产品族）</p>
</blockquote>
<ol>
<li><strong>【概念】：</strong>工厂方法模式的缺点是如果产品种类过多，需要生产大量的工厂类。当涉及到<strong>产品族</strong>的时候，就需要引入抽象工厂模式了。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688698224105-49c88494-d137-4fde-be5e-0250ec187e66.png#averageHue=%23f6f6f6&clientId=uee24b681-3279-4&from=paste&height=834&id=C6GLt&originHeight=834&originWidth=1415&originalType=binary&ratio=1&rotation=0&showTitle=false&size=370496&status=done&style=none&taskId=u2b03936d-2878-467a-84c0-fc8402d8043&title=&width=1415" alt="image.png"></p>
<ul>
<li>AbstractFactory抽象工厂类：工厂方法模式的核心类，提供创建具体产品的接口，由具体工厂类实现；</li>
<li>Factory具体工厂类：继承于抽象工厂，实现创建对应具体产品对象的方式；</li>
<li>Product抽象产品类：是具体产品类的继承的父类或实现的接口。</li>
<li>ConcreteProductX具体产品类：工厂类所创建的对象就是此具体产品实例。<blockquote>
<p>产品族：</p>
</blockquote>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688698445699-b834fd4f-2481-460d-ae41-9a877220266b.png#averageHue=%23fefefc&clientId=uee24b681-3279-4&height=347&id=psiIl&originHeight=515&originWidth=795&originalType=binary&ratio=1&rotation=0&showTitle=false&size=122373&status=done&style=none&taskId=u04583773-5dd2-40b4-be42-a9de07f4969&title=&width=535" alt="image.png"></p>
<ul>
<li><strong>工厂方法模式解决的范畴</strong>是产品等级（大众汽车发动机，奔驰汽车发动机等）；<strong>抽象工厂模式解决的范畴</strong>是产品族等级（大众汽车、奔驰汽车等）；</li>
</ul>
<ol start="2">
<li><strong>【使用场景】：</strong></li>
</ol>
<ul>
<li>QQ 换皮肤，一整套一起换；</li>
<li>生成不同操作系统的程序。</li>
</ul>
<ol start="3">
<li><strong>【优缺点】：</strong></li>
</ol>
<ul>
<li><strong>优点：</strong><ul>
<li><strong>【确保单一产品族】</strong>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</li>
<li><strong>【具体的创建实例过程与客户端分离】</strong>客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>不容易扩展新的产品等级，比如我要加一个轮胎什么的。那么就需要修改抽象工厂，这样就会导致修改所有的工厂实现类。<strong>【违背开闭原则，跟简单工厂模式相似】</strong></li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>【特点】：</strong></li>
</ol>
<p>当涉及到这种产品族的问题的时候，就需要抽象工厂模式来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题。<br><img src="https://www.javadoop.com/blogimages/design-pattern/abstract-factory-3.png#id=BULkY&originHeight=868&originWidth=1522&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>这个时候，对于客户端来说，不再需要单独挑选 CPU厂商、主板厂商、硬盘厂商等，直接选择一家品牌工厂，品牌工厂会负责生产所有的东西，而且能保证肯定是兼容可用的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 第一步就要选定一个“大厂”</span></span><br><span class="line">    <span class="type">ComputerFactory</span> <span class="variable">cf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AmdFactory</span>();</span><br><span class="line">    <span class="comment">// 从这个大厂造 CPU</span></span><br><span class="line">    <span class="type">CPU</span> <span class="variable">cpu</span> <span class="operator">=</span> cf.makeCPU();</span><br><span class="line">    <span class="comment">// 从这个大厂造主板</span></span><br><span class="line">    <span class="type">MainBoard</span> <span class="variable">board</span> <span class="operator">=</span> cf.makeMainBoard();</span><br><span class="line">  	<span class="comment">// 从这个大厂造硬盘</span></span><br><span class="line">  	<span class="type">HardDisk</span> <span class="variable">hardDisk</span> <span class="operator">=</span> cf.makeHardDisk();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 将同一个厂子出来的 CPU、主板、硬盘组装在一起</span></span><br><span class="line">    <span class="type">Computer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(cpu, board, hardDisk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了<strong>对修改关闭，对扩展开放</strong>这个设计原则。</p>
<h2 id="2-5-建造者模式"><a href="#2-5-建造者模式" class="headerlink" title="2.5 建造者模式"></a>2.5 建造者模式</h2><blockquote>
<p>建房子</p>
</blockquote>
<ol>
<li><strong>【概念】：</strong>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688800648381-bd330041-3b59-4bfc-8850-6912fa8b86fe.png#averageHue=%233c3c3c&clientId=uaef691d9-ff29-4&from=paste&height=497&id=ub7af5856&originHeight=497&originWidth=879&originalType=binary&ratio=1&rotation=0&showTitle=false&size=115732&status=done&style=none&taskId=u39cf1373-3d37-4881-8e1e-cfc29d04830&title=&width=879" alt="image.png"></p>
<ul>
<li><strong>类图</strong></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/35382725/1688800578366-cf159401-2e93-46d2-8a2f-eec10a4820f7.jpeg#averageHue=%23f1f1ec&clientId=uaef691d9-ff29-4&from=drop&id=u6e9ed115&originHeight=324&originWidth=474&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17202&status=done&style=none&taskId=u625d0c96-e65c-4e66-8d0a-0ad1cd5d6ca&title=" alt="OIP-C.jpg"></p>
<ul>
<li>Product: 最终要生成的对象，例如 Computer实例。</li>
<li>Builder： 构建者的抽象基类（有时会使用接口代替）。其定义了构建Product的抽象步骤，其实体类需要实现这些步骤。其会包含一个用来返回最终产品的方法Product getProduct()。</li>
<li>ConcreteBuilder: Builder的实现类。</li>
<li>Director: 决定如何构建最终产品的算法. 其会包含一个负责组装的方法void Construct(Builder builder)， 在这个方法中通过调用builder的方法，就可以设置builder，等设置完成后，就可以通过builder的 getProduct() 方法获得最终的产品。</li>
</ul>
<ol start="2">
<li><strong>【使用场景】：</strong></li>
</ol>
<ul>
<li>JDK：StringBuilder</li>
</ul>
<ol start="3">
<li><strong>【优缺点】：</strong></li>
</ol>
<ul>
<li><strong>优点：</strong><ul>
<li>建造者独立，易扩展；</li>
<li>便于控制细节风险。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>产品必须有共同点，范围有限制；</li>
<li>如内部变化复杂，会有很多的建造类。</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>【特点】：</strong></li>
</ol>
<p>经常碰见的 XxxBuilder 的类，通常都是建造者模式的产物。建造者模式其实有很多的变种，但是对于客户端来说，我们的使用通常都是一个模式的：<br><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230212181536775.png#id=JUdSp&originHeight=205&originWidth=460&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoodBuilder</span>().a().b().c().build();</span><br><span class="line"><span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> Food.builder().a().b().c().build();</span><br></pre></td></tr></table></figure>
<p>套路就是先 new 一个 Builder，然后可以链式地调用一堆方法，最后再调用一次 build() 方法，我们需要的对象就有了。<br>来一个中规中矩的建造者模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// 下面是“一堆”的属性</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法私有化，不然客户端就会直接调用构造方法了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">User</span><span class="params">(String name, String password, String nickName, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">        <span class="built_in">this</span>.nickName = nickName;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 静态方法，用于生成一个 Builder，这个不一定要有，不过写这个方法是一个很好的习惯，</span></span><br><span class="line">    <span class="comment">// 有些代码要求别人写 new User.UserBuilder().a()...build() 看上去就没那么好</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserBuilder <span class="title function_">builder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserBuilder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserBuilder</span> &#123;</span><br><span class="line">        <span class="comment">// 下面是和 User 一模一样的一堆属性</span></span><br><span class="line">        <span class="keyword">private</span> String  name;</span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line">        <span class="keyword">private</span> String nickName;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">UserBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链式调用设置各个属性值，返回 this，即 UserBuilder</span></span><br><span class="line">        <span class="keyword">public</span> UserBuilder <span class="title function_">name</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> UserBuilder <span class="title function_">password</span><span class="params">(String password)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.password = password;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> UserBuilder <span class="title function_">nickName</span><span class="params">(String nickName)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.nickName = nickName;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> UserBuilder <span class="title function_">age</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// build() 方法负责将 UserBuilder 中设置好的属性“复制”到 User 中。</span></span><br><span class="line">        <span class="comment">// 当然，可以在 “复制” 之前做点检验</span></span><br><span class="line">        <span class="keyword">public</span> User <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (name == <span class="literal">null</span> || password == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户名和密码必填&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (age &lt;= <span class="number">0</span> || age &gt;= <span class="number">150</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;年龄不合法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 还可以做赋予”默认值“的功能</span></span><br><span class="line">          	<span class="keyword">if</span> (nickName == <span class="literal">null</span>) &#123;</span><br><span class="line">                nickName = name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(name, password, nickName, age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心是：先把所有的属性都设置给 Builder，然后 build() 方法的时候，将这些属性<strong>复制</strong>给实际产生的对象。<br>看看客户端的调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">APP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">d</span> <span class="operator">=</span> User.builder()</span><br><span class="line">                .name(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">                .password(<span class="string">&quot;pass12345&quot;</span>)</span><br><span class="line">                .age(<span class="number">25</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说实话，建造者模式的<strong>链式</strong>写法很吸引人，但是，多写了很多“无用”的 builder 的代码，感觉这个模式没什么用。不过，当属性很多，而且有些必填，有些选填的时候，这个模式会使代码清晰很多。我们可以在 <strong>Builder 的构造方法</strong>中强制让调用者提供必填字段，还有，在 build() 方法中校验各个参数比在 User 的构造方法中校验，代码要优雅一些。</p>
<ul>
<li>题外话：强烈建议读者使用 lombok，用了 lombok 以后，上面的一大堆代码会变成如下这样:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String  name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>怎么样，省下来的时间是不是又可以干点别的了。</p>
</blockquote>
</li>
</ul>
<p>当然，如果你只是想要链式写法，不想要建造者模式，有个很简单的办法，User 的 getter 方法不变，所有的 setter 方法都让其 <strong>return this</strong> 就可以了，然后就可以像下面这样调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>().setName(<span class="string">&quot;&quot;</span>).setPassword(<span class="string">&quot;&quot;</span>).setAge(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>很多人是这么用的，但是笔者觉得其实这种写法非常地不优雅，不是很推荐使用。</li>
</ul>
<h2 id="2-6-原型模式【-】"><a href="#2-6-原型模式【-】" class="headerlink" title="2.6 原型模式【*】"></a>2.6 原型模式【*】</h2><blockquote>
<p>细胞分裂</p>
</blockquote>
<ol>
<li><strong>【概念】：</strong>这种模式是实现了一个原型接口，该接口用于创建当前对象的<strong>“克隆”</strong>。当直接创建对象的代价比较大时，则采用这种模式。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688802266808-3555ffa2-798a-49f6-a01f-bd9b2290c358.png#averageHue=%232c2c2c&clientId=uaef691d9-ff29-4&from=paste&height=373&id=u1a576a19&originHeight=373&originWidth=767&originalType=binary&ratio=1&rotation=0&showTitle=false&size=175409&status=done&style=none&taskId=u2f36db2f-f9a3-48fc-987e-2ba4815ae58&title=&width=767" alt="image.png"></p>
<ul>
<li><strong>类图</strong></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688802090549-55e725e8-e8b9-4c71-884c-986bc0ce4ed1.png#averageHue=%23fdfdfb&clientId=uaef691d9-ff29-4&from=paste&height=450&id=u559d220d&originHeight=450&originWidth=1167&originalType=binary&ratio=1&rotation=0&showTitle=false&size=194926&status=done&style=none&taskId=ucddb773e-c677-48e9-b4ca-647a023737d&title=&width=1167" alt="image.png"></p>
<ul>
<li>Client类：发出指令的客户端</li>
<li>Prototype类：是一个接口，描述了一个对象如何克隆自身，比如必须拥有 clone() 方法</li>
<li>ConcretePrototype类：就是克隆具体的实现，不同对象有不同的实现来拷贝自身</li>
</ul>
<ol start="2">
<li><strong>【使用场景】：</strong></li>
</ol>
<ul>
<li>JDK：Object 类中有一个 clone() 方法，它用于生成一个新的对象，当然，如果我们要调用这个方法，java 要求我们的类必须先<strong>实现 Cloneable 接口</strong>，此接口没有定义任何方法，但是不这么做的话，在 clone() 的时候，会抛出CloneNotSupportedException 异常。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li><strong>【优缺点】：</strong></li>
</ol>
<ul>
<li><strong>优点：</strong><ul>
<li>【减少对象创建的成本】使用原型模式可以通过复制现有对象来创建新对象，而无需创建新对象的成本。因为它避免了重新初始化和设置对象的属性。</li>
<li>【简化对象的创建过程】原型模式可以避免复杂对象的创建过程，尤其是当创建对象需要进行一系列复杂的步骤时。这意味着你可以在实际需要时轻松地创建和配置对象，而不必在程序的许多地方执行大量的初始化和配置代码。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>【复制对象可能会带来副作用】例如如果原型对象的属性是可变的，那么它们的值可能会在对象被克隆时改变。</li>
<li>【复制对象可能会导致深度克隆问题】如果一个对象具有多层嵌套结构，复制它可能会变得很困难，因为你需要确保复制所有嵌套的对象及其属性。这可能会导致深度克隆问题。</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>【特点】：</strong></li>
</ol>
<p><strong>原型模式有两种实现方式：浅克隆和深克隆。</strong><br>【浅克隆】java 的克隆是浅克隆，碰到对象引用的时候，克隆出来的对象和原对象中的引用将指向同一个对象。</p>
<ul>
<li>浅克隆</li>
</ul>
<p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230212184626855.png#id=ZeRhR&originHeight=252&originWidth=523&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>【深克隆】通常实现深克隆的方法是将对象进行序列化，然后再进行反序列化。</p>
<ul>
<li>深克隆</li>
</ul>
<p><img src="https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230212184640045.png#id=KijBV&originHeight=266&originWidth=526&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>原型模式了解到这里我觉得就够了，各种变着法子说这种代码或那种代码是原型模式，没什么意义。</p>
<h1 id="3、结构型模式"><a href="#3、结构型模式" class="headerlink" title="3、结构型模式"></a>3、结构型模式</h1><p>作用：旨在通过改变代码结构来达到<strong>解耦</strong>的目的，使得我们的代码容易维护和扩展。</p>
<ol>
<li>代理模式是做方法增强的</li>
<li>适配器模式是把鸡包装成鸭这种用来适配接口的</li>
<li>桥梁模式做到了很好的解耦</li>
<li>装饰模式从名字上就看得出来，适合于装饰类或者说是增强类的场景</li>
<li>门面模式的优点是客户端不需要关心实例化过程，只要调用需要的方法即可</li>
<li>组合模式用于描述具有层次结构的数据</li>
<li>享元模式是为了在特定的场景中缓存已经创建的对象，用于提高性能。</li>
</ol>
<h2 id="3-1-代理模式【-】"><a href="#3-1-代理模式【-】" class="headerlink" title="3.1 代理模式【*】"></a>3.1 代理模式【*】</h2><blockquote>
<p>房东中介租房</p>
</blockquote>
<ol>
<li><strong>【概念】：</strong>为其他对象提供一种代理以控制对这个对象的访问。</li>
</ol>
<p>对客户端隐藏真实实现，由代理来负责客户端的所有请求。当然，代理只是个代理，它不会完成实际的业务逻辑，而是一层皮而已，但是对于客户端来说，它必须表现得就是客户端需要的真实实现。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688795893193-782b9b05-5fb4-4d6e-b38d-beb5d1bab0dd.png#averageHue=%23f3f3f3&clientId=uaef691d9-ff29-4&from=drop&id=u7e68262d&originHeight=242&originWidth=902&originalType=binary&ratio=1&rotation=0&showTitle=false&size=55852&status=done&style=none&taskId=u0a9559de-0ca8-41d5-a6bd-45b660d6d5e&title=" alt="20200712210951913.png"></p>
<ul>
<li>类图</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688795568343-e109224c-8557-469e-99a2-1e2889d779f1.png#averageHue=%23f8f6f4&clientId=uaef691d9-ff29-4&from=paste&height=596&id=u74811513&originHeight=596&originWidth=915&originalType=binary&ratio=1&rotation=0&showTitle=false&size=186036&status=done&style=none&taskId=u2b440129-77a8-4899-b534-52fdf562e8a&title=&width=915" alt="image.png"></p>
<ul>
<li>Client（客户方）</li>
<li>Proxy（代理角色类）</li>
<li>RealSubject（真实角色类）</li>
<li>Subject（抽象角色类）</li>
</ul>
<ol start="2">
<li><strong>【使用场景】：</strong></li>
</ol>
<ul>
<li>Spring 中实现动态代理：如 UserService 接口和 UserServiceImpl 实现</li>
<li>采用 JDK 的动态代理：java.lang.reflect.Proxy 类；</li>
<li>远程代理</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688796111305-44aadb28-3e21-41a4-b170-6e29d4f16dd0.png#averageHue=%23ebded6&clientId=uaef691d9-ff29-4&from=drop&id=u067a41af&originHeight=205&originWidth=553&originalType=binary&ratio=1&rotation=0&showTitle=false&size=96375&status=done&style=none&taskId=u7d15f37c-6555-4ab6-ae1d-f6e48603f44&title=" alt="20200712212908111.png"></p>
<ul>
<li>虚拟代理：根据需要创建开销很大的对象，通过它来存放实例化需要很长时间的真实对象，使其只有在真正需要时才被创建。</li>
<li>防火墙（Firewall）代理。</li>
</ul>
<ol start="3">
<li><strong>【优缺点】：</strong></li>
</ol>
<ul>
<li><strong>优点：</strong><ul>
<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li>
<li>代理对象可以扩展目标对象的功能；</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；</li>
<li>增加了系统的复杂度；</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>【特点】：</strong></li>
</ol>
<p>理解<strong>代理</strong>这个词，这个模式其实就简单了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FoodService</span> &#123;</span><br><span class="line">    Food <span class="title function_">makeChicken</span><span class="params">()</span>;</span><br><span class="line">    Food <span class="title function_">makeNoodle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FoodServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">FoodService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeChicken</span><span class="params">()</span> &#123;</span><br><span class="line">      	<span class="type">Food</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chicken</span>()</span><br><span class="line">        f.setChicken(<span class="string">&quot;1kg&quot;</span>);</span><br><span class="line">      	f.setSpicy(<span class="string">&quot;1g&quot;</span>);</span><br><span class="line">      	f.setSalt(<span class="string">&quot;3g&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeNoodle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Food</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Noodle</span>();</span><br><span class="line">        f.setNoodle(<span class="string">&quot;500g&quot;</span>);</span><br><span class="line">        f.setSalt(<span class="string">&quot;5g&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理要表现得“就像是”真实实现类，所以需要实现 FoodService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FoodServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">FoodService</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 内部一定要有一个真实的实现类，当然也可以通过构造方法注入</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">FoodService</span> <span class="variable">foodService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoodServiceImpl</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeChicken</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我们马上要开始制作鸡肉了&quot;</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 如果我们定义这句为核心代码的话，那么，核心代码是真实实现类做的，</span></span><br><span class="line">        <span class="comment">// 代理只是在核心代码前后做些“无足轻重”的事情</span></span><br><span class="line">        <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> foodService.makeChicken();</span><br><span class="line">      </span><br><span class="line">        System.out.println(<span class="string">&quot;鸡肉制作完成啦，加点胡椒粉&quot;</span>); <span class="comment">// 增强</span></span><br><span class="line">      	food.addCondiment(<span class="string">&quot;pepper&quot;</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> food;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeNoodle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备制作拉面~&quot;</span>);</span><br><span class="line">        <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> foodService.makeNoodle();</span><br><span class="line">        System.out.println(<span class="string">&quot;制作完成啦&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> food;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端调用，注意，我们要用代理来实例化接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里用代理类来实例化</span></span><br><span class="line"><span class="type">FoodService</span> <span class="variable">foodService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoodServiceProxy</span>();</span><br><span class="line">foodService.makeChicken();</span><br></pre></td></tr></table></figure>
<p><img src="https://www.javadoop.com/blogimages/design-pattern/proxy-1.png#id=XQpQe&originHeight=778&originWidth=1540&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>我们发现没有，代理模式说白了就是做 <strong>“方法包装”</strong> 或做 <strong>“方法增强”</strong>。在面向切面编程中，其实就是动态代理的过程。比如 Spring 中，我们自己不定义代理类，但是 Spring 会帮我们动态来定义代理，然后把我们定义在 @Before、@After、@Around 中的代码逻辑动态添加到代理中。<br>说到动态代理，又可以展开说，Spring 中实现动态代理有两种，一种是如果我们的类定义了接口，如 UserService 接口和 UserServiceImpl 实现，那么采用 JDK 的动态代理，感兴趣的读者可以去看看 java.lang.reflect.Proxy 类的源码；另一种是我们自己没有定义接口的，Spring 会采用 CGLIB 进行动态代理，它是一个 jar 包，性能还不错。</p>
<h2 id="3-2-适配器模式【-】"><a href="#3-2-适配器模式【-】" class="headerlink" title="3.2 适配器模式【*】"></a>3.2 适配器模式【*】</h2><blockquote>
<p>适配器转换头</p>
</blockquote>
<ul>
<li>跟“装饰器模式”的区别，装饰器模式要修改原先的接口，对功能进行扩展；适配器模式是原先接口没问题，但是存在“不兼容问题”，不需要修改原先的接口。</li>
</ul>
<ol>
<li><strong>【概念】：</strong>将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688701067620-14fa076e-293d-4cc1-9ee7-a0c77993c8e1.png#averageHue=%232e2e2e&clientId=uaef691d9-ff29-4&from=paste&height=694&id=u2ce79f64&originHeight=694&originWidth=1339&originalType=binary&ratio=1&rotation=0&showTitle=false&size=235036&status=done&style=none&taskId=ufbf3fb34-c9b2-4b38-8fa2-c49ff09f4b2&title=&width=1339" alt="image.png"></p>
<ul>
<li>Target：是一个接口，它是我们客户端使用的目标接口；</li>
<li>Adaptee：我们想要使用的接口与Target不兼容的类，它可以是一个接口，也可以是一个类；</li>
<li>Adapter适配器类：此模式的核心。它需要实现目标接口Target，而且必须要引用Adaptee，因为我们要在此类中包装Adaptee的功能；</li>
</ul>
<ol start="2">
<li><strong>【使用场景】：</strong></li>
</ol>
<ul>
<li>JAVA中的JDBC数据库连接池</li>
<li>在 LINUX 上运行 WINDOWS 程序</li>
</ul>
<ol start="3">
<li><strong>【优缺点】：</strong></li>
</ol>
<ul>
<li><strong>优点：</strong><ul>
<li>【增强程序的可扩展性】可以随意扩展程序的功能，但却不需要修改接口</li>
<li>【增加类的透明性和复用性】由于适配器模式将目标类和被适配类解耦，使得这些类可以独立地进行变化和复用。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>【增加系统的复杂性】由于适配器模式需要增加一个适配器类来进行接口转换，因此系统的结构变得更加复杂。</li>
<li>【降低系统的性能】由于适配器模式需要进行额外的接口转换操作，因此可能会降低系统的性能。</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>【特点】：</strong></li>
</ol>
<ul>
<li><p><strong>实现：</strong>假设我们有一个音乐播放器程序，其中包括一个播放MP3音乐的接口MusicPlayer和一个播放CD音乐的接口CdPlayer，而我们想要将CdPlayer适配成MusicPlayer接口，这时就可以使用适配器模式。</p>
</li>
<li><p>首先，我们定义目标接口MusicPlayer：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MusicPlayer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String fileName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，我们定义被适配者接口CdPlayer：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CdPlayer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playCd</span><span class="params">(String cdName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来，我们实现一个适配器类CdPlayerAdapter，它实现了目标接口MusicPlayer，并将被适配者接口CdPlayer的playCd方法转换成了目标接口MusicPlayer的play方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CdPlayerAdapter</span> <span class="keyword">implements</span> <span class="title class_">MusicPlayer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CdPlayer cdPlayer;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CdPlayerAdapter</span><span class="params">(CdPlayer cdPlayer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cdPlayer = cdPlayer;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        cdPlayer.playCd(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，我们可以使用适配器类CdPlayerAdapter来播放CD音乐了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CdPlayer</span> <span class="variable">cdPlayer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CdPlayerImpl</span>();</span><br><span class="line">        <span class="type">MusicPlayer</span> <span class="variable">musicPlayer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CdPlayerAdapter</span>(cdPlayer);</span><br><span class="line">        musicPlayer.play(<span class="string">&quot;CD_NAME&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>拓展：</strong></p>
</li>
</ul>
<p>适配器模式总体来说分三种：默认适配器模式——&gt;对象适配器模式——&gt;类适配器模式</p>
<blockquote>
<p><strong>1、默认适配器模式</strong></p>
</blockquote>
<p>首先，我们先看看最简单的适配器模式**默认适配器模式(Default Adapter)**是怎么样的。<br>我们用 Appache commons-io 包中的FileAlterationListener 做例子，此接口定义了很多的方法，用于对文件或文件夹进行监控，一旦发生了对应的操作，就会触发相应的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FileAlterationListener</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onDirectoryCreate</span><span class="params">(<span class="keyword">final</span> File directory)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onDirectoryChange</span><span class="params">(<span class="keyword">final</span> File directory)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onDirectoryDelete</span><span class="params">(<span class="keyword">final</span> File directory)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onFileCreate</span><span class="params">(<span class="keyword">final</span> File file)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onFileChange</span><span class="params">(<span class="keyword">final</span> File file)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onFileDelete</span><span class="params">(<span class="keyword">final</span> File file)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此接口的一大问题是抽象方法太多了，如果我们要用这个接口，意味着我们要实现每一个抽象方法，如果我们只是想要监控文件夹中的<strong>文件创建</strong>和<strong>文件删除</strong>事件，可是我们还是不得不实现所有的方法，很明显，这不是我们想要的。<br>所以，我们需要下面的一个<strong>适配器</strong>，它用于实现上面的接口，但是<strong>所有的方法都是空方法</strong>，这样，我们就可以转而定义自己的类来继承下面这个类即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileAlterationListenerAdaptor</span> <span class="keyword">implements</span> <span class="title class_">FileAlterationListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDirectoryCreate</span><span class="params">(<span class="keyword">final</span> File directory)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDirectoryChange</span><span class="params">(<span class="keyword">final</span> File directory)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDirectoryDelete</span><span class="params">(<span class="keyword">final</span> File directory)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileCreate</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileChange</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileDelete</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如我们可以定义以下类，我们仅仅需要实现我们想实现的方法就可以了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileMonitor</span> <span class="keyword">extends</span> <span class="title class_">FileAlterationListenerAdaptor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileCreate</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">        <span class="comment">// 文件创建</span></span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileDelete</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">        <span class="comment">// 文件删除</span></span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>MVC中也有默认适配器模式</li>
</ul>
<p>当然，上面说的只是适配器模式的其中一种，也是最简单的一种，无需多言。下面，再介绍<strong>“正统的”</strong>适配器模式。</p>
<blockquote>
<p><strong>2、对象适配器模式</strong></p>
</blockquote>
<p>来看一个《Head First 设计模式》中的一个例子，我稍微修改了一下，看看怎么将鸡适配成鸭，这样鸡也能当鸭来用。因为，现在鸭这个接口，我们没有合适的实现类可以用，所以需要适配器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span>; <span class="comment">// 鸭的呱呱叫</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>; <span class="comment">// 飞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Cock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gobble</span><span class="params">()</span>; <span class="comment">// 鸡的咕咕叫</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>; <span class="comment">// 飞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WildCock</span> <span class="keyword">implements</span> <span class="title class_">Cock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gobble</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;咕咕叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鸡也会飞哦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>鸭接口有 fly() 和 quare() 两个方法，鸡 Cock 如果要冒充鸭，fly() 方法是现成的，但是鸡不会鸭的呱呱叫，没有 quack() 方法。这个时候就需要适配了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 毫无疑问，首先，这个适配器肯定需要 implements Duck，这样才能当做鸭来用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CockAdapter</span> <span class="keyword">implements</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">  </span><br><span class="line">    Cock cock;</span><br><span class="line">    <span class="comment">// 构造方法中需要一个鸡的实例，此类就是将这只鸡适配成鸭来用</span></span><br><span class="line">  	<span class="keyword">public</span> <span class="title function_">CockAdapter</span><span class="params">(Cock cock)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cock = cock;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 实现鸭的呱呱叫方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 内部其实是一只鸡的咕咕叫</span></span><br><span class="line">        cock.gobble();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="meta">@Override</span></span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        cock.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端调用很简单了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 有一只野鸡</span></span><br><span class="line">  	<span class="type">Cock</span> <span class="variable">wildCock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WildCock</span>();</span><br><span class="line">  	<span class="comment">// 成功将野鸡适配成鸭</span></span><br><span class="line">  	<span class="type">Duck</span> <span class="variable">duck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CockAdapter</span>(wildCock);</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，大家也就知道了适配器模式是怎么回事了。无非是我们需要一只鸭，但是我们只有一只鸡，这个时候就需要定义一个适配器，由这个适配器来充当鸭，但是适配器里面的方法还是由鸡来实现的。<br>我们用一个图来简单说明下：<br><img src="https://www.javadoop.com/blogimages/design-pattern/adapter-1.png#id=fRnW3&originHeight=908&originWidth=1522&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>上图应该还是很容易理解的，我就不做更多的解释了。下面，我们看看类适配模式怎么样的。</p>
<blockquote>
<p><strong>3、类适配器模式</strong></p>
</blockquote>
<p>废话少说，直接上图：<br><img src="https://www.javadoop.com/blogimages/design-pattern/adapter-2.png#id=r64pt&originHeight=854&originWidth=1514&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>看到这个图，大家应该很容易理解的吧，通过继承的方法，适配器自动获得了所需要的大部分方法。这个时候，客户端使用更加简单，直接 <code>Target t = new SomeAdapter();</code> 就可以了。</p>
<blockquote>
<p><strong>4、适配器模式总结</strong></p>
</blockquote>
<ol>
<li>** 类适配<strong>和</strong>对象适配**的异同<br>一个采用继承，一个采用组合；<br>类适配属于静态实现，对象适配属于组合的动态实现，对象适配需要多实例化一个对象。<br>总体来说，对象适配用得比较多。 </li>
<li>适配器模式和代理模式的异同<br>比较这两种模式，其实是比较对象适配器模式和代理模式，在代码结构上，它们很相似，都需要一个具体的实现类的实例。但是它们的目的不一样，代理模式做的是增强原方法的活；适配器做的是适配的活，为的是提供“把鸡包装成鸭，然后当做鸭来使用”，而鸡和鸭它们之间原本没有继承关系。<br><img src="https://www.javadoop.com/blogimages/design-pattern/adapter-5.png#id=VjvAG&originHeight=1148&originWidth=1470&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></li>
</ol>
<h2 id="3-3-桥接模式"><a href="#3-3-桥接模式" class="headerlink" title="3.3 桥接模式"></a>3.3 桥接模式</h2><blockquote>
<p>电商线下卖各种商品【二维变一维，解耦】</p>
</blockquote>
<ol>
<li><strong>【概念】：</strong>将抽象和实现解耦，使得两者可以独立地变化。</li>
</ol>
<p>理解桥梁模式，其实就是理解代码抽象和解耦。（继承改为关联关系）</p>
<ul>
<li><strong>类图</strong></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688803746140-d745eefd-1134-4727-afd9-ed30071335a2.png#averageHue=%236b6a6b&clientId=uaef691d9-ff29-4&from=paste&height=637&id=ucd40e3c2&originHeight=637&originWidth=971&originalType=binary&ratio=1&rotation=0&showTitle=false&size=230203&status=done&style=none&taskId=ude0c375c-0b86-4ec0-aeca-7b55576a888&title=&width=971" alt="image.png"></p>
<ul>
<li><strong>抽象化(Abstraction)角色</strong>：抽象化给出的定义，并保存一个对实现化对象的引用。</li>
<li><strong>修正抽象化(Refined Abstraction)角色</strong>：扩展抽象化角色，改变和修正父类对抽象化的定义。</li>
<li><strong>实现化(Implementation)角色</strong>：这个角色给出实现化角色的接口，但不给出具体的实现。必须指出的是，这个接口不一定和抽象化角色的接口定义相同，实际上，这两个接口可以非常不一样。实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作。</li>
<li><strong>具体实现化(Concrete Implementor)角色</strong>：这个角色给出实现化角色接口的具体实现。</li>
</ul>
<ol start="2">
<li><strong>【使用场景】：</strong></li>
</ol>
<ul>
<li>在抽象和具体之间需要增加更多灵活性的场景；</li>
<li>一个类存在2个或者以上独立变化的维度，而这些维度又需要独立进行扩展时。</li>
</ul>
<ol start="3">
<li><strong>【优缺点】：</strong></li>
</ol>
<ul>
<li><strong>优点：</strong><ul>
<li>【分离抽象接口及其实现部分】桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。</li>
<li>【提高系统的可扩展性】在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合“开闭原则”</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>【增加系统的理解与设计难度】由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程。</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>【特点】：</strong></li>
</ol>
<ul>
<li><strong>解耦前：</strong></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688804023377-a1ddd553-c685-4d91-b83e-75f1e8cf863f.png#averageHue=%232e2f32&clientId=uaef691d9-ff29-4&from=paste&height=397&id=HTYrq&originHeight=592&originWidth=742&originalType=binary&ratio=1&rotation=0&showTitle=false&size=215530&status=done&style=none&taskId=u5fd57b5e-196f-4418-8829-3a2230a0030&title=&width=497" alt="image.png"></p>
<ul>
<li><strong>解耦后：</strong></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688804066444-1167d38e-7cfa-445e-8835-d81598e67bad.png#averageHue=%23302f31&clientId=uaef691d9-ff29-4&from=paste&height=204&id=u11690c19&originHeight=524&originWidth=1493&originalType=binary&ratio=1&rotation=0&showTitle=false&size=178178&status=done&style=none&taskId=u6a20dbf1-1ccd-476e-9629-c3977ac0beb&title=&width=580" alt="image.png"><br>我们首先需要一个桥梁，它是一个接口，定义提供的接口方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是一系列实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedPen</span> <span class="keyword">implements</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用红色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreenPen</span> <span class="keyword">implements</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用绿色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BluePen</span> <span class="keyword">implements</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用蓝色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个抽象类，此类的实现类都需要使用 DrawAPI：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> DrawAPI drawAPI;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Shape</span><span class="params">(DrawAPI drawAPI)</span> &#123;<span class="comment">//构造</span></span><br><span class="line">        <span class="built_in">this</span>.drawAPI = drawAPI;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义抽象类的子类：他可以注入笔</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 圆形</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> radius;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">int</span> radius, DrawAPI drawAPI)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(drawAPI);<span class="comment">//调用父类的有参构造</span></span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        drawAPI.draw(radius, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 长方形</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, DrawAPI drawAPI)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(drawAPI);</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        drawAPI.draw(<span class="number">0</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们来看客户端演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Shape</span> <span class="variable">greenCircle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">10</span>, <span class="keyword">new</span> <span class="title class_">GreenPen</span>());</span><br><span class="line">    <span class="type">Shape</span> <span class="variable">redRectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">4</span>, <span class="number">8</span>, <span class="keyword">new</span> <span class="title class_">RedPen</span>());</span><br><span class="line">    greenCircle.draw();</span><br><span class="line">    redRectangle.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能大家看上面一步步还不是特别清晰，我把所有的东西整合到一张图上：<br><img src="https://www.javadoop.com/blogimages/design-pattern/bridge-1.png#id=aAUGW&originHeight=1158&originWidth=1544&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>这回大家应该就知道抽象在哪里，怎么解耦了吧。桥梁模式的优点也是显而易见的，就是非常容易进行扩展。</p>
<h2 id="3-4-装饰器模式【-】"><a href="#3-4-装饰器模式【-】" class="headerlink" title="3.4 装饰器模式【*】"></a>3.4 装饰器模式【*】</h2><blockquote>
<p>将一个形状装饰上不同的颜色，同时又不改变形状。<br>孙悟空有72变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能；</p>
</blockquote>
<ol>
<li><strong>【概念】：</strong>装饰器模式又名包装(Wrapper)模式。动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。</li>
</ol>
<ul>
<li>装饰器模式以对客户端透明的方式拓展对象的功能，是继承关系的一种替代方案。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/35382725/1688811320289-d289fa79-a1fe-47a9-af9e-c4bb24b928ae.jpeg#averageHue=%23f1f1f1&clientId=uaef691d9-ff29-4&from=drop&height=444&id=u60c0bee4&originHeight=483&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=34640&status=done&style=none&taskId=u28610a00-7ce7-4a6d-9540-65e234235c0&title=&width=460" alt="v2-e522782edd431352b249572452ec36f6_b.jpg"></p>
<ul>
<li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</li>
<li>具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li>
<li>抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li>
<li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li>
</ul>
<p>Component 实现类 ConcreteComponent 的区别是，它们只是装饰者，起<strong>装饰</strong>作用，也就是即使它们看上去牛逼轰轰，但是它们都只是在具体的实现中<strong>加了层皮来装饰</strong>而已。</p>
<ol start="2">
<li><strong>【使用场景】：Java的IO流——&gt;InputStream流</strong></li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688699688789-ddf41b61-ed31-4b82-8a2b-7fba6b8e78cf.png#averageHue=%23343431&clientId=uee24b681-3279-4&from=paste&height=300&id=u3fe76574&originHeight=300&originWidth=1462&originalType=binary&ratio=1&rotation=0&showTitle=false&size=117047&status=done&style=none&taskId=ubd929e4e-cfd3-442d-997f-79cd0b32874&title=&width=1462" alt="image.png"></p>
<ol start="3">
<li><strong>【优缺点】：</strong></li>
</ol>
<ul>
<li><strong>优点：</strong><ul>
<li>装饰这模式和继承的目的都是扩展对象的功能，但装饰者模式比继承更灵活 通过使用不同的具体装饰类以及这些类的排列组合，设计师可以创造出很多不同行为的组合装饰者模式有很好地可扩展性</li>
<li>装饰类和被装饰类可以独立发展，而不会相互耦合。Component类无须知道Decorator类，而Decorator也不用知道具体的构件，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”。</li>
</ul>
</li>
<li>缺点：<ul>
<li>装饰者模式会导致设计中出现许多小对象，如果过度使用，会让程序变的更复杂。并且更多的对象会是的差错变得困难，特别是这些对象看上去都很像。</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>【特点】：</strong></li>
</ol>
<ul>
<li>“快乐柠檬”案例：</li>
</ul>
<p><img src="https://www.javadoop.com/blogimages/design-pattern/decorator-2.png#id=zu7Ew&originHeight=1158&originWidth=1546&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ul>
<li>装饰模式应用：Stream流</li>
</ul>
<p>下面，我们再来说说 java IO 中的装饰模式。看下图 InputStream 派生出来的部分类：<br><img src="https://www.javadoop.com/blogimages/design-pattern/decorator-3.png#id=fuZKC&originHeight=742&originWidth=1536&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>我们知道 InputStream 代表了输入流，具体的输入来源可以是文件（FileInputStream）、管道（PipedInputStream）、数组（ByteArrayInputStream）等，属于基础输入流。<br>FilterInputStream 承接了装饰模式的关键节点，它的实现类是一系列装饰器，</p>
<ul>
<li>比如 BufferedInputStream 代表用缓冲来装饰，也就<strong>使得输入流具有了缓冲的功能</strong></li>
<li>DataInputStream 的装饰，使得我们可以从输入流转换为 java 中的<strong>基本类型值</strong></li>
<li>LineNumberInputStream 代表用行号来装饰，在操作的时候就可以<strong>取得行号</strong>了</li>
</ul>
<p>当然，在 java IO 中，如果我们使用装饰器的话，就不太适合面向接口编程了，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LineNumberInputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;&quot;</span>)));</span><br></pre></td></tr></table></figure>
<p>这样的结果是，InputStream 还是不具有读取行号的功能，因为读取行号的方法定义在 LineNumberInputStream 类中。<br>我们应该像下面这样使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DataInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(</span><br><span class="line">  							<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(</span><br><span class="line">                              	<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;&quot;</span>)));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所以说嘛，要找到纯的严格符合设计模式的代码还是比较难的。</p>
</blockquote>
<h2 id="3-5-门面-外观模式"><a href="#3-5-门面-外观模式" class="headerlink" title="3.5 门面&#x2F;外观模式"></a>3.5 门面&#x2F;外观模式</h2><blockquote>
<p>公安局开证明，让工作人员安排</p>
</blockquote>
<ol>
<li><strong>【概念】：</strong>要求一个子系统的外与其内部的通信必须通过一个统一的对象进行，外观模式提供一个高层次的接口，使得子系统更易使用。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688811386066-2e0792b7-911a-4d5f-8798-9f03f68e14ad.png#averageHue=%23f2f2f2&clientId=uaef691d9-ff29-4&from=paste&height=364&id=ud0b87bf8&originHeight=387&originWidth=577&originalType=binary&ratio=1&rotation=0&showTitle=false&size=75829&status=done&style=none&taskId=u4aaabbd3-5292-47d1-a4c6-ab5da0fe580&title=&width=542" alt="image.png"></p>
<ul>
<li><strong>类图：</strong></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688787626733-754f382f-56a2-47b8-a5ec-d55f2d62c46d.png#averageHue=%23f6f6f6&clientId=uaef691d9-ff29-4&from=drop&id=wuCNw&originHeight=396&originWidth=770&originalType=binary&ratio=1&rotation=0&showTitle=false&size=52052&status=done&style=none&taskId=ue0912b89-486e-43f1-a4b1-ab02a4bb92f&title=" alt="20210520114447433.png"></p>
<ul>
<li>外观（Facade）角色：为多个子系统对外提供一个共同的接口。</li>
<li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</li>
<li>客户（Client）角色：通过一个外观角色访问各个子系统的功能。</li>
</ul>
<ol start="2">
<li><strong>【使用场景】：</strong></li>
</ol>
<ul>
<li>slf4j 就可以理解为是门面模式的应用；</li>
</ul>
<ol start="3">
<li><strong>【优缺点】：</strong></li>
</ol>
<ul>
<li><strong>优点：</strong><ul>
<li>【<strong>降低系统复杂度 &amp; 耦合度</strong>】通过引入一个新的外观角色来<strong>降低原有系统的复杂度，同时降低客户类与子系统的耦合度</strong>（所指的子系统是一个广义的概念，它可以是一个类、一个功能模块、系统的一个组成部分或者一个完整的系统），使得子系统更加易用</li>
<li><strong>【松耦合】</strong>它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>【减少可变性和灵活性】</strong>不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性</li>
<li><strong>【违背开闭原则】</strong>如果设计不当，增加新的子系统可能需要修改外观类的源代码</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>【特点】：</strong></li>
</ol>
<p>首先，我们定义一个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义几个实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Circle::draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Rectangle::draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 画一个圆形</span></span><br><span class="line">  	<span class="type">Shape</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">  	circle.draw();</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 画一个长方形</span></span><br><span class="line">  	<span class="type">Shape</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">  	rectangle.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是我们常写的代码，我们需要画圆就要先实例化圆，画长方形就需要先实例化一个长方形，然后再调用相应的 draw() 方法。<br>下面，我们看看怎么用门面模式来让客户端调用更加友好一些。<br>我们先定义一个门面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeMaker</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> Shape circle;</span><br><span class="line">   <span class="keyword">private</span> Shape rectangle;</span><br><span class="line">   <span class="keyword">private</span> Shape square;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">ShapeMaker</span><span class="params">()</span> &#123;</span><br><span class="line">      circle = <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">      rectangle = <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">      square = <span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 下面定义一堆方法，具体应该调用什么方法，由这个门面来决定</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">()</span>&#123;</span><br><span class="line">      circle.draw();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">()</span>&#123;</span><br><span class="line">      rectangle.draw();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawSquare</span><span class="params">()</span>&#123;</span><br><span class="line">      square.draw();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看看现在客户端怎么调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">ShapeMaker</span> <span class="variable">shapeMaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShapeMaker</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 客户端调用现在更加清晰了</span></span><br><span class="line">  shapeMaker.drawCircle();</span><br><span class="line">  shapeMaker.drawRectangle();</span><br><span class="line">  shapeMaker.drawSquare();		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>门面模式的优点显而易见，客户端不再需要关注实例化时应该使用哪个实现类，直接调用门面提供的方法就可以了，因为门面类提供的方法的方法名对于客户端来说已经很友好了。</p>
<h2 id="3-6-组合模式"><a href="#3-6-组合模式" class="headerlink" title="3.6 组合模式"></a>3.6 组合模式</h2><blockquote>
<p>地图（乡-镇-县-市-省-国）</p>
</blockquote>
<ol>
<li><strong>【概念】：</strong>组合模式依据<strong>树形结构</strong>来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/35382725/1688811440742-f80b9c8d-e365-4f2a-bfad-2ad26a160bcf.webp#averageHue=%23f7f7f7&clientId=uaef691d9-ff29-4&from=drop&id=u2d1181e4&originHeight=390&originWidth=610&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11196&status=done&style=none&taskId=u990385ce-7cd2-4c88-a6aa-677b07f898f&title=" alt="v2-1525efc414a6ad216bb71ccc8e4889e8_720w.webp"></p>
<ul>
<li><strong>类图</strong></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/35382725/1688811456903-0eccd8cf-ce69-4faa-a627-cee666af78c0.jpeg#averageHue=%23f0f0f0&clientId=uaef691d9-ff29-4&from=drop&id=u33bd26c9&originHeight=519&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=41909&status=done&style=none&taskId=u24a1082c-b2a4-418c-b0dd-8d92a46efb4&title=" alt="v2-44c5f1708c950ea16871b8d91315d0ea_b.jpg"></p>
<ul>
<li><strong>抽象构件（Component）角色：</strong>它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。（总的抽象类或接口，定义一些通用的方法，比如新增、删除）</li>
<li><strong>树叶构件（Leaf）角色：</strong>是组合中的叶节点对象，它没有子节点，用于继承或实现抽象构件。</li>
<li><strong>树枝构件（Composite）角色 &#x2F; 中间构件：</strong>是组合中的分支节点对象，它有子节点，用于继承和实现抽象构件。它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法。</li>
</ul>
<ol start="2">
<li><strong>【使用场景】：</strong></li>
</ol>
<ul>
<li>算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数；</li>
<li>JDK：AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。</li>
</ul>
<ol start="3">
<li><strong>【优缺点】：</strong></li>
</ol>
<ul>
<li><strong>优点：</strong><ul>
<li>利用多态和递归机制更方便地使用复杂树结构；</li>
<li>【符合开闭原则】节点自由增加；</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>【违反依赖倒置原则】在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口；</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>【特点】：</strong><blockquote>
<p>桥接模式是传入对象，组合模式是list和对象调用方法一致</p>
</blockquote>
</li>
</ol>
<p>组合模式用于表示具有层次结构的数据，使得我们对单个对象和组合对象的访问具有一致性。<br>直接看一个例子吧，每个员工都有姓名、部门、薪水这些属性，同时还有下属员工集合（虽然可能集合为空），而下属员工和自己的结构是一样的，也有姓名、部门这些属性，同时也有他们的下属员工集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String dept;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> salary;</span><br><span class="line">   <span class="keyword">private</span> List&lt;Employee&gt; subordinates; <span class="comment">// 下属</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name,String dept, <span class="type">int</span> sal)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="built_in">this</span>.dept = dept;</span><br><span class="line">      <span class="built_in">this</span>.salary = sal;</span><br><span class="line">      subordinates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Employee&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Employee e)</span> &#123;</span><br><span class="line">      subordinates.add(e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Employee e)</span> &#123;</span><br><span class="line">      subordinates.remove(e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">getSubordinates</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> subordinates;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="string">&quot;Employee :[ Name : &quot;</span> + name + <span class="string">&quot;, dept : &quot;</span> + dept + <span class="string">&quot;, salary :&quot;</span> + salary+<span class="string">&quot; ]&quot;</span>);</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常，这种类需要定义 add(node)、remove(node)、getChildren() 这些方法。</p>
<blockquote>
<p>很多源码中如果出现xxxComposite的样式，就是组合模式</p>
</blockquote>
<h2 id="3-7-享元模式"><a href="#3-7-享元模式" class="headerlink" title="3.7 享元模式"></a>3.7 享元模式</h2><blockquote>
<p>共享单车【池技术：内部状态共享，外部状态实现子类定义】</p>
</blockquote>
<ol>
<li><strong>【概念】：</strong>运用共享技术有效地支持大量细粒度的对象。主要用于减少创建对象的数量，以减少内存占用和提高性能。它提供了减少对象数量从而改善应用所需的对象结构的方式。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688798623479-fe315228-421a-449e-be21-e21558c4733a.png#averageHue=%232a2a2a&clientId=uaef691d9-ff29-4&from=paste&height=307&id=u842df804&originHeight=307&originWidth=833&originalType=binary&ratio=1&rotation=0&showTitle=false&size=48442&status=done&style=none&taskId=uacab6053-8e8e-4e04-8705-8966d2b2e9f&title=&width=833" alt="image.png"></p>
<ul>
<li><strong>类图：</strong></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688798148356-3443376e-3217-411d-bda8-f464ca3709bb.png#averageHue=%23f3f3f3&clientId=uaef691d9-ff29-4&from=paste&height=346&id=ud7356f19&originHeight=346&originWidth=754&originalType=binary&ratio=1&rotation=0&showTitle=false&size=70820&status=done&style=none&taskId=u6c9ba4e6-465e-4e96-9861-385f9fc6a6a&title=&width=754" alt="image.png"></p>
<ul>
<li>享元工厂（FlyweightFactory）：用于创建具体享元类，维护相同的享元对象。</li>
<li>抽象享元（Flyweight）：定义需要共享的对象业务接口。</li>
<li>具体享元（ConcreteFlyweight）：实现抽象享元类的接口，完成某一具体逻辑。</li>
</ul>
<ol start="2">
<li><strong>【使用场景】：</strong></li>
</ol>
<ul>
<li>JDK：String类，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。</li>
<li>连接池：数据库连接池 &amp;&amp; 并发线程连接池</li>
</ul>
<ol start="3">
<li><strong>【优缺点】：</strong></li>
</ol>
<ul>
<li><strong>优点：</strong><ul>
<li>【减少内存消耗】通过共享对象，可以减少系统中对象的数量，从而减少内存消耗。</li>
<li>【实现对象的复用】通过共享对象，可以实现对象的复用，避免重复创建对象。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>【提高系统的复杂度】需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>【特点】：</strong></li>
</ol>
<p>定义抽象享元类（Book）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">borrow</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义具体享元类（ConcreteBook）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteBook</span> <span class="keyword">implements</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="comment">//被借出的书名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteBook</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">borrow</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;图书馆借出一本书，书名为：&quot;</span> + <span class="built_in">this</span>.name );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>享元工厂（Llibrary）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Library</span> &#123;</span><br><span class="line">    <span class="comment">//图书馆维护一个图书列表</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Book&gt; bookPools = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Book&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Library</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Library</span>();</span><br><span class="line">    <span class="comment">//图书馆只有一个</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Library <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//图书馆外借图书</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">libToBorrow</span><span class="params">(String bookName)</span>&#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">order</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//如果书架有，直接借出</span></span><br><span class="line">        <span class="keyword">if</span> (bookPools.containsKey(bookName)) &#123;</span><br><span class="line">            order = bookPools.get(bookName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果书架没有，那就调进来一本新书</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            order = <span class="keyword">new</span> <span class="title class_">ConcreteBook</span>(bookName);</span><br><span class="line">            bookPools.put(bookName, order);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//图书馆书架上的书的数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAllBookSize</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookPools.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模拟学生去借书</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">//图书馆书架上的书</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Book&gt; books = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Book&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Library library;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        library = Library.getInstance();</span><br><span class="line">        studentBorrow(<span class="string">&quot;java编程思想&quot;</span>);</span><br><span class="line">        studentBorrow(<span class="string">&quot;java核心卷一&quot;</span>);</span><br><span class="line">        studentBorrow(<span class="string">&quot;java从入门到精通&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;后两本没学会，又借了一次 &quot;</span>);</span><br><span class="line">        studentBorrow(<span class="string">&quot;java核心卷一&quot;</span>);</span><br><span class="line">        studentBorrow(<span class="string">&quot;java从入门到精通&quot;</span>);</span><br><span class="line">        <span class="comment">//把每一本书借出去</span></span><br><span class="line">        <span class="keyword">for</span> (Book book : books) &#123;</span><br><span class="line">            book.borrow();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出一些学生一共借多少本书</span></span><br><span class="line">        System.out.println(<span class="string">&quot;学生一共借了 &quot;</span> + books.size() + <span class="string">&quot; 本书! &quot;</span>);</span><br><span class="line">        <span class="comment">//输出一下图书馆一共借出多少本书</span></span><br><span class="line">        System.out.println(<span class="string">&quot;图书馆实际借出&quot;</span> + library.getAllBookSize() + <span class="string">&quot; 本书&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">studentBorrow</span><span class="params">(String bookName)</span> &#123;</span><br><span class="line">        books.add(library.libToBorrow(bookName));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是享元模式的代码实现，其实在这里最为关键的就是<strong>享元工厂类</strong>。享元模式的思想也主要在这个类中去体现。最后我们把享元模式和其他的模式进行一个对比分析。</p>
<h1 id="4、行为型模式"><a href="#4、行为型模式" class="headerlink" title="4、行为型模式"></a>4、行为型模式</h1><p>行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使得我们的代码更加地清晰。<br>行为型模式部分介绍了策略模式、观察者模式、责任链模式、模板方法模式和状态模式，其实，经典的行为型模式还包括备忘录模式、命令模式等。</p>
<h2 id="4-1-策略模式【-】"><a href="#4-1-策略模式【-】" class="headerlink" title="4.1 策略模式【*】"></a>4.1 策略模式【*】</h2><blockquote>
<p>洗衣机的模式选择</p>
</blockquote>
<ol>
<li><strong>【概念】：</strong>定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688794977369-c0299402-f29f-48a1-9035-e5d3edb37ef3.png#averageHue=%232e2a2a&clientId=uaef691d9-ff29-4&from=paste&height=525&id=ude845edf&originHeight=525&originWidth=875&originalType=binary&ratio=1&rotation=0&showTitle=false&size=57708&status=done&style=none&taskId=ud87384e0-d709-455c-b442-46b6006179c&title=&width=875" alt="image.png"></p>
<ul>
<li>类图</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688794949647-822087e3-f273-44aa-9cfb-2b321c58878c.png#averageHue=%23f6f4f1&clientId=uaef691d9-ff29-4&from=paste&height=440&id=uedc8052c&originHeight=440&originWidth=1075&originalType=binary&ratio=1&rotation=0&showTitle=false&size=191187&status=done&style=none&taskId=ue6a2eadc-f7fe-435d-8163-636873508cd&title=&width=1075" alt="image.png"></p>
<ul>
<li>Context（环境类）：使用策略算法的角色</li>
<li>Strategy(抽象策略类)：声明了抽象方法，是所有策略类的父类，它可以是抽象类或者具体类，也可以是接口。</li>
<li>ConcreteStrategy(具体策略类)：实现了在抽象策略类中声明的算法，使用一种具体的算法实现某个业务功能。</li>
</ul>
<ol start="2">
<li><strong>【使用场景】：</strong></li>
</ol>
<ul>
<li><strong>JDK：</strong>ThreadPoolExecutor线程池里的拒绝策略</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688794869674-af170ddd-42f2-45ec-ac72-557f4e4a6aee.png#averageHue=%23333230&clientId=uaef691d9-ff29-4&from=paste&height=407&id=u98240ea0&originHeight=407&originWidth=1007&originalType=binary&ratio=1&rotation=0&showTitle=false&size=88288&status=done&style=none&taskId=u6e977453-1822-4bd5-b8b6-e44cbf16bf4&title=&width=1007" alt="image.png"></p>
<ul>
<li><strong>JDK：</strong>Collections.sort(List<T> list, Comparator&lt;? super T&gt; c)方法，这个方法接受一个比较器Compartor参数，客户端在运行时可以传入一个比较器的实现，sort()方法中根据不同实现，按照不同的方式进行排序。</li>
</ul>
<ol start="3">
<li><strong>【优缺点】：</strong></li>
</ol>
<ul>
<li><strong>优点：</strong><ul>
<li>策略模式符合开闭原则；</li>
<li>避免使用多重条件转移语句，如if…else…语句、switch语句；</li>
<li>使用策略模式可以提高算法的保密性和安全性；</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>客户端必须知道所有的策略，并且自行决定使用哪一个策略类；</li>
<li>代码中会产生非常多策略类，增加维护难度；</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>【特点】：</strong></li>
</ol>
<p>首先，先定义一个策略接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们定义具体的几个策略：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedPen</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;用红色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreenPen</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;用绿色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BluePen</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;用蓝色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用策略的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(Strategy strategy)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">executeDraw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> strategy.draw(radius, x, y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">BluePen</span>()); <span class="comment">// 使用绿色笔来画</span></span><br><span class="line">  	context.executeDraw(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>放到一张图上，让大家看得清晰些：<br><img src="https://www.javadoop.com/blogimages/design-pattern/strategy-1.png#id=TUHvK&originHeight=1156&originWidth=1544&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>这个时候，大家有没有联想到结构型模式中的桥梁模式，它们其实非常相似，我把桥梁模式的图拿过来大家对比下：<br><img src="https://www.javadoop.com/blogimages/design-pattern/bridge-1.png#id=jHM8K&originHeight=1158&originWidth=1544&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>要我说的话，它们非常相似，桥梁模式在左侧加了一层抽象而已。<strong>桥梁模式的耦合更低</strong>，结构更复杂一些。</p>
<h2 id="4-2-观察者模式"><a href="#4-2-观察者模式" class="headerlink" title="4.2 观察者模式"></a>4.2 观察者模式</h2><blockquote>
<p>欠钱还钱，有钱就通知</p>
</blockquote>
<ol>
<li><strong>【概念】：</strong>观察者模式(Observer Pattern):定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688702180424-3eb182a3-be9f-4c7e-bc58-1a2c2117f4d8.png#averageHue=%232c2c2c&clientId=uaef691d9-ff29-4&from=paste&height=417&id=ub57f7908&originHeight=809&originWidth=1113&originalType=binary&ratio=1&rotation=0&showTitle=false&size=144691&status=done&style=none&taskId=u3c60d3f6-d0d0-4c01-b03b-659d6ead0c7&title=&width=574" alt="image.png"></p>
<ul>
<li>类图</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/35382725/1688787096869-b6b20ce8-bc69-41e4-b28e-a197b03fdbe7.jpeg#averageHue=%23f4f4f4&clientId=uaef691d9-ff29-4&from=drop&height=408&id=udb42b9d7&originHeight=462&originWidth=590&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18802&status=done&style=none&taskId=u56087300-8a4b-4169-b4c1-641000c1bd4&title=&width=521" alt="v2-4ad3e0b3c15d542518aa433ed9a8c640_720w.jpg"></p>
<ul>
<li><strong>抽象主题（Subject）角色：</strong>也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。</li>
<li><strong>具体主题（Concrete Subject）角色：</strong>也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</li>
<li><strong>抽象观察者（Observer）角色：</strong>它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。</li>
<li><strong>具体观察者（Concrete Observer）角色：</strong>实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。</li>
</ul>
<ol start="2">
<li><strong>【使用场景】：java.util.Observable 和 java.util.Observer 这两个类</strong></li>
<li><strong>【优缺点】：</strong></li>
</ol>
<ul>
<li><strong>优点：</strong><ul>
<li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li>
<li>目标与观察者之间建立了一套触发机制。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</li>
<li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>【特点】：</strong></li>
</ol>
<p>观察者模式对于我们来说，真是再简单不过了。无外乎两个操作，观察者订阅自己关心的主题和主题有数据变化后通知观察者们。**(注册观察者后通知)**<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688702223331-af234c6a-8f5a-4c8a-b568-181907a4260f.png#averageHue=%23302f2f&clientId=uaef691d9-ff29-4&from=paste&height=380&id=u4ce72b49&originHeight=380&originWidth=918&originalType=binary&ratio=1&rotation=0&showTitle=false&size=139778&status=done&style=none&taskId=ud21cc16b-c7dc-4977-9298-455119d37a4&title=&width=918" alt="image.png"><br>首先，需要定义主题，每个主题需要持有观察者列表的引用，用于在数据变更的时候通知各个观察者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">        <span class="comment">// 数据已变更，通知观察者们</span></span><br><span class="line">        notifyAllObservers();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册观察者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知观察者们</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyAllObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义观察者接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Subject subject;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实如果只有一个观察者类的话，接口都不用定义了，不过，通常场景下，既然用到了观察者模式，我们就是希望一个事件出来了，会有多个不同的类需要处理相应的信息。比如，订单修改成功事件，我们希望发短信的类得到通知、发邮件的类得到通知、处理物流信息的类得到通知等。<br>我们来定义具体的几个观察者类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryObserver</span> <span class="keyword">extends</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">// 在构造方法中进行订阅主题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BinaryObserver</span><span class="params">(Subject subject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subject = subject;</span><br><span class="line">        <span class="comment">// 通常在构造方法中将 this 发布出去的操作一定要小心</span></span><br><span class="line">        <span class="built_in">this</span>.subject.attach(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该方法由主题类在数据变更的时候进行调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> Integer.toBinaryString(subject.getState());</span><br><span class="line">        System.out.println(<span class="string">&quot;订阅的数据发生变化，新的数据处理为二进制值为：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HexaObserver</span> <span class="keyword">extends</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HexaObserver</span><span class="params">(Subject subject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subject = subject;</span><br><span class="line">        <span class="built_in">this</span>.subject.attach(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> Integer.toHexString(subject.getState()).toUpperCase();</span><br><span class="line">        System.out.println(<span class="string">&quot;订阅的数据发生变化，新的数据处理为十六进制值为：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端使用也非常简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 先定义一个主题</span></span><br><span class="line">    <span class="type">Subject</span> <span class="variable">subject1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Subject</span>();</span><br><span class="line">    <span class="comment">// 定义观察者</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">BinaryObserver</span>(subject1);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HexaObserver</span>(subject1);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 模拟数据变更，这个时候，观察者们的 update 方法将会被调用</span></span><br><span class="line">    subject.setState(<span class="number">11</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">订阅的数据发生变化，新的数据处理为二进制值为：1011</span><br><span class="line">订阅的数据发生变化，新的数据处理为十六进制值为：B</span><br></pre></td></tr></table></figure>
<p>实际生产过程中，观察者模式往往用消息中间件来实现，如果要实现单机观察者模式，笔者建议读者使用 Guava 中的 EventBus，它有同步实现也有异步实现，本文主要介绍设计模式，就不展开说了。<br>还有，即使是上面的这个代码，也会有很多变种，大家只要记住核心的部分，那就是一定有一个地方存放了所有的观察者，然后在事件发生的时候，遍历观察者，调用它们的回调函数。</p>
<h2 id="4-3-责任链模式"><a href="#4-3-责任链模式" class="headerlink" title="4.3 责任链模式"></a>4.3 责任链模式</h2><blockquote>
<p>请假审批流程</p>
</blockquote>
<ol>
<li><strong>【概念】：</strong>责任链模式(Chain of Responsibility)是一种处理请求的模式，它让多个处理器都有机会处理该请求，直到其中某个处理成功为止。责任链模式把多个处理器串成链，然后让请求在链上传递。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688796371382-b477ced1-0b5c-4ea7-a9be-18e0f002bac4.png#averageHue=%232b2b2b&clientId=uaef691d9-ff29-4&from=paste&height=271&id=u12504a84&originHeight=271&originWidth=1242&originalType=binary&ratio=1&rotation=0&showTitle=false&size=78682&status=done&style=none&taskId=u91e640ad-0757-441d-90c4-512f7bc85ae&title=&width=1242" alt="image.png"></p>
<ul>
<li><strong>类图：</strong></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/35382725/1688796526469-67534bdc-4ce3-4817-9808-a38e1fce01bc.webp#averageHue=%23f1f1f1&clientId=uaef691d9-ff29-4&from=drop&id=ua462ec68&originHeight=458&originWidth=720&originalType=binary&ratio=1&rotation=0&showTitle=false&size=28448&status=done&style=none&taskId=u56718c9a-6f60-410c-90b5-caaca9df2b9&title=" alt="v2-323352bbdc7d89ec9835819fc63e779c_720w.webp"></p>
<ul>
<li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li>
<li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li>
<li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li>
<li><strong>结构图：</strong></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/35382725/1688796551714-b03d3eda-8700-48e9-9f86-f6b4b8095920.jpeg#averageHue=%23f5f5f5&clientId=uaef691d9-ff29-4&from=drop&id=ub5906214&originHeight=178&originWidth=650&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16886&status=done&style=none&taskId=uf0d260c6-e56a-489b-8106-b829a625e62&title=" alt="v2-56e0265703ecd889cb2f4b14a414d5c9_720w.jpg"></p>
<ol start="2">
<li><strong>【使用场景】：</strong></li>
</ol>
<ul>
<li>JS 中的事件冒泡；</li>
<li>JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。</li>
</ul>
<ol start="3">
<li><strong>【优缺点】：</strong></li>
</ol>
<ul>
<li><strong>优点：</strong><ul>
<li>【降低耦合度】它将请求的发送者和接收者解耦 </li>
<li>【简化对象】使得对象不需要知道链的结构 </li>
<li>【增强给对象指派职责的灵活性】允许动态地新增或者删除责任链 </li>
<li>增加新的请求处理类方便</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>不能保证请求一定被接收； </li>
<li>系统性能将受到一定影响，调试时不方便，可能会造成循环调用</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>【特点】：</strong></li>
</ol>
<p>有这么一个场景，用户参加一个活动可以领取奖品，但是活动需要进行很多的规则校验然后才能放行，比如首先需要校验用户是否是新用户、今日参与人数是否有限额、全场参与人数是否有限额等等。设定的规则都通过后，才能让用户领走奖品。<br>首先，我们要定义流程上节点的基类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RuleHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 后继节点 ，如果把这个类命名为next你就更能理解了</span></span><br><span class="line">    <span class="keyword">protected</span> RuleHandler successor;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Context context)</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuccessor</span><span class="params">(RuleHandler successor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> RuleHandler <span class="title function_">getSuccessor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们需要定义具体的每个节点了。<br>校验用户是否是新用户：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewUserRuleHandler</span> <span class="keyword">extends</span> <span class="title class_">RuleHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (context.isNewUser()) &#123;</span><br><span class="line">            <span class="comment">// 如果有后继节点的话，传递下去</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.getSuccessor() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.getSuccessor().apply(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;该活动仅限新用户参与&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>校验用户所在地区是否可以参与：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocationRuleHandler</span> <span class="keyword">extends</span> <span class="title class_">RuleHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">allowed</span> <span class="operator">=</span> activityService.isSupportedLocation(context.getLocation);</span><br><span class="line">        <span class="keyword">if</span> (allowed) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.getSuccessor() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.getSuccessor().apply(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;非常抱歉，您所在的地区无法参与本次活动&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>校验奖品是否已领完：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LimitRuleHandler</span> <span class="keyword">extends</span> <span class="title class_">RuleHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">remainedTimes</span> <span class="operator">=</span> activityService.queryRemainedTimes(context); <span class="comment">// 查询剩余奖品</span></span><br><span class="line">        <span class="keyword">if</span> (remainedTimes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.getSuccessor() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.getSuccessor().apply(userInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;您来得太晚了，奖品被领完了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">RuleHandler</span> <span class="variable">newUserHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewUserRuleHandler</span>();</span><br><span class="line">    <span class="type">RuleHandler</span> <span class="variable">locationHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocationRuleHandler</span>();</span><br><span class="line">    <span class="type">RuleHandler</span> <span class="variable">limitHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LimitRuleHandler</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 假设本次活动仅校验地区和奖品数量，不校验新老用户</span></span><br><span class="line">    locationHandler.setSuccessor(limitHandler);</span><br><span class="line">  </span><br><span class="line">    locationHandler.apply(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码其实很简单，就是先定义好一个链表，然后在通过任意一节点后，如果此节点有后继节点，那么传递下去。<br>至于它和我们前面说的用一个 List 存放需要执行的规则的做法有什么异同，留给读者自己琢磨吧。</p>
<h2 id="4-4-模板方法模式【-】"><a href="#4-4-模板方法模式【-】" class="headerlink" title="4.4 模板方法模式【*】"></a>4.4 模板方法模式【*】</h2><blockquote>
<p>新东方学做菜</p>
</blockquote>
<ol>
<li><strong>【概念】：</strong>定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤【在含有继承结构的代码中，模板方法模式是非常常用的。(回调)】</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688797613102-d96e6bba-bd11-4a13-8fa0-9bb6ea4da7da.png#averageHue=%23323131&clientId=uaef691d9-ff29-4&from=paste&height=525&id=u7df2bbc2&originHeight=525&originWidth=1019&originalType=binary&ratio=1&rotation=0&showTitle=false&size=93676&status=done&style=none&taskId=u3104c5e7-6d5b-4765-86f4-c3524f2e49b&title=&width=1019" alt="image.png"></p>
<ul>
<li><strong>类图</strong></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688797472069-d03bfc7d-612f-4555-9b87-e11cc9331021.png#averageHue=%232f2e2e&clientId=uaef691d9-ff29-4&from=paste&height=730&id=ub6b255cd&originHeight=730&originWidth=1121&originalType=binary&ratio=1&rotation=0&showTitle=false&size=174386&status=done&style=none&taskId=u25401e49-5a2e-4485-820f-42e0dbafa95&title=&width=1121" alt="image.png"></p>
<ul>
<li>AbstractClass（抽象模板类）</li>
<li>ConcreteClass（模板实现子类）</li>
</ul>
<ol start="2">
<li><strong>【使用场景】：</strong></li>
</ol>
<ul>
<li>JDK：静态的Arrays.sort(Object[])，sort()是一个模板方法，然后需要我们自定义实现 compareTo()方法,用来“填补”模板方法的缺陷；</li>
<li>Java并发包的大核心，AbstactQueuedSynchronizer（简称AQS），其提供的 acquire() 方法用来获取锁，但是需要具体的锁实现类去自定义完成 tryAcquire() 方法。</li>
</ul>
<ol start="3">
<li><strong>【优缺点】：</strong></li>
</ol>
<ul>
<li><strong>优点：</strong><ul>
<li>【提高代码的复用性】利用模板方法将相同处理逻辑的代码放到抽象父类中；</li>
<li>【提高代码的扩展性】将不同的代码不同的子类中，通过对子类的扩展增加新的行为；</li>
<li>【符合开闭原则】把不变的行为写在父类上，去除子类的重复代码，提供了一个很好的代码复用平台。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>【增加系统实现复杂度】类数目的增加，每一个抽象类都需要一个子类来实现，这样导致类的个数增加。</li>
<li>【继承关系自身缺点】如果父类添加新的抽象方法，所有子类都要改一遍。</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>【特点】：</strong></li>
</ol>
<p>通常会有一个抽象类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractTemplate</span> &#123;</span><br><span class="line">    <span class="comment">// 这就是模板方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        init();</span><br><span class="line">        apply(); <span class="comment">// 这个是重点</span></span><br><span class="line">        end(); <span class="comment">// 可以作为钩子方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init 抽象层已经实现，子类也可以选择覆写&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 留给子类实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板方法中调用了 3 个方法，其中 apply() 是抽象方法，子类必须实现它，其实模板方法中有几个抽象方法完全是自由的，我们也可以将三个方法都设置为抽象方法，让子类来实现。也就是说，模板方法只负责定义第一步应该要做什么，第二步应该做什么，第三步应该做什么，至于怎么做，由子类来实现。<br>我们写一个实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteTemplate</span> <span class="keyword">extends</span> <span class="title class_">AbstractTemplate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类实现抽象方法 apply&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我们可以把 method3 当做钩子方法来使用，需要的时候覆写就可以了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端调用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AbstractTemplate</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteTemplate</span>();</span><br><span class="line">    <span class="comment">// 调用模板方法</span></span><br><span class="line">    t.templateMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码其实很简单，基本上看到就懂了，关键是要学会用到自己的代码中。</p>
<blockquote>
<p>如果在源码中看到了final修饰符，而该方法中调用了其他源码，很可能就是模板方法模式</p>
</blockquote>
<h2 id="4-5-状态模式"><a href="#4-5-状态模式" class="headerlink" title="4.5 状态模式"></a>4.5 状态模式</h2><blockquote>
<p>根据心情做事情，解决if else问题</p>
</blockquote>
<ol>
<li><strong>【概念】：</strong>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States),状态模式是一种对象行为型模式。</li>
</ol>
<p>【阿里Java开发手册】如果非得使用if()..else if()…else..方式表达逻辑，【强制】避免后续代码维护困难，请勿超过3层。<br><strong>正例：超过3层的if-eLse的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，</strong></p>
<ul>
<li><p><strong>卫语句</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)&#123;</span><br><span class="line">	<span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688788458311-4d6d8f73-01b2-4f1d-bc08-965eab23f56d.png#averageHue=%23f4f2ee&clientId=uaef691d9-ff29-4&from=paste&height=353&id=ucf32a376&originHeight=355&originWidth=772&originalType=binary&ratio=1&rotation=0&showTitle=false&size=131661&status=done&style=none&taskId=uc81f1dcc-4497-460b-8b57-1620bf43aa6&title=&width=768" alt="image.png"></p>
</li>
<li><p>State：是一个接口，封装了状态及其行为</p>
</li>
<li><p>ConcreteState X：State的实现类，表示具体的状态</p>
</li>
<li><p>Context：保持并切换各个状态，其持有一个State的引用。它将依赖状态的各种操作委托给不同的状态对象执行。其负责与客户端交互</p>
</li>
</ul>
<ol start="2">
<li><strong>【使用场景】：</strong></li>
</ol>
<ul>
<li>打篮球的时候运动员可以有正常状态、不正常状态和超常状态。</li>
<li>曾侯乙编钟中，’钟是抽象接口’,’钟A’等是具体状态，’曾侯乙编钟’是具体环境（Context）。</li>
</ul>
<ol start="3">
<li><strong>【优缺点】：</strong></li>
</ol>
<ul>
<li><strong>优点：</strong><ul>
<li>【增强了程序的可扩展性】因为我们很容易添加一个State</li>
<li>【增强了程序的封装性】每个状态的操作都被封装到了一个状态类中</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>【系统复杂度增加】类变多了</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>【特点】：</strong></li>
</ol>
<p>商品库存中心有个最基本的需求是减库存和补库存。<br>核心在于，我们的关注点不再是 Context 是该进行哪种操作，而是关注在这个 Context 会有哪些操作。<br>定义状态接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAction</span><span class="params">(Context context)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义减库存的状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeductState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAction</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;商品卖出，准备减库存&quot;</span>);</span><br><span class="line">        context.setState(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... 执行减库存的具体操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Deduct State&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义补库存状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RevertState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAction</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;给此商品补库存&quot;</span>);</span><br><span class="line">        context.setState(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... 执行加库存的具体操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Revert State&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面用到了 context.setState(this)，我们来看看怎么定义 Context 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line">  	<span class="keyword">private</span> String name;</span><br><span class="line">  	<span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(State state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看下客户端调用，大家就一清二楚了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 我们需要操作的是 iPhone X</span></span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="string">&quot;iPhone X&quot;</span>);</span><br><span class="line">  	</span><br><span class="line">    <span class="comment">// 看看怎么进行补库存操作</span></span><br><span class="line">  	<span class="type">State</span> <span class="variable">revertState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RevertState</span>();</span><br><span class="line">  	revertState.doAction(context);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 同样的，减库存操作也非常简单</span></span><br><span class="line">  	<span class="type">State</span> <span class="variable">deductState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeductState</span>();</span><br><span class="line">  	deductState.doAction(context);</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 如果需要我们可以获取当前的状态</span></span><br><span class="line">    <span class="comment">// context.getState().toString();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读者可能会发现，在上面这个例子中，如果我们不关心当前 context 处于什么状态，那么 Context 就可以不用维护 state 属性了，那样代码会简单很多。<br>不过，商品库存这个例子毕竟只是个例，我们还有很多实例是需要知道当前 context 处于什么状态的。</p>
<h2 id="4-6-访问者模式"><a href="#4-6-访问者模式" class="headerlink" title="4.6 访问者模式"></a>4.6 访问者模式</h2><blockquote>
<p>您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。</p>
</blockquote>
<ol>
<li><strong>【概念】：</strong>用于封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688808261187-6e31e012-8e23-4d85-9bc3-40c15ce8abc6.png#averageHue=%232f2a2d&clientId=uaef691d9-ff29-4&from=paste&height=362&id=uc4470929&originHeight=362&originWidth=1200&originalType=binary&ratio=1&rotation=0&showTitle=false&size=67959&status=done&style=none&taskId=ubfd48018-a562-491f-9f84-c38ff5eaf03&title=&width=1200" alt="image.png"></p>
<ul>
<li><strong>类图</strong></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/35382725/1688804819908-dc40c552-9b87-41bb-a01b-f26dbf6a40fe.webp#averageHue=%23f4f4f4&clientId=uaef691d9-ff29-4&from=drop&height=410&id=u3942a4fe&originHeight=462&originWidth=590&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18802&status=done&style=none&taskId=ue77514e6-2011-482c-94f1-f719a2e8087&title=&width=524" alt="v2-4ad3e0b3c15d542518aa433ed9a8c640_720w.webp"></p>
<ul>
<li>抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。</li>
<li>具体主题（Concrete Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</li>
<li>抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。</li>
<li>具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。</li>
</ul>
<ol start="2">
<li><strong>【使用场景】：</strong></li>
</ol>
<ul>
<li>JDK：Files 类提供了 walkFileTree() 方法，该方法可以很容易的对目录下的所有文件进行遍历，需要 Path、FileVisitor 两个参数。其中，Path 是要遍历文件的路径，FileVisitor 则可以看成一个文件访问器。</li>
<li>Spring：PropertySourcesPlaceholderConfigurer 允许我们用 Properties 文件中的属性来定义应用上下文。</li>
</ul>
<ol start="3">
<li><strong>【优缺点】：</strong></li>
</ol>
<ul>
<li><strong>优点：</strong><ul>
<li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li>
<li>目标与观察者之间建立了一套触发机制。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</li>
<li>【影响程序的效率】当观察者对象很多时，通知的发布会花费很多时间。</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>【特点】：</strong><blockquote>
<p>精髓：传入一个对象，在我们这里调用该对象的方法，而该方法会把this指针传进去</p>
</blockquote>
</li>
</ol>
<ul>
<li><p>传入访问者，遍历元素调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体元素类, 用于访问者访问</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ElementA</span> <span class="keyword">implements</span> <span class="title class_">IElement</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ElementA</span><span class="params">(String name)</span> &#123;  <span class="built_in">this</span>.name = name;  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 接受访问者访问自己  */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(IVisitor visitor)</span> &#123;</span><br><span class="line">        visitor.viewElementA(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;   <span class="keyword">return</span> name; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体访问者类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 具体访问者类, 用于访问元素 **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisitorA</span> <span class="keyword">implements</span>  <span class="title class_">IVisitor</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">viewElementA</span><span class="params">(ElementA elementA)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A访问者 访问 A元素: &quot;</span> + elementA.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">viewElementB</span><span class="params">(ElementB elementB)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A访问者 访问 B元素: &quot;</span> + elementB.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ElementStructure</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;IElement&gt; listElement = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addElement</span><span class="params">(IElement element)</span> &#123;</span><br><span class="line">        lstElement.add(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(IVisitor visitor)</span> &#123;<span class="comment">// 传入访问者</span></span><br><span class="line">        <span class="keyword">for</span> (IElement element : listElement) &#123;</span><br><span class="line">            element.accept(visitor);<span class="comment">//visitor.viewElementA(this);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-7-中介者模式"><a href="#4-7-中介者模式" class="headerlink" title="4.7 中介者模式"></a>4.7 中介者模式</h2><blockquote>
<p>机场调度系统</p>
</blockquote>
<ol>
<li><strong>【概念】：</strong>中介者模式是一种行为设计模式，能让你减少对象之间混乱无序的依赖关系。该模式会限制对象之间的直接交互，迫使它们通过一个中介者对象进行合作。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688808425055-fee581a2-6079-4f99-803f-469386d2ae84.png#averageHue=%23343433&clientId=uaef691d9-ff29-4&from=paste&height=339&id=u7c0505a6&originHeight=610&originWidth=924&originalType=binary&ratio=1&rotation=0&showTitle=false&size=125750&status=done&style=none&taskId=ue026bcfe-c297-4425-be0e-531878a031a&title=&width=514" alt="image.png"></p>
<ul>
<li><strong>类图：</strong></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/35382725/1688806511654-dee5a8f7-9805-4267-94d2-acd64139ab01.jpeg#averageHue=%23eeeeee&clientId=uaef691d9-ff29-4&from=drop&id=u643045a2&originHeight=375&originWidth=690&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43123&status=done&style=none&taskId=u709d76c2-faef-467c-a2ff-b60229a8aa2&title=" alt="v2-2757530b097845dd5d611dddfb5b5697_b.jpg"></p>
<ul>
<li>抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</li>
<li>具体中介者（Concrete Mediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。</li>
<li>抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</li>
<li>具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</li>
</ul>
<ol start="2">
<li><strong>【使用场景】：</strong></li>
</ol>
<ul>
<li>JDK源码中的Timer类：我们任意查看其中的几个schedule方法，所有的task都放入了Timer类中维护的task队列中。所以Timer就是充当了一个中介者的角色，而task队列内的任务就是具体同事对象。</li>
</ul>
<ol start="3">
<li><strong>【优缺点】：</strong></li>
</ol>
<ul>
<li><strong>优点：</strong><ul>
<li>【可扩展性】将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。</li>
<li>【符合迪米特法则】类之间各司其职。</li>
<li>【降低对象之间的耦合性】使得对象易于独立地被复用。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>中介者模式将原本多个对象直接的相互依赖变成了中介者和多个同事类的依赖关系。当同事类越多时，中介者就会越臃肿，变得复杂且难以维护。</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>【特点】：</strong></li>
</ol>
<ul>
<li><p>首先设计子系统</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子系统Light</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Light</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> Srtring position;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Light</span><span class="params">(String postion)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.position = position;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="built_in">this</span>.positioin + <span class="string">&quot;灯打开！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="built_in">this</span>.positioin + <span class="string">&quot;灯关闭！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="comment">//子系统Fan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fan</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="built_in">this</span>.positioin + <span class="string">&quot;风扇打开！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="built_in">this</span>.positioin + <span class="string">&quot;风扇关闭！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子系统AirCondition</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AirCondition</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="built_in">this</span>.positioin + <span class="string">&quot;空调打开！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="built_in">this</span>.positioin + <span class="string">&quot;空调关闭！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子系统TV</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TV</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="built_in">this</span>.positioin + <span class="string">&quot;电视打开！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="built_in">this</span>.positioin + <span class="string">&quot;电视关闭！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>外观类统一管理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//外观类GeneralSwitchFacade</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GeneralSwitchFacade</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> Light lights[] = <span class="keyword">new</span> <span class="title class_">Light</span>[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">private</span> Fan fan;</span><br><span class="line">	<span class="keyword">private</span> AirCondition ac;</span><br><span class="line">	<span class="keyword">private</span> TV tv;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">GeneralSwitchFacade</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		lights[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Light</span>(<span class="string">&quot;左前&quot;</span>);</span><br><span class="line">		lights[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Light</span>(<span class="string">&quot;右前&quot;</span>);</span><br><span class="line">		lights[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Light</span>(<span class="string">&quot;左后&quot;</span>);</span><br><span class="line">		lights[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Light</span>(<span class="string">&quot;右后&quot;</span>);</span><br><span class="line">		fan = <span class="keyword">new</span> <span class="title class_">Fan</span>();</span><br><span class="line">		ac = <span class="keyword">new</span> <span class="title class_">AirCondition</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">		lights[<span class="number">0</span>].on();</span><br><span class="line">		lights[<span class="number">1</span>].on();</span><br><span class="line">		lights[<span class="number">2</span>].on();</span><br><span class="line">		lights[<span class="number">3</span>].on();</span><br><span class="line">		fan.on();</span><br><span class="line">		ac.on();</span><br><span class="line">		tv.on();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">		lights[<span class="number">0</span>].off();</span><br><span class="line">		lights[<span class="number">1</span>].off();</span><br><span class="line">		lights[<span class="number">2</span>].off();</span><br><span class="line">		lights[<span class="number">3</span>].off();</span><br><span class="line">		fan.off();</span><br><span class="line">		ac.off();</span><br><span class="line">		tv.off();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">	&#123;</span><br><span class="line">         <span class="type">GeneralSwitchFacade</span> <span class="variable">gsf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeneralSwitchFacade</span>();</span><br><span class="line">         gsf.on();</span><br><span class="line">         gsf.off();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码非常简洁，子系统的各类交互逻辑都封装在外观类，客户只需要对接好封装的on方法和off方法。</p>
</li>
</ul>
<h2 id="4-8-命令模式"><a href="#4-8-命令模式" class="headerlink" title="4.8 命令模式"></a>4.8 命令模式</h2><blockquote>
<p>打开电视机、关闭电视机和切换频道。</p>
</blockquote>
<ol>
<li><strong>【概念】：</strong>它可将请求转换为一个包含与请求相关的所有信息的独立对象。该转换让你能根据不同的请求将方法参数化、延迟请求执行或将其放入<strong>队列</strong>中，且能实现可撤销操作。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688799198055-48d1238e-4faa-4288-a599-09e782bd68d9.png#averageHue=%23262525&clientId=uaef691d9-ff29-4&from=paste&height=426&id=u2afa3931&originHeight=426&originWidth=1137&originalType=binary&ratio=1&rotation=0&showTitle=false&size=105836&status=done&style=none&taskId=uf7341643-8977-4760-a9ab-6507aa2bcdf&title=&width=1137" alt="image.png"></p>
<ul>
<li><strong>类图</strong></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/gif/35382725/1688799459219-2ddc766f-ec2d-4540-aa45-43e7e05cb4d3.gif#averageHue=%23f3f3f3&clientId=uaef691d9-ff29-4&from=drop&height=485&id=V1pqf&originHeight=612&originWidth=550&originalType=binary&ratio=1&rotation=0&showTitle=false&size=30549&status=done&style=none&taskId=ue35d22eb-f0ae-440f-8023-2b22e104bd1&title=&width=436" alt="aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xODExMTYvMy0xUTExNjExMzM1RTQ0LmdpZg.gif"></p>
<ul>
<li>抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()。</li>
<li>具体命令角色（Concrete Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。</li>
<li>实现者&#x2F;接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。</li>
<li>调用者&#x2F;请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。</li>
</ul>
<ol start="2">
<li><strong>【使用场景】：</strong></li>
</ol>
<ul>
<li>现实语义中存在具备“命令”的操作，如：dos命令，shell命令。</li>
<li>请求调用者和请求的接收者需要解耦，使得调用者和接收者不直接互相调用。</li>
<li>需要抽象出等待执行的行为，比如撤销和和恢复等操作。</li>
<li>需要支持命令宏(即命令组合)操作。</li>
</ul>
<ol start="3">
<li><strong>【优缺点】：</strong></li>
</ol>
<ul>
<li><strong>优点：</strong><ul>
<li>【降低系统的耦合度】命令模式能将调用操作的对象与实现该操作的对象解耦；</li>
<li>【满足开闭原则】增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类；</li>
<li>【可以实现宏命令】命令模式与组合模式结合，将多个命令装配成一个组合命令，即宏命令；</li>
<li>【方便实现 Undo 和 Redo 操作】命令模式与备忘录模式结合，实现命令的撤销与恢复。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>【可能产生大量具体命令类】因为计对每一个具体操作都需要设计一个具体命令类，这将增加系统的复杂性。</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>【特点】：</strong></li>
</ol>
<ul>
<li><p>调用者Invoker</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Invoker</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Invoker</span><span class="params">(Command command)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.command=command;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommand</span><span class="params">(Command command)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.command=command;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用者执行命令command...&quot;</span>);</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>抽象命令Command</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体命令ConcreteCommand</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line">    ConcreteCommand()</span><br><span class="line">    &#123;</span><br><span class="line">        receiver=<span class="keyword">new</span> <span class="title class_">Receiver</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        receiver.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接收者Receiver</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Receiver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收者的action()方法被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-9-备忘录模式"><a href="#4-9-备忘录模式" class="headerlink" title="4.9 备忘录模式"></a>4.9 <strong>备忘录模式</strong></h2><blockquote>
<p>打游戏时的存档；数据库的事务管理。</p>
</blockquote>
<ol>
<li><strong>【概念】：</strong>在不破坏封装的前提下，捕获一个对象的内部状态，并在对象之外保存这个状态，这样我们就可以在需要的时候将该对象恢复到原先保存的状态了，备忘录模式属于行为型模式。【回滚机制】</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688809308802-1622dcf1-b155-4601-afad-28744b85ee7e.png#averageHue=%234f4e50&clientId=uaef691d9-ff29-4&from=paste&height=216&id=uade8e3e6&originHeight=268&originWidth=743&originalType=binary&ratio=1&rotation=0&showTitle=false&size=52222&status=done&style=none&taskId=uca795727-2bdd-4d06-ab6b-f2f277813cc&title=&width=599" alt="image.png"></p>
<ul>
<li><strong>类图</strong></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688803549180-2ea1653b-825c-42c4-b3cc-ba53e983d801.png#averageHue=%23706e70&clientId=uaef691d9-ff29-4&from=paste&height=517&id=h3j3Y&originHeight=517&originWidth=813&originalType=binary&ratio=1&rotation=0&showTitle=false&size=163387&status=done&style=none&taskId=u9bdea211-37d8-4ded-bdd3-1911213d8af&title=&width=813" alt="image.png"></p>
<ul>
<li>发起人角色(Originator)：负责创建一个备忘录，记录自身需要保存的状态，而且需要具备状态的回滚功能。</li>
<li>备忘录角色(Memento)：用于存储Originator角色的内部状态，且可以防止Originator以外的对象进行访问。</li>
<li>备忘录管理员角色(Caretaker)：负责存储，管理备忘录功能。且其本身应该无法对备忘录的内容进行访问。</li>
</ul>
<ol start="2">
<li><strong>【使用场景】：</strong></li>
</ol>
<ul>
<li>Spring中的spring-webflow包的类StateManageableMessageContext</li>
</ul>
<ol start="3">
<li><strong>【优缺点】：</strong></li>
</ol>
<ul>
<li><strong>优点：</strong><ul>
<li>简化了发起人的的职责，将状态的存储和获取进行了隔离，而且客户端无需关心状态的保存细节。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>消耗资源，如果每个快照的内容都非常大，会消耗大量内存。</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>【特点】：</strong></li>
</ol>
<p>下面我们就以常见的富文本编辑器来编辑文章的功能为例来写一个简单的示例来看看备忘录模式是如何实现的。</p>
<ul>
<li><p>首先建立一个类来保存最新文章信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwx.design.pattern.memento;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArticleText</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArticleText</span><span class="params">(String title, String content, Date createTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">        <span class="built_in">this</span>.createTime = createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTitle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTitle</span><span class="params">(String title)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getCreateTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCreateTime</span><span class="params">(Date createTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.createTime = createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArticleMemento <span class="title function_">saveToMemento</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ArticleMemento</span> <span class="variable">articleMemento</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArticleMemento</span>(<span class="built_in">this</span>.title,<span class="built_in">this</span>.content,<span class="built_in">this</span>.createTime);</span><br><span class="line">        <span class="keyword">return</span> articleMemento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getArticleFromMemento</span><span class="params">(ArticleMemento articleMemento)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.title = articleMemento.getTitle();</span><br><span class="line">        <span class="built_in">this</span>.content = articleMemento.getContent();</span><br><span class="line">        <span class="built_in">this</span>.createTime = articleMemento.getCreateTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：这里面除了getter&#x2F;setter方法之外还有一个方法用来备份，一个方法用来还原。</p>
</li>
<li><p>建立一个类用来保存历史数据，这个类的信息必须要和原始类一样，否则无法完全备份：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwx.design.pattern.memento;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArticleMemento</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArticleMemento</span><span class="params">(String title, String content, Date createTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">        <span class="built_in">this</span>.createTime = createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTitle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTitle</span><span class="params">(String title)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getCreateTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCreateTime</span><span class="params">(Date createTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.createTime = createTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后还需要一个类来管理历史快照信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwx.design.pattern.memento;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArticleCaretaker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ArticleMemento&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArticleMemento <span class="title function_">getArticle</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setArticle</span><span class="params">(ArticleMemento articleMemento)</span>&#123;</span><br><span class="line">        list.add(articleMemento);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后来一个测试类测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwx.design.pattern.memento;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMemento</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArticleCaretaker</span> <span class="variable">articleCaretaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArticleCaretaker</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">ArticleText</span> <span class="variable">articleText</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArticleText</span>(<span class="string">&quot;标题1&quot;</span>,<span class="string">&quot;内容1&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="type">ArticleMemento</span> <span class="variable">articleMemento</span> <span class="operator">=</span> articleText.saveToMemento();</span><br><span class="line">        articleCaretaker.setArticle(articleMemento);<span class="comment">//备忘1次</span></span><br><span class="line"></span><br><span class="line">        articleText = <span class="keyword">new</span> <span class="title class_">ArticleText</span>(<span class="string">&quot;标题2&quot;</span>,<span class="string">&quot;内容2&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;修改后的标题为【%s】，内容为【%s】&quot;</span>,articleText.getTitle(),articleText.getContent()));</span><br><span class="line"></span><br><span class="line">        articleText.getArticleFromMemento(articleCaretaker.getArticle(<span class="number">0</span>));</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;还原后的标题为【%s】，内容为【%s】&quot;</span>,articleText.getTitle(),articleText.getContent()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结果：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修改后的标题为【标题<span class="number">2</span>】，内容为【内容<span class="number">2</span>】</span><br><span class="line">还原后的标题为【标题<span class="number">1</span>】，内容为【内容<span class="number">1</span>】</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-10-迭代器模式【-】"><a href="#4-10-迭代器模式【-】" class="headerlink" title="4.10 迭代器模式【*】"></a>4.10 迭代器模式【*】</h2><blockquote>
<p>Java中的iterator</p>
</blockquote>
<ol>
<li><strong>【概念】：</strong>迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。</li>
</ol>
<p>提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。</p>
<ul>
<li><strong>类图</strong></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688802998917-fbd3e0e8-788d-4a16-9f03-64dd106bef1d.png#averageHue=%23717171&clientId=uaef691d9-ff29-4&from=paste&height=592&id=EzZDp&originHeight=592&originWidth=756&originalType=binary&ratio=1&rotation=0&showTitle=false&size=104856&status=done&style=none&taskId=u82b40184-15c1-4781-b007-5c7afe19f15&title=&width=756" alt="image.png"></p>
<ul>
<li>Iterator（抽象迭代器）：它定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法，例如：用于获取第一个元素的first()方法，用于访问下一个元素的next()方法，用于判断是否还有下一个元素的hasNext()方法，用于获取当前元素的currentItem()方法等，在具体迭代器中将实现这些方法。</li>
<li>ConcreteIterator（具体迭代器）：它实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置，在具体实现时，游标通常是一个表示位置的非负整数。</li>
<li>IterableCollection（抽象聚合类）：它用于存储和管理元素对象，声明一个createIterator()方法用于创建一个迭代器对象，充当抽象迭代器工厂角色。</li>
<li>ConcreteCollection（具体聚合类）：它实现了在抽象聚合类中声明的createIterator()方法，该方法返回一个与该具体聚合类对应的具体迭代器ConcreteIterator实例。</li>
</ul>
<ol start="2">
<li><strong>【使用场景】：</strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36970993/article/details/112156234">迭代器模式在JDK以及MyBatis源码中的应用</a></li>
</ol>
<ul>
<li><p>Java集合中的迭代器模式：<strong>new ArrayList&lt;&gt;().iterator();</strong></p>
<ul>
<li>最重要的两个方法是hasNext()和next()<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">	E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Mybatis中的迭代器模式</p>
</li>
</ul>
<ol start="3">
<li><strong>【优缺点】：</strong></li>
</ol>
<ul>
<li><strong>优点：</strong><ul>
<li>它支持以不同的方式遍历一个聚合对象。</li>
<li>迭代器简化了聚合类。</li>
<li>在同一个聚合上可以有多个遍历。</li>
<li>在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>增加了类的个数，这在一定程度上增加了系统的复杂性。</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>【特点】：</strong></li>
</ol>
<p>我们来实现一个学生报数的示例</p>
<ul>
<li><p>定义一个学生类，有一个报数方法 count()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, Integer number)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">count</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;我是 %d 号 %s&quot;</span>, <span class="built_in">this</span>.number, <span class="built_in">this</span>.name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义班级接口和班级类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentAggregate</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addStudent</span><span class="params">(Student student)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeStudent</span><span class="params">(Student student)</span>;</span><br><span class="line"></span><br><span class="line">    StudentIterator <span class="title function_">getStudentIterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentAggregateImpl</span> <span class="keyword">implements</span> <span class="title class_">StudentAggregate</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; list;  <span class="comment">// 学生列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StudentAggregateImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addStudent</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list.add(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeStudent</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list.remove(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> StudentIterator <span class="title function_">getStudentIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentIteratorImpl</span>(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义迭代器接口并实现迭代器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentIterator</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hashNext</span><span class="params">()</span>;</span><br><span class="line">    Student <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentIteratorImpl</span> <span class="keyword">implements</span> <span class="title class_">StudentIterator</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; list;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Student currentStudent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StudentIteratorImpl</span><span class="params">(List&lt;Student&gt; list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hashNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> position &lt; list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        currentStudent = list.get(position);</span><br><span class="line">        position ++;</span><br><span class="line">        <span class="keyword">return</span> currentStudent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试，进行报数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StudentAggregate</span> <span class="variable">classOne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentAggregateImpl</span>();</span><br><span class="line">        classOne.addStudent(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">1</span>));</span><br><span class="line">        classOne.addStudent(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">2</span>));</span><br><span class="line">        classOne.addStudent(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">3</span>));</span><br><span class="line">        classOne.addStudent(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;赵六&quot;</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历，报数</span></span><br><span class="line">        <span class="type">StudentIterator</span> <span class="variable">iterator</span> <span class="operator">=</span> classOne.getStudentIterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hashNext())&#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            student.count();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我是 <span class="number">1</span> 号 张三</span><br><span class="line">我是 <span class="number">2</span> 号 李四</span><br><span class="line">我是 <span class="number">3</span> 号 王五</span><br><span class="line">我是 <span class="number">4</span> 号 赵六</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-11-解释器模式"><a href="#4-11-解释器模式" class="headerlink" title="4.11 解释器模式"></a>4.11 解释器模式</h2><blockquote>
<p>编译器、运算表达式计算</p>
</blockquote>
<ol>
<li><strong>【概念】：</strong>提供了评估语言的语法或表达式的方式，这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。</li>
</ol>
<ul>
<li><strong>定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的”语言”是指使用规定格式和语法的代码。解释器模式是一种类行为型模式。</strong></li>
<li><strong>解释过程</strong></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688805322718-de60b843-ca56-4045-a031-d087d4ac4058.png#averageHue=%23e7ecec&clientId=uaef691d9-ff29-4&from=paste&height=175&id=MZdBi&originHeight=175&originWidth=1184&originalType=binary&ratio=1&rotation=0&showTitle=false&size=128339&status=done&style=none&taskId=u60df0928-679e-46ae-83ef-d43334453ac&title=&width=1184" alt="image.png"></p>
<ul>
<li><strong>类图</strong></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1688805219233-88da67ab-8478-4b5c-9bda-b8f992e53bab.png#averageHue=%23353437&clientId=uaef691d9-ff29-4&from=paste&height=695&id=XGWIx&originHeight=695&originWidth=1356&originalType=binary&ratio=1&rotation=0&showTitle=false&size=188959&status=done&style=none&taskId=u75858de3-cd07-46ee-8eca-ee760af22bf&title=&width=1356" alt="image.png"></p>
<ul>
<li>上下文环境(Context)：包含解释器之外的全局信息。一般用来存放文法中各个终结符所对应的具体值；</li>
<li>抽象表达式(AbstractExpression)：一般会定义一个解释方法，具体如何解析会交由子类进行实现(如示例中的IExpression)；</li>
<li>终结符表达式(Terminal Expression)：实现文法中与终结符有关的解释操作(如示例中的AddExpression,SubExpression)；</li>
<li>非终符结表达式(NonTerminal Expression)：实现文法中与非终结符有关的解释操作(如示例中的NumberExpression)；</li>
</ul>
<ol start="2">
<li><strong>【使用场景】：</strong></li>
</ol>
<ul>
<li>JDK中的正则表达式：Pattern类；</li>
<li>Spring里面的ExpressionParse接口；</li>
<li>作为解释器的模板，帮助我们生成解释器（类似：加减运算解释器）</li>
</ul>
<ol start="3">
<li><strong>【优缺点】：</strong></li>
</ol>
<ul>
<li><strong>优点：</strong><ul>
<li>可扩展性比较好，灵活；</li>
<li>增加了新的解释表达式的方式；</li>
<li>易于实现简单文法。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>当文法规则比较复杂时，会引起类膨胀，比较难维护；</li>
<li>当文法规则比较复杂时，如果出错了，调试比较困难；</li>
<li>执行效率比较低下。因为当表达式比较复杂，结果层层依赖的话会采用递归方式进行解析；</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>【特点】：</strong></li>
</ol>
<p>下面我们就以简单的加减法表达式类简单写一个示例：</p>
<ul>
<li><p>首先建立一个顶层的表达式接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwx.design.pattern.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IExpression</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">interpret</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义一个抽象的非终结表达式(比如加号和减号这种就属于非终结表达式)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwx.design.pattern.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非终结表达式-抽象表达式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractNonTerminalExpression</span> <span class="keyword">implements</span> <span class="title class_">IExpression</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> IExpression leftExpression;</span><br><span class="line">    <span class="keyword">protected</span> IExpression rightExpression;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractNonTerminalExpression</span><span class="params">(IExpression leftExpression, IExpression rightExpression)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.leftExpression = leftExpression;</span><br><span class="line">        <span class="built_in">this</span>.rightExpression = rightExpression;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>因为本次示例中只列举加法和减法，所以我们还需要一个加法类和一个减法类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwx.design.pattern.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非终结表达式-具体表达式-加法表达式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddExpression</span> <span class="keyword">extends</span> <span class="title class_">AbstractNonTerminalExpression</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AddExpression</span><span class="params">(IExpression leftExpression, IExpression rightExpression)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(leftExpression, rightExpression);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.leftExpression.interpret() + <span class="built_in">this</span>.rightExpression.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwx.design.pattern.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非终结表达式-具体表达式-减法表达式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubExpression</span> <span class="keyword">extends</span> <span class="title class_">AbstractNonTerminalExpression</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubExpression</span><span class="params">(IExpression leftExpression, IExpression rightExpression)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(leftExpression, rightExpression);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.leftExpression.interpret() - <span class="built_in">this</span>.rightExpression.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再建立一个终结表达式(如加减法运算中的数值)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwx.design.pattern.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 终结表达式-数值表达式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberExpression</span> <span class="keyword">implements</span> <span class="title class_">IExpression</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumberExpression</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = Integer.valueOf(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后我们还需要一个上下文信息来存储我们的运算结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwx.design.pattern.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExpressionContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer currValue;<span class="comment">//记录当前运算结果，空表示暂未运算</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;IExpression&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExpressionContext</span><span class="params">(String expression)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.parse(expression);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(String expression)</span> &#123;</span><br><span class="line">        String[] elementArr = expression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;elementArr.length;i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> elementArr[i];</span><br><span class="line">            <span class="keyword">if</span> (element.equals(<span class="string">&quot;+&quot;</span>))&#123;</span><br><span class="line">                <span class="type">IExpression</span> <span class="variable">leftExpression</span> <span class="operator">=</span> stack.pop();<span class="comment">//栈内元素出栈</span></span><br><span class="line">                <span class="type">IExpression</span> <span class="variable">rightExpression</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumberExpression</span>(elementArr[++i]);<span class="comment">//取出+号后的下一个元素</span></span><br><span class="line">                <span class="type">IExpression</span> <span class="variable">addExpression</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddExpression</span>(leftExpression,rightExpression);</span><br><span class="line">                stack.push(<span class="keyword">new</span> <span class="title class_">NumberExpression</span>(addExpression.interpret() + <span class="string">&quot;&quot;</span>));<span class="comment">//将计算结果入栈</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (element.equals(<span class="string">&quot;-&quot;</span>))&#123;</span><br><span class="line">                <span class="type">IExpression</span> <span class="variable">leftExpression</span> <span class="operator">=</span> stack.pop();<span class="comment">//栈内元素出栈</span></span><br><span class="line">                <span class="type">IExpression</span> <span class="variable">rightExpression</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumberExpression</span>(elementArr[++i]);<span class="comment">//取出-号后的下一个元素</span></span><br><span class="line">                <span class="type">IExpression</span> <span class="variable">subExpression</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubExpression</span>(leftExpression,rightExpression);</span><br><span class="line">                stack.push(<span class="keyword">new</span> <span class="title class_">NumberExpression</span>(subExpression.interpret() + <span class="string">&quot;&quot;</span>));<span class="comment">//将计算结果入栈</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(<span class="keyword">new</span> <span class="title class_">NumberExpression</span>(element));<span class="comment">//如果是数字则直接入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calcuate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.pop().interpret();<span class="comment">//经过前面解析，到这里stack内只会剩下唯一一个数字，即运算结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后新建一个测试类来测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwx.design.pattern.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInterpreter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExpressionContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExpressionContext</span>(<span class="string">&quot;666 + 888 - 777&quot;</span>);</span><br><span class="line">        System.out.println(context.calcuate());</span><br><span class="line">        context = <span class="keyword">new</span> <span class="title class_">ExpressionContext</span>(<span class="string">&quot;123 - 456 + 11&quot;</span>);</span><br><span class="line">        System.out.println(context.calcuate());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">777</span></span><br><span class="line">-<span class="number">322</span></span><br></pre></td></tr></table></figure></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">cocochimp</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/01/18/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">http://example.com/2024/01/18/23种设计模式/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">cocochimpBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></div><div class="post_share"><div class="social-share" data-image="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/01/18/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="JUC并发编程"><img class="cover" src="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/juc.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JUC并发编程</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">cocochimp</div><div class="author-info__description">to be a cool man!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/cocochimp" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://gitee.com/cocochimp" target="_blank" title="Gitee"><i class="fab fa-github-alt"></i></a><a class="social-icon" href="https://blog.csdn.net/m0_51634403" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="mailto:2427886409@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E3%80%81OOP%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-number">1.</span> <span class="toc-text">1、OOP七大原则</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">2、创建型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E3%80%90-%E3%80%91"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 单例模式【**】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-x"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 简单工厂模式(x)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E3%80%90-%E3%80%91"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 工厂模式【*】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 抽象工厂模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 建造者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E3%80%90-%E3%80%91"><span class="toc-number">2.6.</span> <span class="toc-text">2.6 原型模式【*】</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E3%80%81%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">3、结构型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E3%80%90-%E3%80%91"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 代理模式【*】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E3%80%90-%E3%80%91"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 适配器模式【*】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 桥接模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E3%80%90-%E3%80%91"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 装饰器模式【*】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E9%97%A8%E9%9D%A2-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 门面&#x2F;外观模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.6.</span> <span class="toc-text">3.6 组合模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.7.</span> <span class="toc-text">3.7 享元模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E3%80%81%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">4、行为型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E3%80%90-%E3%80%91"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 策略模式【*】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 观察者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 责任链模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E3%80%90-%E3%80%91"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 模板方法模式【*】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 状态模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.6.</span> <span class="toc-text">4.6 访问者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.7.</span> <span class="toc-text">4.7 中介者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.8.</span> <span class="toc-text">4.8 命令模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.9.</span> <span class="toc-text">4.9 备忘录模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-10-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E3%80%90-%E3%80%91"><span class="toc-number">4.10.</span> <span class="toc-text">4.10 迭代器模式【*】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-11-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.11.</span> <span class="toc-text">4.11 解释器模式</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/18/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="23种设计模式"><img src="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="23种设计模式"/></a><div class="content"><a class="title" href="/2024/01/18/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="23种设计模式">23种设计模式</a><time datetime="2024-01-18T03:00:54.577Z" title="发表于 2024-01-18 11:00:54">2024-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/18/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="JUC并发编程"><img src="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/juc.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC并发编程"/></a><div class="content"><a class="title" href="/2024/01/18/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="JUC并发编程">JUC并发编程</a><time datetime="2024-01-18T03:00:43.042Z" title="发表于 2024-01-18 11:00:43">2024-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/18/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="JVM虚拟机"><img src="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/JVM.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM虚拟机"/></a><div class="content"><a class="title" href="/2024/01/18/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="JVM虚拟机">JVM虚拟机</a><time datetime="2024-01-18T03:00:28.866Z" title="发表于 2024-01-18 11:00:28">2024-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="Java多线程"><img src="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java多线程"/></a><div class="content"><a class="title" href="/2024/01/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="Java多线程">Java多线程</a><time datetime="2024-01-18T03:00:10.504Z" title="发表于 2024-01-18 11:00:10">2024-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/18/Java%E9%9B%86%E5%90%88/" title="Java集合"><img src="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/Java%E9%9B%86%E5%90%88.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java集合"/></a><div class="content"><a class="title" href="/2024/01/18/Java%E9%9B%86%E5%90%88/" title="Java集合">Java集合</a><time datetime="2024-01-18T02:59:47.232Z" title="发表于 2024-01-18 10:59:47">2024-01-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By cocochimp</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div></body></html>