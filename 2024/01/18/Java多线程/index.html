<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java多线程 | cocochimpBlog</title><meta name="author" content="cocochimp"><meta name="copyright" content="cocochimp"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="AQSAQS（AbstractQueuedSynchronizer）是Java并发包中的一个重要类，用于实现同步器和锁的基础组件。下面是AQS底层原理的简要解释：  AQS的核心思想是一个FIFO队列，用于管理线程的获取和释放资源的顺序。 AQS通过内部的一个volatile状态变量来表示资源的占用情况，以及线程等待队列的状态。 AQS提供了两种操作方式：独占模式（Exclusive）和共享模式（">
<meta property="og:type" content="article">
<meta property="og:title" content="Java多线程">
<meta property="og:url" content="http://example.com/2024/01/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="cocochimpBlog">
<meta property="og:description" content="AQSAQS（AbstractQueuedSynchronizer）是Java并发包中的一个重要类，用于实现同步器和锁的基础组件。下面是AQS底层原理的简要解释：  AQS的核心思想是一个FIFO队列，用于管理线程的获取和释放资源的顺序。 AQS通过内部的一个volatile状态变量来表示资源的占用情况，以及线程等待队列的状态。 AQS提供了两种操作方式：独占模式（Exclusive）和共享模式（">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/%E5%A4%9A%E7%BA%BF%E7%A8%8B.png">
<meta property="article:published_time" content="2024-01-18T03:00:10.504Z">
<meta property="article:modified_time" content="2024-01-18T03:27:39.364Z">
<meta property="article:author" content="cocochimp">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/%E5%A4%9A%E7%BA%BF%E7%A8%8B.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/01/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java多线程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-18 11:27:39'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="cocochimpBlog" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/picture/"><i class="fa-fw iconfont icon-tupian"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-touxiang"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/%E5%A4%9A%E7%BA%BF%E7%A8%8B.png')"><nav id="nav"><span id="blog-info"><a href="/" title="cocochimpBlog"><span class="site-name">cocochimpBlog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/picture/"><i class="fa-fw iconfont icon-tupian"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-touxiang"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java多线程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-18T03:00:10.504Z" title="发表于 2024-01-18 11:00:10">2024-01-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-18T03:27:39.364Z" title="更新于 2024-01-18 11:27:39">2024-01-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java多线程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AQS（AbstractQueuedSynchronizer）是Java并发包中的一个重要类，用于实现同步器和锁的基础组件。下面是AQS底层原理的简要解释：</p>
<ol>
<li>AQS的核心思想是一个FIFO队列，用于管理线程的获取和释放资源的顺序。</li>
<li>AQS通过内部的一个volatile状态变量来表示资源的占用情况，以及线程等待队列的状态。</li>
<li>AQS提供了两种操作方式：独占模式（Exclusive）和共享模式（Shared）。独占模式适用于只有一个线程能够访问资源的场景，而共享模式适用于多个线程可以同时访问资源的场景。</li>
<li>当线程尝试获取资源时，会先通过CAS操作修改AQS的状态变量，如果成功获取资源，则可以继续执行；否则，线程会被加入等待队列，并进入阻塞状态。</li>
<li>当资源被释放时，需要通知等待队列中的第一个线程可以继续执行。这个过程可以通过CAS操作来保证只有一个线程获取到通知，并唤醒。</li>
<li>AQS的子类可以通过继承AQS并重写指定的方法来实现自定义的同步器，例如ReentrantLock和Semaphore等。</li>
</ol>
<p>总的来说，AQS通过使用内部状态变量、等待队列和CAS操作，实现了线程的排队等待和唤醒机制，进而提供了可靠的同步和互斥操作。这一机制为Java中各种锁的实现提供了重要的基础支持。</p>
<h1 id="1、并发-多线程概念-⭐"><a href="#1、并发-多线程概念-⭐" class="headerlink" title="1、并发&#x2F;多线程概念 ⭐"></a>1、并发&#x2F;多线程概念 ⭐</h1><h2 id="1-1-常见概念"><a href="#1-1-常见概念" class="headerlink" title="1.1 常见概念"></a>1.1 常见概念</h2><ol>
<li><strong>线程与进程：</strong><br>:::tips</li>
</ol>
<ul>
<li><p><strong>进程：</strong>是正在运行的程序<br>是系统进行<strong>资源分配</strong>和<strong>调用</strong>的<strong>独立单位</strong><br>每一个进程都有它自己的<strong>内存空间</strong>和<strong>系统资源</strong> </p>
</li>
<li><p><strong>线程：</strong>是进程中的单个顺序控制流，是一条执行路径（Java默认 Main 和 GC 进程）<br>单线程：一个进程如果只有一条执行路径，则称为单线程程序<br>多线程：一个进程如果有多条执行路径，则称为多线程程序<br>:::<br>2.<strong>多线程&#x2F;并发区别：</strong><br>:::tips</p>
</li>
<li><p><strong>多线程：指在一个程序中同时执行多个线程</strong>，每个线程都是独立的执行路径，可以并发执行。多线程的目的是为了充分利用多核CPU或多个处理器的资源，提高程序的执行效率和并行处理能力。</p>
</li>
<li><p><strong>并发：指多个任务在同一个时间段内交替执行</strong>，通过时间片轮转或者其他调度算法来实现任务间的切换。并发的主要目的是尽量减少任务等待时间，提高系统整体的效率和响应能力。</p>
</li>
</ul>
<p>因此，<strong>多线程是实现并发的一种方式，但并发不仅限于多线程</strong>。在Java中，我们可以通过多线程编写并发程序，但也可以通过其他机制（比如使用非阻塞IO、异步编程或并发集合等）来实现并发操作。<br>:::</p>
<h2 id="1-2-并发三要素-可见-原子-有序"><a href="#1-2-并发三要素-可见-原子-有序" class="headerlink" title="1.2 并发三要素(可见&#x2F;原子&#x2F;有序)"></a>1.2 并发三要素(可见&#x2F;原子&#x2F;有序)</h2><p><strong>为什么需要多线程？</strong>众所周知，CPU、内存、I&#x2F;O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为:</p>
<ul>
<li>CPU 增加了缓存，以均衡与内存的速度差异；**&#x2F;&#x2F; 可见性问题**</li>
<li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I&#x2F;O 设备的速度差异；**&#x2F;&#x2F; 原子性问题**</li>
<li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。**&#x2F;&#x2F; 有序性问题**<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadSize</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="type">ThreadUnsafeExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadUnsafeExample</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadSize);</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.println(example.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">997</span> <span class="comment">// 结果总是小于1000</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>上述代码输出为什么不是1000? 并发出现问题的根源是什么?<br>:::tips<br><strong>可见性</strong>【CPU缓存引起】：一个线程对共享变量的修改，另外一个线程能够立刻看到<br><strong>原子性</strong>【分时复用引起】：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行<br><strong>有序性</strong>【重排序引起】：即程序执行的顺序按照代码的先后顺序执行<br>:::</p>
<ol>
<li><p><strong>可见性：</strong>一个线程对共享变量的修改，另外一个线程能够立刻看到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//线程1执行的代码</span></span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">j = i;<span class="comment">//线程2执行的代码</span></span><br></pre></td></tr></table></figure>
<p>:::tips<br>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i &#x3D;10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。<br>此时线程2执行 j &#x3D; i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10。<br>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。<img src="https://cdn.nlark.com/yuque/0/2023/webp/35382725/1697201091520-a1f3af55-b86d-4161-845c-dbf1b91099db.webp#averageHue=%23ecf1e4&clientId=u17b23df9-2b95-4&from=drop&height=289&id=u702ce5e8&originHeight=382&originWidth=443&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=8666&status=done&style=none&taskId=u25ba13b7-b427-440d-b3e5-bf707260619&title=&width=335" alt="v2-a1a75c9f7264cf78d0927663371ca9d2_720w.webp"><br>:::<br><strong>解决方案（JMM）：</strong>Java内存模型只保证了<strong>基本读取</strong>和<strong>赋值</strong>是原子性操作，如果要实现更大范围操作的原子性，可以通过<strong>synchronized和Lock</strong>来实现。由于synchronized和Lock能够<strong>保证任一时刻只有一个线程执行该代码块</strong>，那么自然就不存在原子性问题了，从而保证了原子性。</p>
</li>
<li><p><strong>原子性：</strong>即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">i += <span class="number">1</span>;<span class="comment">// 线程1执行</span></span><br><span class="line">i += <span class="number">1</span>;<span class="comment">// 线程2执行</span></span><br></pre></td></tr></table></figure>
<p>:::tips<br>i +&#x3D; 1需要三条 CPU 指令</p>
</li>
<li><p>将变量 i 从内存读取到 CPU寄存器；</p>
</li>
<li><p>在CPU寄存器中执行 i + 1 操作；</p>
</li>
<li><p>将最后的结果i写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。</p>
</li>
</ol>
<p>由于CPU分时复用（线程切换）的存在，线程1执行了第一条指令后，就切换到线程2执行，假如线程2执行了这三条指令后，再切换会线程1执行后续两条指令，将造成最后写到内存中的i值是2而不是3。<br>:::<br><strong>解决方案（JMM）：synchronized和Lock</strong>能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<ol start="3">
<li><strong>有序性：</strong>即程序执行的顺序按照代码的先后顺序执行<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;              </span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">i = <span class="number">1</span>;                <span class="comment">//语句1  </span></span><br><span class="line">flag = <span class="literal">true</span>;          <span class="comment">//语句2</span></span><br></pre></td></tr></table></figure>
<img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697025193996-8df5aa17-2994-4f68-b74b-a9ac06703ccb.png#averageHue=%23efeeed&clientId=u4831536b-25c6-4&from=drop&id=DoraY&originHeight=76&originWidth=529&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=1676&status=done&style=none&taskId=u23f4b427-5265-4fab-b8bd-7028243eb09&title=" alt="java-jmm-3.png"><br>:::tips<br>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</li>
</ol>
<ul>
<li><strong>编译器优化</strong>的重排序<strong>。</strong>编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li><strong>指令级并行</strong>的重排序<strong>。</strong>现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li><strong>内存系统</strong>的重排序<strong>。</strong>由于处理器使用缓存和读 &#x2F; 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。<br>:::<br><strong>解决方案（JMM）：synchronized和Lock</strong>保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。当然JMM是通过Happens-Before 规则来保证有序性的。</li>
</ul>
<h2 id="1-3-如何解决并发：JMM"><a href="#1-3-如何解决并发：JMM" class="headerlink" title="1.3 如何解决并发：JMM"></a>1.3 如何解决并发：JMM</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/29881777">Java内存模型（JMM）总结</a></p>
<ul>
<li>JMM（Java Memory Model）：Java内存模型<br>:::tips<br>JMM 规范了 JVM 如何提供按需禁用缓存和编译优化的方法，方法如下：</li>
</ul>
<ol>
<li><p><strong>synchronized、volatile 和 final 三个关键字</strong></p>
</li>
<li><p>Happens-Before 规则（×）<br>:::</p>
</li>
<li><p><strong>synchronized（看互斥同步模块）</strong></p>
</li>
<li><p><strong>volatile：</strong><br>:::tips<br><strong>可见性：</strong>引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。volatile关键字能有效的解决这个问题<br><strong>原子性：</strong>volatile是无法保证原子性的，只能保证单次的读&#x2F;写操作具有原子性。i++其实是一个复合操作，因此不能保证i++的原子性<br><strong>有序性：单例模式！</strong>采用双重检查加锁(DCL)的方式来实现<br>:::</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有序性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton; <span class="comment">//【核心】</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数私有，禁止外部实例化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>final：修饰类&#x2F;方法&#x2F;参数&#x2F;变量</strong><br>:::tips</p>
</li>
<li><p><strong>修饰类：</strong>当某个类的整体定义为final时，就表明这个类是不能有子类的。</p>
<ul>
<li>注意：final类中的所有方法都隐式为final，在final类中给任何方法添加final关键字是没有任何意义的</li>
</ul>
</li>
<li><p><strong>方法：</strong>private 方法是隐式的final（类中所有private方法都隐式地指定为final的，由于无法取用private方法，所以private不用加final）</p>
<ul>
<li>注意：final方法是可以被重载的</li>
</ul>
</li>
<li><p><strong>参数：</strong>Java允许在参数列表中以声明的方式将参数指明为final，这意味这你无法在方法中更改参数引用所指向的对象。这个特性主要用来向匿名内部类传递数据。</p>
</li>
<li><p><strong>变量：</strong>太简单不阐述<br>:::</p>
</li>
</ol>
<h2 id="1-4-线程状态转换"><a href="#1-4-线程状态转换" class="headerlink" title="1.4 线程状态转换"></a>1.4 线程状态转换</h2><p><strong>线程的生命周期：</strong>线程一共有五种状态，线程在各种状态之间转换。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697183013446-7b8ca940-f958-46f9-b34c-0ce25997c9ee.png#averageHue=%23fafafa&clientId=uc4f565ad-210d-4&id=oH8sI&originHeight=216&originWidth=762&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3542092e-d1aa-45b7-a6e0-97a5b825d58&title="><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697015337666-fd79cd42-5d38-40ca-b824-5f35b2df2b2e.png#averageHue=%23fdfcfc&clientId=u4831536b-25c6-4&from=drop&id=u69308b16&originHeight=492&originWidth=893&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=11971&status=done&style=none&taskId=u502595d0-3cc3-4371-9a89-51c96d0643d&title=" alt="ace830df-9919-48ca-91b5-60b193f593d2.png"></p>
<ol>
<li><p><strong>新建（new）：</strong>创建后未启动</p>
</li>
<li><p><strong>可运行（Runnable）：</strong>可能正在运行（Running）、可能正在等待CPU时间片（Ready）</p>
</li>
<li><p><strong>阻塞（Blocked）：</strong>等待获取一个排它锁，如果线程释放了锁就结束状态</p>
</li>
<li><p><strong>限期等待（Time Waiting）：</strong>一定时间后系统自动唤醒</p>
<table>
<thead>
<tr>
<th><strong>进入方法</strong></th>
<th><strong>退出方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Thread.sleep() 方法</td>
<td>时间结束</td>
</tr>
<tr>
<td>设置 Timeout 参数的 Object.wait() 方法</td>
<td>时间结束 &#x2F; Object.notify() &#x2F; Object.notifyAll()</td>
</tr>
<tr>
<td>设置 Timeout 参数的 Thread.join() 方法</td>
<td>时间结束 &#x2F; 被调用的线程执行完毕</td>
</tr>
</tbody></table>
</li>
<li><p><strong>无限期等待（Waiting）：</strong>等待其他线程唤醒，不然不会被分配CPU时间片</p>
<table>
<thead>
<tr>
<th><strong>进入方法</strong></th>
<th><strong>退出方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td>没有设置 Timeout 参数的 Object.wait() 方法</td>
<td>Object.notify() &#x2F; Object.notifyAll()</td>
</tr>
<tr>
<td>没有设置 Timeout 参数的 Thread.join() 方法</td>
<td>被调用的线程执行完毕</td>
</tr>
</tbody></table>
</li>
<li><p><strong>死亡（Terminated）：</strong>线程结束 &#x2F; 出现异常</p>
</li>
</ol>
<h1 id="2、实现线程-⭐⭐"><a href="#2、实现线程-⭐⭐" class="headerlink" title="2、实现线程 ⭐⭐"></a>2、实现线程 ⭐⭐</h1><p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。</p>
<blockquote>
<p>实现接口 VS 继承 </p>
</blockquote>
<p>Thread实现接口会更好一些，因为：</p>
<ol>
<li>Java <strong>不支持多重继承</strong>，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li>
<li>类可能只要求可执行就行，继承整个 Thread 类<strong>开销过大</strong>。</li>
</ol>
<h2 id="2-1-实现Runnable接口"><a href="#2-1-实现Runnable接口" class="headerlink" title="2.1 实现Runnable接口"></a>2.1 实现Runnable接口</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Thread(Runnable target)</td>
<td>分配一个新的Thread对象</td>
</tr>
<tr>
<td>Thread(Runnable target, String name)</td>
<td>分配一个新的Thread对象，并重命名</td>
</tr>
</tbody></table>
<p>需要实现 run() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 Thread 调用 start() 方法来启动线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyRunnable</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instance);</span><br><span class="line">	<span class="comment">//Thread t1 = new Thread(instance,&quot;高铁&quot;);</span></span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-继承Thread类"><a href="#2-2-继承Thread类" class="headerlink" title="2.2 继承Thread类"></a>2.2 继承Thread类</h2><ol>
<li><strong>核心方法</strong><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void run()</td>
<td>在线程开启后，此方法将被调用执行</td>
</tr>
<tr>
<td>void start()</td>
<td>启动线程，然后由JVM调用此线程的run()方法</td>
</tr>
</tbody></table>
</li>
</ol>
<p>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>线程信息方法</strong><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void setName(String name)</td>
<td>将此线程的名称更改为等于参数name</td>
</tr>
<tr>
<td>String getName()</td>
<td>返回此线程的名称</td>
</tr>
<tr>
<td>Thread currentThread()</td>
<td>返回对当前正在执行的线程对象的引用</td>
</tr>
</tbody></table>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一般用于日志打印</span></span><br><span class="line">System.out.println(Thread.currentThread().getName());</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>线程优先级</strong></li>
</ol>
<ul>
<li>两种线程调度方式 <ul>
<li><strong>分时调度模型：</strong>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片</li>
<li><strong>抢占式调度模型：</strong>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些（Java默认）<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>final int getPriority()</td>
<td>返回此线程的优先级</td>
</tr>
<tr>
<td>final void setPriority(int newPriority)</td>
<td>更改此线程的优先级 线程默认优先级是5；线程优先级的范围是：1-10</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ThreadPriority</span> <span class="variable">tp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPriority</span>();</span><br><span class="line">tp.getPriority(); <span class="comment">//5</span></span><br><span class="line">tp.setPriority(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h2 id="2-3-实现Callable接口（JUC）"><a href="#2-3-实现Callable接口（JUC）" class="headerlink" title="2.3 实现Callable接口（JUC）"></a>2.3 实现Callable接口（JUC）</h2><p>与 Runnable 相比，Callable 可以有返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回值通过 FutureTask（线程池内容） 进行封装</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="type">MyCallable</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(mc);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3、Java锁机制"><a href="#3、Java锁机制" class="headerlink" title="3、Java锁机制"></a>3、Java锁机制</h1><p>:::tips</p>
<ol>
<li><strong>线程要不要锁住同步资源？</strong><ul>
<li>锁住：<strong>悲观锁</strong></li>
<li>不锁住：<strong>乐观锁</strong></li>
</ul>
</li>
<li><strong>锁住同步资源失败，线程要不要阻塞？</strong><ul>
<li>阻塞</li>
<li>不阻塞：<strong>自旋锁&#x2F;自适应自旋锁</strong></li>
</ul>
</li>
<li><strong>多个线程竞争同步资源的流程细节有没有区别？</strong><ul>
<li>不锁住资源，多个线程中只有一个能修改资源成功，具它线程会重试：<strong>无锁</strong></li>
<li>同一个线程执行同步资源时自动获取资源：<strong>偏向锁</strong></li>
<li>多个线程竞争同步资源时，没有获取资源的线程自旋等待锁释放：<strong>轻量级锁</strong></li>
<li>多个线程竞争同步资源时，没有获取资源的线程阻塞等待唤醒：<strong>重量级锁</strong></li>
</ul>
</li>
<li><strong>多个线程竞争锁时要不要排队？</strong><ul>
<li>排队：<strong>公平锁</strong></li>
<li>先尝试插队，插队失败再排队：<strong>非公平锁</strong></li>
</ul>
</li>
<li><strong>一个线程中的多个流程能不能获取同一把锁？</strong><ul>
<li>能：<strong>可重入锁</strong></li>
<li>不能：<strong>非可重入锁</strong></li>
</ul>
</li>
<li><strong>多个线程能不能共享一把锁</strong><ul>
<li>能：<strong>共享锁</strong></li>
<li>不能：<strong>排它锁</strong><br>:::</li>
</ul>
</li>
</ol>
<h2 id="3-1-乐观锁-悲观锁"><a href="#3-1-乐观锁-悲观锁" class="headerlink" title="3.1 乐观锁&#x2F;悲观锁"></a>3.1 乐观锁&#x2F;悲观锁</h2><ul>
<li><strong>悲观锁适合写操作多的场景，</strong>先加锁可以保证写操作时数据正确。</li>
<li><strong>乐观锁适合读操作多的场景，</strong>不加锁的特点能够使其读操作的性能大幅提升。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697073457856-86a86e6b-106d-4199-8a3a-16d6ed30ba23.png#averageHue=%23f6f3ee&clientId=uf0f5972f-536f-4&from=drop&id=vGlT6&originHeight=1462&originWidth=1898&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=104259&status=done&style=none&taskId=ue621a7b8-0d53-4e15-96aa-d10dae0e8c9&title=" alt="java-lock-2.png"><br>对于同一个数据的并发操作：</p>
<ol>
<li><p>悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。【Java中，synchronized关键字和Lock的实现类都是悲观锁】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// synchronized</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 操作同步资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReentrantLock</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">// 需要保证多个线程使用的是同一个锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modifyPublicResources</span><span class="params">()</span> &#123;</span><br><span class="line">	lock.lock();</span><br><span class="line">	<span class="comment">// 操作同步资源</span></span><br><span class="line">	lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。【Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();  <span class="comment">// 需要保证多个线程使用的是同一个AtomicInteger</span></span><br><span class="line">atomicInteger.incrementAndGet(); <span class="comment">//执行自增1</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-2-自旋锁-适应性自旋锁"><a href="#3-2-自旋锁-适应性自旋锁" class="headerlink" title="3.2 自旋锁&#x2F;适应性自旋锁"></a>3.2 自旋锁&#x2F;适应性自旋锁</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697074045476-bb4daf93-4bde-424b-b098-2f4846573d44.png#averageHue=%23fcfcfc&clientId=u39aa0cd9-7c7b-4&from=drop&id=BYkNU&originHeight=1276&originWidth=1320&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=46569&status=done&style=none&taskId=u4a86db4f-38c0-4b3d-8e70-860d6e0e6f0&title=" alt="java-lock-4.png"><br>:::tips<br><strong>概念：</strong>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。<br>我们可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么<strong>当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销</strong>。这就是自旋锁。<br>:::<br>:::tips<br><strong>缺点：</strong>自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。<strong>如果锁被占用的时间很短，自旋等待的效果就会非常好。</strong>反之，<strong>如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。</strong>所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。<br>:::<br>:::tips<br><strong>应用：</strong>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。<br>:::</p>
<h2 id="3-3-无锁-偏向锁-轻量级锁-重量级锁"><a href="#3-3-无锁-偏向锁-轻量级锁-重量级锁" class="headerlink" title="3.3 无锁&#x2F;偏向锁&#x2F;轻量级锁&#x2F;重量级锁"></a>3.3 无锁&#x2F;偏向锁&#x2F;轻量级锁&#x2F;重量级锁</h2><p>这四种锁是指锁的状态，专门针对synchronized的。<br>总结而言：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697114528909-c30e8f32-fa25-4de9-a71c-f00a7aa895ad.png#averageHue=%23c8e7fc&clientId=ua061cce9-94ae-4&from=drop&id=JIYzM&originHeight=264&originWidth=1544&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=3630&status=done&style=none&taskId=uda70a9e8-02c4-420f-bcdc-bdf49d8a82f&title=" alt="java-lock-6.png"></p>
<ol>
<li><strong>偏向锁：</strong>通过对比Mark Word解决加锁问题，避免执行CAS操作</li>
<li><strong>轻量级锁：</strong>是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能</li>
<li><strong>重量级锁：</strong>是将除了拥有锁的线程以外的线程都阻塞。</li>
</ol>
<h2 id="3-4-公平锁-非公平锁"><a href="#3-4-公平锁-非公平锁" class="headerlink" title="3.4 公平锁&#x2F;非公平锁"></a>3.4 公平锁&#x2F;非公平锁</h2><ol>
<li><strong>公平锁：</strong>是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。<ul>
<li><strong>优点：</strong>等待锁的线程不会饿死。</li>
<li><strong>缺点：</strong>整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</li>
</ul>
</li>
<li><strong>非公平锁：</strong>是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。<ul>
<li><strong>优点：</strong>可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。</li>
<li><strong>缺点：</strong>处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</li>
</ul>
</li>
</ol>
<ul>
<li>非公平锁：</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697114582796-1664ad3a-10e7-41cf-8df3-ac391fc9ea78.png#averageHue=%23fcfbfb&clientId=ua061cce9-94ae-4&from=drop&id=P8nXG&originHeight=1222&originWidth=1436&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=67145&status=done&style=none&taskId=u59d6e467-1f8d-46f6-afe6-e73511cd107&title=" alt="java-lock-8.png"></p>
<h2 id="3-5-可重入锁-非可重入锁"><a href="#3-5-可重入锁-非可重入锁" class="headerlink" title="3.5 可重入锁&#x2F;非可重入锁"></a>3.5 可重入锁&#x2F;非可重入锁</h2><p> 可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法1执行...&quot;</span>);</span><br><span class="line">        doOthers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doOthers</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法2执行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>:::tips<br>在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。<br>如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。<br>:::<br>举例：</p>
<ol>
<li><strong>可重入锁：</strong>有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697115328950-bae6a972-2e21-4250-9beb-d9b7ffbbdba3.png#averageHue=%23fdfcfc&clientId=ua061cce9-94ae-4&from=drop&id=krkom&originHeight=1058&originWidth=1838&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=48125&status=done&style=none&taskId=u876b224c-20c0-4295-9ab1-e255bfe1b9b&title=" alt="java-lock-12.png"></p>
<ol start="2">
<li><strong>非可重入锁：</strong>管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697115359811-21602da1-d961-4892-b865-9e6af8a23bcc.png#averageHue=%23fdfdfd&clientId=ua061cce9-94ae-4&from=drop&id=clCSW&originHeight=1052&originWidth=1812&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=49711&status=done&style=none&taskId=ufef624c3-87a3-464a-afe9-9eea0acd5fe&title=" alt="java-lock-13.png"></p>
<h2 id="3-6-排它锁-共享锁"><a href="#3-6-排它锁-共享锁" class="headerlink" title="3.6 排它锁&#x2F;共享锁"></a>3.6 排它锁&#x2F;共享锁</h2><ol>
<li><strong>排他锁：</strong>是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。</li>
<li><strong>共享锁：</strong>是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</li>
</ol>
<p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。<br>下图为ReentrantReadWriteLock的部分源码：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697115587090-0ab35346-1ac6-4a09-8137-bad826648788.png#averageHue=%23fdfcfc&clientId=ua061cce9-94ae-4&from=drop&id=D0LgF&originHeight=1076&originWidth=1850&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=145556&status=done&style=none&taskId=u247a6235-0f90-41ec-8dd1-80d5f42a8ea&title=" alt="java-lock-15.png"><br>:::tips<br>我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。<br>:::<br>在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样：<br>读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。</p>
<h1 id="4、线程控制-⭐⭐"><a href="#4、线程控制-⭐⭐" class="headerlink" title="4、线程控制 ⭐⭐"></a>4、线程控制 ⭐⭐</h1><h2 id="4-1-Executor（JUC）"><a href="#4-1-Executor（JUC）" class="headerlink" title="4.1 Executor（JUC）"></a>4.1 Executor（JUC）</h2><p>Executor <strong>管理多个异步任务的执行</strong>，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。<br>主要有三种 Executor:</p>
<ul>
<li>CachedThreadPool: 一个任务创建一个线程；</li>
<li>FixedThreadPool: 所有任务只能使用固定大小的线程；</li>
<li>SingleThreadExecutor: 相当于大小为 1 的 FixedThreadPool。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-2-Thread-sleep-join-yield-Daemon"><a href="#4-2-Thread-sleep-join-yield-Daemon" class="headerlink" title="4.2 Thread(sleep&#x2F;join&#x2F;yield&#x2F;Daemon)"></a>4.2 Thread(sleep&#x2F;join&#x2F;yield&#x2F;Daemon)</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>static void sleep(long millis)</td>
<td><strong>线程暂停一段时间；</strong>等时间结束进入就绪态【线程会阻塞】</td>
</tr>
<tr>
<td>void join()</td>
<td><strong>在线程A中调用线程B的 join() 方法，先运行完B线程在运行A线程；</strong>【线程会阻塞】</td>
</tr>
<tr>
<td>void yield()</td>
<td><strong>线程暂停，让给同等或更高优先级的线程执行；</strong>线程让出CPU的执行【线程不会阻塞】</td>
</tr>
<tr>
<td>void setDaemon(boolean on)</td>
<td><strong>将此线程标记为守护线程</strong>，守护线程是一种在后台运行的线程，它的生命周期与程序的非守护线程不同</td>
</tr>
</tbody></table>
<ol>
<li><strong>sleep()：</strong>Thread.sleep(millisec) 方法会<strong>休眠当前正在执行的线程</strong>，millisec 单位为毫秒。</li>
</ol>
<p>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>join()：</strong>在线程A中调用线程B的 join() 方法，先运行完B线程在运行A线程；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 目标线程要执行的任务</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thread.start(); <span class="comment">// 启动目标线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待目标线程执行完成</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    thread.join(); <span class="comment">// 目标线程执行完成后，继续执行当前线程的其他任务</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>yield()：</strong>对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，<strong>可以切换给其它线程来执行</strong>。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    Thread.<span class="keyword">yield</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Daemon：守护线程</strong>是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p>
</li>
</ol>
<p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程【main() 属于非守护线程】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">	<span class="comment">// 使用 setDaemon() 方法将一个线程设置为守护线程</span></span><br><span class="line">    thread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5、线程协作方案"><a href="#5、线程协作方案" class="headerlink" title="5、线程协作方案"></a>5、线程协作方案</h1><p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调</p>
<h2 id="5-1-join"><a href="#5-1-join" class="headerlink" title="5.1 join()"></a>5.1 join()</h2><p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		a.join();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-wait-notify-notifyAll"><a href="#5-2-wait-notify-notifyAll" class="headerlink" title="5.2 wait()&#x2F;notify()&#x2F;notifyAll()"></a>5.2 wait()&#x2F;notify()&#x2F;notifyAll()</h2><p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。它们都属于 Object 的一部分，而不属于 Thread。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotifyExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateExeception。<br>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</p>
<h2 id="5-3-await-signal-signalAll-（JUC）"><a href="#5-3-await-signal-signalAll-（JUC）" class="headerlink" title="5.3 await()&#x2F;signal()&#x2F;signalAll()（JUC）"></a>5.3 await()&#x2F;signal()&#x2F;signalAll()（JUC）</h2><p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。使用 Lock 来获取一个 Condition 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AwaitSignalExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="type">AwaitSignalExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AwaitSignalExample</span>();</span><br><span class="line">    executorServiSWce.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6、线程安全（互斥同步）-⭐⭐"><a href="#6、线程安全（互斥同步）-⭐⭐" class="headerlink" title="6、线程安全（互斥同步） ⭐⭐"></a>6、线程安全（互斥同步） ⭐⭐</h1><p>:::tips<br> 互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁(这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁)、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。<br>:::<br>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p>
<blockquote>
<p>使用建议</p>
</blockquote>
<p> 除非需要使用 ReentrantLock 的高级功能，否则<strong>优先使用 synchronized</strong>，原因如下：</p>
<ol>
<li><p>synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。</p>
</li>
<li><p>synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p>
<blockquote>
<p>ReentrantLock 的高级性质</p>
</blockquote>
</li>
<li><p>ReentrantLock 可中断线程（当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情）</p>
</li>
<li><p>ReentrantLock 默认情况下也是非公平锁，但是也可以是公平的</p>
</li>
<li><p>一个 ReentrantLock 可以同时绑定多个 Condition 对象</p>
</li>
</ol>
<h2 id="6-1-synchronized"><a href="#6-1-synchronized" class="headerlink" title="6.1 synchronized"></a>6.1 synchronized</h2><ol>
<li><p><strong>同步代码块：</strong>（同一个对象）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>同步方法：</strong>（作用在整个方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">func</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态方法：作用在整个类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>同步类：</strong>（作用在整个类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SynchronizedExample.class) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="6-2-ReentrantLock（JUC）"><a href="#6-2-ReentrantLock（JUC）" class="headerlink" title="6.2 ReentrantLock（JUC）"></a>6.2 ReentrantLock（JUC）</h2><p>Lock是接口不能直接实例化，这里采用它的实现类<strong>ReentrantLock</strong>来实例化</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void lock()</td>
<td>加锁</td>
</tr>
<tr>
<td>void unlock()</td>
<td>解锁</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 确保释放锁，从而避免发生死锁。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">LockExample</span> <span class="variable">lockExample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockExample</span>();</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7、线程安全（非阻塞同步）-⭐"><a href="#7、线程安全（非阻塞同步）-⭐" class="headerlink" title="7、线程安全（非阻塞同步） ⭐"></a>7、线程安全（非阻塞同步） ⭐</h1><p>:::tips<br>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为<strong>阻塞同步</strong>。<br>:::</p>
<h2 id="7-1-CAS（乐观锁）"><a href="#7-1-CAS（乐观锁）" class="headerlink" title="7.1 CAS（乐观锁）"></a>7.1 CAS（乐观锁）</h2><p>:::tips<br>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略: 先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施(不断地重试，直到成功为止)。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为<strong>非阻塞同步</strong>。<br><strong>乐观锁</strong>需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成<strong>（硬件平台的汇编指令）</strong>。硬件支持的原子性操作最典型的是: 比较并交换(Compare-and-Swap，CAS)。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。<br>:::<br><strong>CAS会导致问题：</strong></p>
<ol>
<li><p><strong>ABA 问题：</strong>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。<br>:::tips<br>ABA问题的解决思路就是<strong>使用版本号</strong>。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A-&gt;B-&gt;A就会变成1A-&gt;2B-&gt;3A。<br>JDK的Atomic包里提供了一个类<strong>AtomicStampedReference</strong>来解决ABA问题。这个类的<strong>compareAndSet</strong>方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。<br>:::</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicStampedReferenceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference&lt;String&gt; atomicRef = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">expectedReference</span> <span class="operator">=</span> atomicRef.getReference();</span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedStamp</span> <span class="operator">=</span> atomicRef.getStamp();</span><br><span class="line">        <span class="type">String</span> <span class="variable">newReference</span> <span class="operator">=</span> <span class="string">&quot;B&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newStamp</span> <span class="operator">=</span> expectedStamp + <span class="number">1</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> atomicRef.compareAndSet(expectedReference, newReference, expectedStamp, newStamp);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;compareAndSet执行结果：&quot;</span> + success);</span><br><span class="line">        System.out.println(<span class="string">&quot;最终的引用值：&quot;</span> + atomicRef.getReference());</span><br><span class="line">        System.out.println(<span class="string">&quot;最终的标记值：&quot;</span> + atomicRef.getStamp());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>循环时间长开销大问题：</strong><br>:::tips<br> 自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。<br>pause指令有两个作用：</p>
</li>
<li><p>它可以延迟流水线执行命令(de-pipeline)，使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零；</p>
</li>
<li><p>它可以避免在退出循环的时候因内存顺序冲突(Memory Order Violation)而引起CPU流水线被清空(CPU Pipeline Flush)，从而提高CPU的执行效率。<br>:::</p>
</li>
<li><p><strong>只能保证一个共享变量的原子操作：</strong><br>:::tips<br>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。<br>还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i &#x3D; 2，j &#x3D; a，合并一下ij &#x3D; 2a，然后用CAS来操作ij。<br>从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。<br>:::</p>
</li>
</ol>
<h2 id="7-2-AtomicXXX（JUC）"><a href="#7-2-AtomicXXX（JUC）" class="headerlink" title="7.2 AtomicXXX（JUC）"></a>7.2 AtomicXXX（JUC）</h2><ul>
<li>一共4个分类，13个小类。<br>:::tips</li>
</ul>
<ol>
<li><strong>原子更新基本类型：</strong></li>
</ol>
<ul>
<li>AtomicBoolean: 原子更新布尔类型</li>
<li>AtomicInteger: 原子更新整型 ⭐</li>
<li>AtomicLong: 原子更新长整型<br>:::<br>:::tips</li>
</ul>
<ol start="2">
<li><strong>原子更新数组：</strong></li>
</ol>
<ul>
<li>AtomicIntegerArray: 原子更新整型数组里的元素。</li>
<li>AtomicLongArray: 原子更新长整型数组里的元素。</li>
<li>AtomicReferenceArray: 原子更新引用类型数组里的元素。</li>
</ul>
<p>最常用的两个方法：</p>
<ul>
<li>get(int index)：获取索引为index的元素值</li>
<li>compareAndSet(int i,E expect,E update): 如果当前值等于预期值，则以原子方式将数组位置i的元素设置为update值<br>:::<br>:::tips</li>
</ul>
<ol start="3">
<li><strong>原子更新引用类型：</strong></li>
</ol>
<ul>
<li>AtomicReference: 原子更新引用类型。 ⭐</li>
<li>AtomicStampedReference: 原子更新引用类型, 内部使用Pair来存储元素值及其版本号。</li>
<li>AtomicMarkableReferce: 原子更新带有标记位的引用类型。</li>
</ul>
<p> 这三个类提供的方法都差不多，首先构造一个引用对象，然后把引用对象set进Atomic类，然后调用<strong>compareAndSet</strong>等一些方法去进行原子操作，原理都是基于Unsafe实现，但AtomicReferenceFieldUpdater略有不同，更新的字段必须用volatile修饰。<br>:::<br>:::tips</p>
<ol start="4">
<li><strong>原子更新字段类：</strong></li>
</ol>
<ul>
<li>AtomicIntegerFieldUpdater: 原子更新整型的字段的更新器。</li>
<li>AtomicLongFieldUpdater: 原子更新长整型字段的更新器。</li>
<li>AtomicReferenceFieldUpdater: 上面已经说过此处不在赘述。</li>
</ul>
<p>是基于反射的原子更新字段的值。要想原子地更新字段类需要两步:</p>
<ul>
<li>第一步，因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。</li>
<li>第二步，更新类的字段必须使用public volatile修饰。<br>:::<br>以下代码使用了 AtomicInteger 执行了自增的操作。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        cnt.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
AtomicInteger 常用API：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span>：获取当前的值</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span>：获取当前的值，并设置新的值</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span>：获取当前的值，并自增</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span>：获取当前的值，并自减</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span>：获取当前的值，并加上预期的值</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> newValue)</span>: 最终会设置成newValue,使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="生产者消费者-多线程"><a href="#生产者消费者-多线程" class="headerlink" title="生产者消费者(多线程)"></a>生产者消费者(多线程)</h1><p>:::tips<br>为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库</p>
<ul>
<li><p>生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为</p>
</li>
<li><p>消费者只需要从共享数据区中去获取数据，并不需要关心生产者的行为<br>:::<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697183015987-d093d359-e7d6-4ff7-aade-e84bbc8b4a17.png#averageHue=%23afc7e8&clientId=uc4f565ad-210d-4&id=bWiuf&originHeight=90&originWidth=725&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1e48c02e-8906-4008-95b4-0193a0baf70&title="></p>
</li>
<li><p>Object类的等待和唤醒方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void wait()</td>
<td>导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法</td>
</tr>
<tr>
<td>void notify()</td>
<td>唤醒正在等待对象监视器的单个线程</td>
</tr>
<tr>
<td>void notifyAll()</td>
<td>唤醒正在等待对象监视器的所有线程</td>
</tr>
</tbody></table>
</li>
<li><p>案例需求</p>
</li>
</ul>
<p>生产者消费者案例中包含的类：（Box、Producer、Customer）</p>
<ol>
<li><p><strong>奶箱类(Box)：</strong>定义一个成员变量，表示第x瓶奶，提供存储牛奶和获取牛奶的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个成员变量，表示第x瓶奶</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> milk;</span><br><span class="line">    <span class="comment">//定义一个成员变量，表示奶箱的状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">state</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//提供存储牛奶和获取牛奶的操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> milk)</span> &#123;</span><br><span class="line">        <span class="comment">//如果有牛奶，等待消费</span></span><br><span class="line">        <span class="keyword">if</span>(state) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有牛奶，就生产牛奶</span></span><br><span class="line">        <span class="built_in">this</span>.milk = milk;</span><br><span class="line">        System.out.println(<span class="string">&quot;送奶工将第&quot;</span> + <span class="built_in">this</span>.milk + <span class="string">&quot;瓶奶放入奶箱&quot;</span>);</span><br><span class="line">        <span class="comment">//生产完毕之后，修改奶箱状态</span></span><br><span class="line">        state = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//唤醒其他等待的线程</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//如果没有牛奶，等待生产</span></span><br><span class="line">        <span class="keyword">if</span>(!state) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果有牛奶，就消费牛奶</span></span><br><span class="line">        System.out.println(<span class="string">&quot;用户拿到第&quot;</span> + <span class="built_in">this</span>.milk + <span class="string">&quot;瓶奶&quot;</span>);</span><br><span class="line">        <span class="comment">//消费完毕之后，修改奶箱状态</span></span><br><span class="line">        state = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//唤醒其他等待的线程</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>生产者类(Producer)：</strong>实现Runnable接口，重写run()方法，调用存储牛奶的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Box b;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Box b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">30</span>; i++) &#123;</span><br><span class="line">            b.put(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>消费者类(Customer)：</strong>实现Runnable接口，重写run()方法，调用获取牛奶的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Box b;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(Box b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            b.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>测试类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoxDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建奶箱对象，这是共享数据区域</span></span><br><span class="line">        <span class="type">Box</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Box</span>();</span><br><span class="line">        <span class="comment">//创建生产者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用存储牛奶的操作</span></span><br><span class="line">        <span class="type">Producer</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(b);</span><br><span class="line">        <span class="comment">//创建消费者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用获取牛奶的操作</span></span><br><span class="line">        <span class="type">Customer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(b);</span><br><span class="line">        <span class="comment">//创建2个线程对象，分别把生产者对象和消费者对象作为构造方法参数传递</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(p);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(c);</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">cocochimp</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/01/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">http://example.com/2024/01/18/Java多线程/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">cocochimpBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/18/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="JVM虚拟机"><img class="cover" src="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/JVM.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JVM虚拟机</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/18/Java%E9%9B%86%E5%90%88/" title="Java集合"><img class="cover" src="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/Java%E9%9B%86%E5%90%88.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java集合</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/01/18/Java%E9%9B%86%E5%90%88/" title="Java集合"><img class="cover" src="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/Java%E9%9B%86%E5%90%88.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-18</div><div class="title">Java集合</div></div></a></div><div><a href="/2024/01/18/Java%E5%9F%BA%E7%A1%80:%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" title="Java基础&#x2F;高级特性"><img class="cover" src="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/Java%E5%9F%BA%E7%A1%80.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-18</div><div class="title">Java基础&#x2F;高级特性</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">cocochimp</div><div class="author-info__description">to be a cool man!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/cocochimp" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://gitee.com/cocochimp" target="_blank" title="Gitee"><i class="fab fa-github-alt"></i></a><a class="social-icon" href="https://blog.csdn.net/m0_51634403" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="mailto:2427886409@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS"><span class="toc-number">1.</span> <span class="toc-text">AQS</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E3%80%81%E5%B9%B6%E5%8F%91-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5-%E2%AD%90"><span class="toc-number"></span> <span class="toc-text">1、并发&#x2F;多线程概念 ⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">1.1 常见概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%B9%B6%E5%8F%91%E4%B8%89%E8%A6%81%E7%B4%A0-%E5%8F%AF%E8%A7%81-%E5%8E%9F%E5%AD%90-%E6%9C%89%E5%BA%8F"><span class="toc-number">2.</span> <span class="toc-text">1.2 并发三要素(可见&#x2F;原子&#x2F;有序)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%EF%BC%9AJMM"><span class="toc-number">3.</span> <span class="toc-text">1.3 如何解决并发：JMM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.</span> <span class="toc-text">1.4 线程状态转换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B-%E2%AD%90%E2%AD%90"><span class="toc-number"></span> <span class="toc-text">2、实现线程 ⭐⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.</span> <span class="toc-text">2.1 实现Runnable接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">2.2 继承Thread类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3%EF%BC%88JUC%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">2.3 实现Callable接口（JUC）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E3%80%81Java%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number"></span> <span class="toc-text">3、Java锁机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E4%B9%90%E8%A7%82%E9%94%81-%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">1.</span> <span class="toc-text">3.1 乐观锁&#x2F;悲观锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E8%87%AA%E6%97%8B%E9%94%81-%E9%80%82%E5%BA%94%E6%80%A7%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">2.</span> <span class="toc-text">3.2 自旋锁&#x2F;适应性自旋锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%97%A0%E9%94%81-%E5%81%8F%E5%90%91%E9%94%81-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">3.</span> <span class="toc-text">3.3 无锁&#x2F;偏向锁&#x2F;轻量级锁&#x2F;重量级锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%85%AC%E5%B9%B3%E9%94%81-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">4.</span> <span class="toc-text">3.4 公平锁&#x2F;非公平锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-%E9%9D%9E%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">5.</span> <span class="toc-text">3.5 可重入锁&#x2F;非可重入锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E6%8E%92%E5%AE%83%E9%94%81-%E5%85%B1%E4%BA%AB%E9%94%81"><span class="toc-number">6.</span> <span class="toc-text">3.6 排它锁&#x2F;共享锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E3%80%81%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6-%E2%AD%90%E2%AD%90"><span class="toc-number"></span> <span class="toc-text">4、线程控制 ⭐⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Executor%EF%BC%88JUC%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">4.1 Executor（JUC）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Thread-sleep-join-yield-Daemon"><span class="toc-number">2.</span> <span class="toc-text">4.2 Thread(sleep&#x2F;join&#x2F;yield&#x2F;Daemon)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E3%80%81%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C%E6%96%B9%E6%A1%88"><span class="toc-number"></span> <span class="toc-text">5、线程协作方案</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-join"><span class="toc-number">1.</span> <span class="toc-text">5.1 join()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-wait-notify-notifyAll"><span class="toc-number">2.</span> <span class="toc-text">5.2 wait()&#x2F;notify()&#x2F;notifyAll()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-await-signal-signalAll-%EF%BC%88JUC%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">5.3 await()&#x2F;signal()&#x2F;signalAll()（JUC）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5%EF%BC%89-%E2%AD%90%E2%AD%90"><span class="toc-number"></span> <span class="toc-text">6、线程安全（互斥同步） ⭐⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-synchronized"><span class="toc-number">1.</span> <span class="toc-text">6.1 synchronized</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-ReentrantLock%EF%BC%88JUC%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">6.2 ReentrantLock（JUC）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%88%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5%EF%BC%89-%E2%AD%90"><span class="toc-number"></span> <span class="toc-text">7、线程安全（非阻塞同步） ⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-CAS%EF%BC%88%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">7.1 CAS（乐观锁）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-AtomicXXX%EF%BC%88JUC%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">7.2 AtomicXXX（JUC）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text">生产者消费者(多线程)</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/18/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="23种设计模式"><img src="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="23种设计模式"/></a><div class="content"><a class="title" href="/2024/01/18/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="23种设计模式">23种设计模式</a><time datetime="2024-01-18T03:00:54.577Z" title="发表于 2024-01-18 11:00:54">2024-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/18/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="JUC并发编程"><img src="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/juc.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC并发编程"/></a><div class="content"><a class="title" href="/2024/01/18/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="JUC并发编程">JUC并发编程</a><time datetime="2024-01-18T03:00:43.042Z" title="发表于 2024-01-18 11:00:43">2024-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/18/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="JVM虚拟机"><img src="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/JVM.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM虚拟机"/></a><div class="content"><a class="title" href="/2024/01/18/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="JVM虚拟机">JVM虚拟机</a><time datetime="2024-01-18T03:00:28.866Z" title="发表于 2024-01-18 11:00:28">2024-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="Java多线程"><img src="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java多线程"/></a><div class="content"><a class="title" href="/2024/01/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="Java多线程">Java多线程</a><time datetime="2024-01-18T03:00:10.504Z" title="发表于 2024-01-18 11:00:10">2024-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/18/Java%E9%9B%86%E5%90%88/" title="Java集合"><img src="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/Java%E9%9B%86%E5%90%88.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java集合"/></a><div class="content"><a class="title" href="/2024/01/18/Java%E9%9B%86%E5%90%88/" title="Java集合">Java集合</a><time datetime="2024-01-18T02:59:47.232Z" title="发表于 2024-01-18 10:59:47">2024-01-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By cocochimp</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div></body></html>