<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java基础/高级特性 | cocochimpBlog</title><meta name="author" content="cocochimp"><meta name="copyright" content="cocochimp"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="学习Java8这一篇就够了_java8会这些就够了-CSDN博客  面试题：Java基础知识面试题（91道含答案）:::tipsJava8新添特性：   Lambda表达式：允许把函数作为一个方法的参数（函数作为参数传递到方法中），使代码更加简洁和可读，并有助于编写并行代码。 Collections.sort(names, (s1, s2) -&gt; s1.compareTo(s2));   方">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础&#x2F;高级特性">
<meta property="og:url" content="http://example.com/2024/01/18/Java%E5%9F%BA%E7%A1%80:%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/index.html">
<meta property="og:site_name" content="cocochimpBlog">
<meta property="og:description" content="学习Java8这一篇就够了_java8会这些就够了-CSDN博客  面试题：Java基础知识面试题（91道含答案）:::tipsJava8新添特性：   Lambda表达式：允许把函数作为一个方法的参数（函数作为参数传递到方法中），使代码更加简洁和可读，并有助于编写并行代码。 Collections.sort(names, (s1, s2) -&gt; s1.compareTo(s2));   方">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/Java%E5%9F%BA%E7%A1%80.png">
<meta property="article:published_time" content="2024-01-18T02:59:25.942Z">
<meta property="article:modified_time" content="2024-01-18T03:28:06.844Z">
<meta property="article:author" content="cocochimp">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/Java%E5%9F%BA%E7%A1%80.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/01/18/Java%E5%9F%BA%E7%A1%80:%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础/高级特性',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-18 11:28:06'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="cocochimpBlog" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/picture/"><i class="fa-fw iconfont icon-tupian"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-touxiang"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/Java%E5%9F%BA%E7%A1%80.png')"><nav id="nav"><span id="blog-info"><a href="/" title="cocochimpBlog"><span class="site-name">cocochimpBlog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/picture/"><i class="fa-fw iconfont icon-tupian"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-touxiang"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java基础/高级特性</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-18T02:59:25.942Z" title="发表于 2024-01-18 10:59:25">2024-01-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-18T03:28:06.844Z" title="更新于 2024-01-18 11:28:06">2024-01-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">18.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>72分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java基础/高级特性"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://caochenlei.blog.csdn.net/article/details/119992847">学习Java8这一篇就够了_java8会这些就够了-CSDN博客</a></p>
<ul>
<li>面试题：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_30999361/article/details/124482581">Java基础知识面试题（91道含答案）</a><br>:::tips<br>Java8新添特性：</li>
</ul>
<ol>
<li><strong>Lambda表达式：允许把函数作为一个方法的参数</strong>（函数作为参数传递到方法中），使代码更加简洁和可读，并有助于编写并行代码。<ul>
<li>Collections.sort(names, (s1, s2) -&gt; s1.compareTo(s2));</li>
</ul>
</li>
<li><strong>方法引用：方法引用提供了一种简化代码的方法。</strong>它可以直接引用已存在的方法&#x2F;构造器，减少冗余代码，与 Lambda 表达式一起使用<strong>。</strong><ul>
<li>Integer::parseInt</li>
</ul>
</li>
<li><strong>函数式接口：支持函数式编程的特性。</strong>提供了一系列的函数式接口，用于便捷地使用Lambda表达式和方法引用（java.util.function）<ul>
<li>Consumer<T>：接受一个输入参数并且不返回结果的操作</li>
<li>Supplier<T>：提供一个结果的供应商</li>
<li>Function&lt;T, R&gt;：将一个类型的值转换为另一个类型的值</li>
<li>Predicate<T>：对一个输入参数进行判断，并返回一个布尔值。</li>
</ul>
</li>
<li><strong>Stream API：提供了一种流式操作集合的方法。</strong>可以通过一系列的操作（如过滤、映射、收集等）对数据进行处理。它能够简化对集合的操作，并支持并行处理，函数式编程风格（java.util.stream）</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696661152842-f0c740e0-c9d3-4727-9eac-b601d6ad78fd.png#averageHue=%23f0efee&clientId=uff5592ff-7738-4&from=paste&height=74&id=tSWX4&originHeight=92&originWidth=713&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=3701&status=done&style=none&taskId=ue780d218-f8e3-4115-a1f1-77849734f6f&title=&width=570.4" alt="image.png"></p>
<ol start="5">
<li><strong>默认方法：允许在接口中定义具有默认实现的方法。</strong>这样一来，即使在旧版本的接口中增加新的抽象方法，也不会破坏现有的实现类。</li>
<li><strong>Optional类：用于解决空指针异常的类。</strong>是一种用于处理可能为 null 的值的容器类。它可以减少空指针异常，并提供了一系列的方法来处理可能为空的值。（java.util.optional）<br>:::<blockquote>
<p>匿名内部类 —&gt; lambda —&gt; 方法引用</p>
</blockquote>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匿名内部类</span></span><br><span class="line">Consumer&lt;String&gt; consumer1 = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lambda表达式</span></span><br><span class="line">Consumer&lt;String&gt; consumer2 = s -&gt; System.out.println(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法引用【类::方法】默认传入参数s</span></span><br><span class="line">Consumer&lt;String&gt; consumer3 = System.out::println;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>Lambda表达式：</strong><a target="_blank" rel="noopener" href="https://www.cainiaojc.com/java/java8-lambda-expressions.html">Java Lambda 表达式</a><strong>&#x2F;</strong><a target="_blank" rel="noopener" href="http://dict.code-nav.cn/Java/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F.html">Lambda表达式</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 java 8 排序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sortUsingJava8</span><span class="params">(List&lt;String&gt; names)</span>&#123;</span><br><span class="line">  Collections.sort(names, (s1, s2) -&gt; s1.compareTo(s2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>方法引用：</strong><a target="_blank" rel="noopener" href="https://www.cainiaojc.com/java/java8-method-references.html">Java 8 方法引用</a></p>
</li>
<li><p><strong>Stream流：</strong><a target="_blank" rel="noopener" href="https://www.cainiaojc.com/java/java8-streams.html">Java 8 Stream</a><strong>【*】</strong><a target="_blank" rel="noopener" href="http://dict.code-nav.cn/Java/Stream%20API.html#terminal-%E6%93%8D%E4%BD%9C">Stream API</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链式编程！！！！</span></span><br><span class="line">list.stream()</span><br><span class="line">		.map((x)-&gt;x.getName().toUpperCase())</span><br><span class="line">		.filter((x)-&gt;x.getId()%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">		.sorted((x,y) -&gt; x.getWeight() - y.getWeight())</span><br><span class="line">		.limit(<span class="number">5</span>)</span><br><span class="line">		.collect(Collectors.toList())</span><br><span class="line">		.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>### map</td>
<td></td>
</tr>
</tbody></table>
</li>
</ol>
<p> | <strong>【元素处理】</strong>对映射的每个元素进行相应处理<br>平方处理：.map( i -&gt; i*i) |<br>| ### filter<br> | <strong>【筛选过滤if】</strong>通过设置的条件过滤出元素<br>判空处理：filter(string -&gt; string.isEmpty()) |</p>
<ul>
<li>stream流两种形式：<ul>
<li>stream() − 为集合创建串行流。</li>
<li>parallelStream()  − 为集合创建并行流。</li>
</ul>
</li>
</ul>
<h1 id="1、基础知识"><a href="#1、基础知识" class="headerlink" title="1、基础知识"></a>1、基础知识</h1><blockquote>
<p>Java语言跨平台原理</p>
</blockquote>
<p>Java程序并非是直接运行的，Java编译器将Java源程序编译成与平台无关的字节码文件(class文件)，然后由Java虚拟机（JVM）对字节码文件解释执行。所以在不同的操作系统下，只需安装不同的Java虚拟机即可实现java程序的跨平台。</p>
<ul>
<li>JVM（Java Virtual Machine），Java虚拟机</li>
<li>JRE（Java Runtime Environment），Java运行环境，包含了JVM和Java的核心类库（Java API）</li>
<li>JDK（Java Development Kit）称为Java开发工具，包含了JRE和开发工具</li>
</ul>
<p>总结：我们只需安装JDK即可，它包含了java的运行环境和虚拟机。</p>
<ul>
<li>JVM的内存模型，分别是：<strong>栈内存</strong>、<strong>堆内存、</strong>寄存器、方法区、本地方法栈<table>
<thead>
<tr>
<th>区域名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>堆内存</strong></td>
<td>存储对象或者数组，new来创建的，都存储在堆内存。</td>
</tr>
<tr>
<td><strong>方法栈</strong></td>
<td>方法运行时使用的内存，比如main和GC方法运行，进入方法栈中执行。</td>
</tr>
<tr>
<td>寄存器</td>
<td>给CPU使用，和我们开发无关。</td>
</tr>
<tr>
<td>本地方法栈</td>
<td>JVM在使用操作系统功能的时候使用，和我们开发无关。</td>
</tr>
<tr>
<td>方法区</td>
<td>存储可以运行的class文件。</td>
</tr>
</tbody></table>
</li>
</ul>
<p>Java虚拟机要运行程序，必须要对内存进行空间的分配和管理。</p>
<h2 id="1-1-基本数据类型-⭐"><a href="#1-1-基本数据类型-⭐" class="headerlink" title="1.1 基本数据类型 ⭐"></a>1.1 基本数据类型 ⭐</h2><p>Java是一个强类型语言，Java中的数据必须明确数据类型。<br>在Java中的数据类型包括<strong>基本数据类型</strong>和<strong>引用数据类型</strong>两种。</p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>关键字</strong></th>
<th><strong>内存占用（B）</strong></th>
<th><strong>取值范围（2的次方）</strong></th>
</tr>
</thead>
<tbody><tr>
<td>整数类型</td>
<td>byte</td>
<td>1</td>
<td>[-128,127]</td>
</tr>
<tr>
<td></td>
<td>short</td>
<td>2</td>
<td>[-215,215-1]</td>
</tr>
<tr>
<td></td>
<td><strong>int（默认）</strong></td>
<td>4</td>
<td>[-231,231-1]</td>
</tr>
<tr>
<td></td>
<td>long</td>
<td>8</td>
<td>[-263,263-1]</td>
</tr>
<tr>
<td>浮点类型</td>
<td>float</td>
<td>4</td>
<td>[-231,231-1]</td>
</tr>
<tr>
<td></td>
<td><strong>double（默认）</strong></td>
<td>8</td>
<td>[-263,263-1]</td>
</tr>
<tr>
<td>字符类型</td>
<td>char</td>
<td>2</td>
<td>[0,65535]</td>
</tr>
<tr>
<td>布尔类型</td>
<td>boolean</td>
<td>1</td>
<td>true，false</td>
</tr>
</tbody></table>
<ul>
<li><strong>类型转换：</strong>boolean类型不能与其他基本数据类型相互转换</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697201457602-ef51df63-02e8-4310-86c8-954dfa5719ed.png#averageHue=%23fdfcfc&clientId=uef60bb95-3f71-4&id=jHcfN&originHeight=197&originWidth=775&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u42731f98-5f42-4ba0-929b-dfac43ceb94&title="><br>char字符对应的一些特殊值<br>:::tips</p>
<ul>
<li>‘a’ – 97 a-z是连续的，所以’b’对应的数值是98，’c’是99，依次递加</li>
<li>‘A’ – 65 A-Z是连续的，所以’B’对应的数值是66，’C’是67，依次递加</li>
<li>‘0’ – 48 0-9是连续的，所以’1’对应的数值是49，’2’是50，依次递加<br>:::</li>
</ul>
<h2 id="1-2-抽象类-接口-⭐"><a href="#1-2-抽象类-接口-⭐" class="headerlink" title="1.2 抽象类 &#x2F; 接口 ⭐"></a>1.2 抽象类 &#x2F; 接口 ⭐</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697198074254-9cc9eff1-9fe8-44d9-a692-3d4d3038e3cf.png#averageHue=%23f9efe9&clientId=uef60bb95-3f71-4&id=IWMPo&originHeight=339&originWidth=613&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u811002d9-b5be-4639-94ff-f7b99be2a20&title="><br>:::tips<br>相同点：</p>
<ol>
<li>都<strong>不能被实例化</strong></li>
<li>接口的实现类&#x2F;抽象类的子类都只有实现或继承之后才能被实例化</li>
</ol>
<p>不同点：</p>
<ol>
<li>实现接口implements，继承抽象类extends，一个类可以实现多个接口，但只能继承一个抽象类</li>
<li>接口只有<strong>方法定义</strong>，没有实现；抽象类中有<strong>方法定义</strong>和<strong>方法实现</strong></li>
<li>接口强调特定功能的实现，抽象类强调所属关系<br>:::<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象类的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> class 类名 &#123;&#125;</span><br><span class="line"><span class="comment">//抽象方法的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口用关键字interface修饰</span></span><br><span class="line"><span class="keyword">public</span> interface 接口名 &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类实现接口用implements表示</span></span><br><span class="line"><span class="keyword">public</span> class 类名 implements 接口名 &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="1-3-权限修饰符"><a href="#1-3-权限修饰符" class="headerlink" title="1.3 权限修饰符"></a>1.3 权限修饰符</h2><table>
<thead>
<tr>
<th></th>
<th><strong>同一类</strong></th>
<th><strong>同一包子类无关类</strong></th>
<th><strong>不同包的子类</strong></th>
<th><strong>不同包的非子类</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>public</strong></td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
</tr>
<tr>
<td><strong>protected</strong></td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
<td></td>
</tr>
<tr>
<td><strong>默认</strong></td>
<td>✔️</td>
<td>✔️</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>private</strong></td>
<td>✔️</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>修饰类时，只能使用 public 或默认访问修饰符（不使用任何修饰符）。</li>
<li>在接口中，接口的所有成员都默认使用 public 访问权限。</li>
</ul>
<h2 id="1-4-final-static"><a href="#1-4-final-static" class="headerlink" title="1.4 final &#x2F; static"></a>1.4 final &#x2F; static</h2><ul>
<li>final 用于限定不可修改的特性，用于限制继承和修改</li>
<li>static 用于表示类级别的共享特性，用于实现共享和方便访问。<br>:::tips</li>
</ul>
<ol>
<li><strong>修饰范围：</strong></li>
</ol>
<ul>
<li>final：可以修饰类、方法和变量。被 final 修饰的类不能被继承，被 final 修饰的方法不能被子类重写，被 final 修饰的变量是不可修改的。</li>
<li>static：可以修饰方法、变量和内部类。被 static 修饰的方法和变量属于类级别，可以直接通过类名访问，不需要创建对象。</li>
</ul>
<ol start="2">
<li><strong>内存分配：</strong></li>
</ol>
<ul>
<li>final：被 final 修饰的变量在声明时必须被初始化，且其值在初始化后不能再被修改。</li>
<li>static：被 static 修饰的变量属于类级别，只有一份实例存在，被所有对象共享。</li>
</ul>
<ol start="3">
<li><strong>继承和多态性：</strong></li>
</ol>
<ul>
<li>final：被 final 修饰的类不能被继承，被 final 修饰的方法不能被子类重写，但可以被继承类继承和调用。</li>
<li>static：静态方法和变量属于类级别，不具备多态性。</li>
</ul>
<ol start="4">
<li><strong>访问方式：</strong></li>
</ol>
<ul>
<li>final：被 final 修饰的类、方法和变量可以通过对象或类名直接访问。</li>
<li>static：被 static 修饰的方法和变量可以直接通过类名访问，不需要创建对象，静态内部类也可以通过类名直接访问。<br>:::</li>
</ul>
<h2 id="1-5-可变参数"><a href="#1-5-可变参数" class="headerlink" title="1.5 可变参数"></a>1.5 可变参数</h2><ul>
<li><p>可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了 【变量其实是一个数组】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>... a)</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可变参数的使用</p>
</blockquote>
</li>
<li><p>Arrays工具类中有一个静态方法： </p>
<ul>
<li>public static List <strong>asList</strong>(T… a)：返回由指定数组支持的固定大小的列表</li>
<li>返回的集合不能做增删操作，可以做修改操作<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">asList</span><span class="params">(T... a)</span>：<span class="comment">//返回由指定数组支持的固定大小的列表</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;java&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;javaee&quot;</span>); <span class="comment">//UnsupportedOperationException</span></span><br><span class="line">list.remove(<span class="string">&quot;world&quot;</span>); <span class="comment">//UnsupportedOperationException</span></span><br><span class="line">list.set(<span class="number">1</span>,<span class="string">&quot;javaee&quot;</span>);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>List接口中有一个静态方法： </p>
<ul>
<li>public static List <strong>of</strong>(E… elements)：返回包含任意数量元素的不可变列表</li>
<li>返回的集合不能做增删改操作<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">of</span><span class="params">(E... elements)</span>：<span class="comment">//返回包含任意数量元素的不可变列表</span></span><br><span class="line">List&lt;String&gt; list = List.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;javaee&quot;</span>);<span class="comment">//UnsupportedOperationException</span></span><br><span class="line">list.remove(<span class="string">&quot;java&quot;</span>);<span class="comment">//UnsupportedOperationException</span></span><br><span class="line">list.set(<span class="number">1</span>,<span class="string">&quot;javaee&quot;</span>);<span class="comment">//UnsupportedOperationException</span></span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Set接口中有一个静态方法： </p>
<ul>
<li>public static Set <strong>of</strong>(E… elements) ：返回一个包含任意数量元素的不可变集合</li>
<li>在给元素的时候，不能给重复的元素</li>
<li>返回的集合不能做增删操作，没有修改的方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="title function_">of</span><span class="params">(E... elements)</span> ：<span class="comment">//返回一个包含任意数量元素的不可变集合</span></span><br><span class="line">Set&lt;String&gt; set = Set.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;java&quot;</span>,<span class="string">&quot;world&quot;</span>);<span class="comment">//IllegalArgumentException</span></span><br><span class="line">Set&lt;String&gt; set = Set.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;java&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;javaee&quot;</span>);<span class="comment">//UnsupportedOperationException</span></span><br><span class="line">set.remove(<span class="string">&quot;world&quot;</span>);<span class="comment">//UnsupportedOperationException</span></span><br><span class="line">System.out.println(set);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="1-6-对象内存图"><a href="#1-6-对象内存图" class="headerlink" title="1.6 对象内存图"></a>1.6 对象内存图</h2><ul>
<li><strong>成员变量</strong>使用过程</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697200484068-46fe8cfa-d4b1-44d2-9b35-034813be38e4.png#averageHue=%23f5f3c2&clientId=uef60bb95-3f71-4&id=WI3Pj&originHeight=318&originWidth=749&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0647274f-a895-40ce-9feb-9b630d03f92&title="></p>
<ul>
<li><strong>成员方法</strong>调用过程</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697203348688-d0facadb-a4ce-4b55-b69e-77bdc977bb77.png#averageHue=%23f0e9bb&clientId=uef60bb95-3f71-4&id=Pu5ej&originHeight=244&originWidth=695&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5290bde1-50b8-4227-94db-e96b13238f6&title="><br>注：多个对象在堆内存中，都有不同的内存划分，成员变量存储在各自的内存区域中，成员方法多个对象共用的一份。</p>
<h1 id="2、面向对象"><a href="#2、面向对象" class="headerlink" title="2、面向对象"></a>2、面向对象</h1><h2 id="2-1-封装"><a href="#2-1-封装" class="headerlink" title="2.1 封装"></a>2.1 封装</h2><p>:::tips<br><strong>封装：</strong>是面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作的 ；</p>
<ul>
<li><strong>原则：</strong>将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问：成员变量private，提供对应的getXxx()&#x2F;setXxx()方法 ；</li>
<li><strong>好处：</strong>通过方法来控制成员变量的操作，提高了代码的安全性 把代码用方法进行封装，提高了代码的复用性；<br>:::</li>
</ul>
<h2 id="2-2-继承"><a href="#2-2-继承" class="headerlink" title="2.2 继承"></a>2.2 继承</h2><p>:::tips<br><strong>继承：</strong>继承可以让类与类之间产生关系，子类则可以<strong>使用父类中非私有的成员</strong>（extends）</p>
<ul>
<li><strong>优点</strong>：<ul>
<li>提高代码的<strong>复用性</strong>(多个类相同的成员可以放到同一个类中)</li>
<li>提高代码的<strong>维护性</strong>(如果方法的代码需要修改，修改一处即可)</li>
</ul>
</li>
<li><strong>弊端</strong>：继承让类与类之间产生了关系，<strong>类的耦合性增强</strong>，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性<br>:::</li>
</ul>
<ol>
<li>继承中变量的<strong>访问特点（就近原则）</strong>：<ul>
<li>子类局部 —&gt; 子类成员 —&gt; 父类成员(不考虑父亲的父亲…)</li>
</ul>
</li>
<li><strong>super关键字</strong><br>:::tips<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697199880884-3b332489-cfc3-463c-a72f-24c4f5a319d7.png#averageHue=%23f3e3ca&clientId=uef60bb95-3f71-4&id=A2Lrx&originHeight=321&originWidth=765&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5ae34483-c82a-4b47-83a0-5e766abf216&title="></li>
</ol>
<ul>
<li>super.成员变量 - 访问父类成员变量</li>
<li>super.成员方法 - 访问父类成员方法</li>
<li>super(…) - 访问父类构造方法<br>:::</li>
</ul>
<h2 id="2-3-多态"><a href="#2-3-多态" class="headerlink" title="2.3 多态"></a>2.3 多态</h2><p>:::tips<br><strong>多态：</strong>同一个对象，在不同时刻表现出来的不同形态（前提条件：有继承&#x2F;实现关系、有方法重写、父类引用指向子类对象  Animal animal1 &#x3D; new Dog();）</p>
<ul>
<li><strong>优缺点：</strong><ul>
<li><strong>优点：提高程序的扩展性。</strong>定义方法时候，使用<strong>父类型作为参数</strong>，在使用的时候，使用<strong>具体的子类型参与操作；</strong></li>
<li><strong>弊端：不能使用子类的特有成员</strong>，基于弊端，因此我们不需要在子类中定义成员方法</li>
</ul>
</li>
<li><strong>编译原则：</strong><ul>
<li><strong>成员变量</strong>：编译看父类，运行看父类 </li>
<li><strong>成员方法</strong>：编译看父类，运行看子类</li>
</ul>
</li>
<li><strong>多态形式：</strong><ul>
<li><strong>编译时多态（静态多态）：</strong>通过方法的重载实现，即在同一类中定义多个同名的方法，但参数列表不同。根据调用时传递的参数类型，编译器在编译阶段就可以确定调用的方法，并进行静态绑定。</li>
<li><strong>运行时多态（动态多态）：</strong>通过方法的覆盖实现，即子类重写父类的方法，且方法签名完全一致。通过父类或接口的引用变量指向子类对象时，根据实际对象的类型进行动态绑定，即在运行时根据对象的实际类型确定调用的方法。<br> :::<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal is making a sound.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> / Cat <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog is barking.&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat is meowing.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        animal1.makeSound(); <span class="comment">// 输出：Dog is barking.</span></span><br><span class="line">        animal2.makeSound(); <span class="comment">// 输出：Cat is meowing.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="3、常用API"><a href="#3、常用API" class="headerlink" title="3、常用API"></a>3、常用API</h1><p>API (Application Programming Interface) ：应用程序编程接口</p>
<h2 id="3-1-String类-⭐"><a href="#3-1-String类-⭐" class="headerlink" title="3.1 String类 ⭐"></a>3.1 String类 ⭐</h2><ul>
<li>java.lang包下的类<blockquote>
<p>String构造方法</p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String()</td>
<td>创建一个空白字符串对象，不含有任何内容</td>
</tr>
<tr>
<td>public String(char[] chs)</td>
<td>根据字符数组的内容，来创建字符串对象</td>
</tr>
<tr>
<td>public String(byte[] bys)</td>
<td>根据字节数组的内容，来创建字符串对象</td>
</tr>
<tr>
<td>String s &#x3D; “abc”;</td>
<td>直接赋值的方式创建字符串对象，内容就是abc</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>String常用方法</strong></p>
</blockquote>
<ol>
<li><p><strong>与“长度”有关</strong></p>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>length()</td>
<td>得到一个字符串的<strong>字符个数</strong></td>
</tr>
</tbody></table>
</li>
<li><p><strong>与“数组”有关</strong></p>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>byte[]</td>
<td>getBytes()</td>
<td>将一个字符串转换成<strong>字节数组</strong></td>
</tr>
<tr>
<td>char[]</td>
<td>toCharArray()</td>
<td>将一个字符串转换成<strong>字符数组</strong></td>
</tr>
<tr>
<td>String[]</td>
<td>split(String)</td>
<td>将一个字符串<strong>按照指定内容分开</strong></td>
</tr>
</tbody></table>
</li>
<li><p><strong>与“判断”有关</strong></p>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>equals(String)</td>
<td>判断<strong>两个字符串的内容</strong></td>
</tr>
<tr>
<td>boolean</td>
<td>equalsIgnoreCase(String)</td>
<td>判断<strong>两个字符串的内容</strong>（忽略大小写）</td>
</tr>
<tr>
<td>boolean</td>
<td>contains(String)</td>
<td>判断一个字符串里面<strong>是否包含指定的内容</strong></td>
</tr>
<tr>
<td>boolean</td>
<td>startsWith(String)</td>
<td>判断一个字符串是否<strong>以指定的内容开头</strong></td>
</tr>
<tr>
<td>boolean</td>
<td>endsWith(String)</td>
<td>判断一个字符串是否<strong>以指定的内容结尾</strong></td>
</tr>
</tbody></table>
</li>
<li><p><strong>与“修改内容”有关</strong></p>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td>toUpperCase()</td>
<td>将一个字符串全部转换成大写</td>
</tr>
<tr>
<td>String</td>
<td>toLowerCase()</td>
<td>将一个字符串全部转换成小写</td>
</tr>
<tr>
<td>String</td>
<td>replace(String,String)</td>
<td>将某个内容全部替换成指定内容</td>
</tr>
<tr>
<td>String</td>
<td>replaceAll(String,String)</td>
<td>将某个内容全部替换成指定内容【支持正则】</td>
</tr>
<tr>
<td>String</td>
<td>repalceFirst(String,String)</td>
<td>将第一次出现的某个内容替换成指定的内容</td>
</tr>
<tr>
<td>String</td>
<td>substring(int)</td>
<td>从指定下标开始一直<strong>截取</strong>到字符串的最后</td>
</tr>
<tr>
<td>String</td>
<td>substring(int,int)</td>
<td>从下标x<strong>截取</strong>到下标y-1对应的元素</td>
</tr>
<tr>
<td>String</td>
<td>trim()</td>
<td>去除一个字符串的前后空格</td>
</tr>
</tbody></table>
</li>
<li><p><strong>与”位置“有关</strong></p>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>charAt(int)</td>
<td>得到指定下标位置对应的字符</td>
</tr>
<tr>
<td>int</td>
<td>indexOf(String)</td>
<td>得到指定内容第一次出现的下标</td>
</tr>
<tr>
<td>int</td>
<td>lastIndexOf(String)</td>
<td>得到指定内容最后一次出现的下标</td>
</tr>
</tbody></table>
</li>
</ol>
<blockquote>
<p>字符串的比较</p>
</blockquote>
<ul>
<li>&#x3D;&#x3D;号的作用<ul>
<li>比较<strong>基本</strong>数据类型：比较的是<strong>具体的值</strong></li>
<li>比较<strong>引用</strong>数据类型：比较的是<strong>对象地址值（相比值使用equals方法）</strong></li>
</ul>
</li>
</ul>
<h2 id="3-2-StringBuilder类-⭐"><a href="#3-2-StringBuilder类-⭐" class="headerlink" title="3.2 StringBuilder类 ⭐"></a>3.2 StringBuilder类 ⭐</h2><p>StringBuilder 是一个可变的字符串类，我们可以把它看成是一个容器，这里的可变指的是 StringBuilder 对象中的内容是可变的<br>:::tips</p>
<ul>
<li><p>StringBuilder类和String类的区别 </p>
<ul>
<li>String类：内容是不可变的</li>
<li>StringBuilder类：内容是可变的<br> :::</li>
</ul>
</li>
<li><p>构造方法 </p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>StringBuilder()</td>
<td>创建一个空白可变字符串对象，不含有任何内容</td>
</tr>
<tr>
<td>StringBuilder(String str)</td>
<td>根据字符串的内容，来创建可变字符串对象</td>
</tr>
</tbody></table>
</li>
<li><p>常用的方法</p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>StringBuilder</td>
<td>append (T)</td>
<td>添加数据，并返回对象本身</td>
</tr>
<tr>
<td>StringBuilder</td>
<td>reverse()</td>
<td>返回相反的字符序列</td>
</tr>
<tr>
<td>int</td>
<td>length()</td>
<td>返回长度，实际存储值</td>
</tr>
<tr>
<td>String</td>
<td>toString()</td>
<td>StringBuilder转换为String</td>
</tr>
</tbody></table>
</li>
</ul>
<blockquote>
<p>StringBuilder和String相互转换</p>
</blockquote>
<ul>
<li><p>StringBuilder转换为String：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br></pre></td></tr></table></figure>
</li>
<li><p>String转换为StringBuilder：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-3-Math-System类"><a href="#3-3-Math-System类" class="headerlink" title="3.3 Math &#x2F; System类"></a>3.3 Math &#x2F; System类</h2><p>概述：基本数字运算</p>
<ul>
<li>调用方式：Math类中无构造方法，但内部的方法都是静态的，则可以通过类名进行调用。</li>
</ul>
<ol>
<li><p>**Math类常用方法 **</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static int <strong>abs</strong>(int a)</td>
<td>返回参数的绝对值</td>
</tr>
<tr>
<td>public static double <strong>ceil</strong>(double a)</td>
<td>返回大于或等于参数的最小double值，等于一个整数</td>
</tr>
<tr>
<td>public static double <strong>floor</strong>(double a)</td>
<td>返回小于或等于参数的最大double值，等于一个整数</td>
</tr>
<tr>
<td>public static int <strong>round</strong>(float a)</td>
<td>按照四舍五入返回最接近参数的int</td>
</tr>
<tr>
<td>public static int <strong>max</strong>(int a,int b)</td>
<td>返回两个int值中的较大值</td>
</tr>
<tr>
<td>public static int <strong>min</strong>(int a,int b)</td>
<td>返回两个int值中的较小值</td>
</tr>
<tr>
<td>public static double <strong>pow</strong> (double a,double b)</td>
<td>返回a的b次幂的值</td>
</tr>
<tr>
<td>public static double <strong>random</strong>()</td>
<td>返回值为double的正值，[0.0,1.0)</td>
</tr>
</tbody></table>
</li>
<li><p><strong>System类的常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static void exit(int status)</td>
<td>终止当前运行的 Java 虚拟机，非零表示异常终止</td>
</tr>
<tr>
<td>public static long currentTimeMillis()</td>
<td>返回当前时间(以毫秒为单位)</td>
</tr>
</tbody></table>
</li>
</ol>
<ul>
<li>需求：在控制台输出1-10000，计算这段代码执行了多少毫秒<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取开始的时间节点</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 获取代码运行结束后的时间节点</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">&quot;共耗时：&quot;</span> + (end ­ start) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-4-包装类"><a href="#3-4-包装类" class="headerlink" title="3.4 包装类"></a>3.4 包装类</h2><ul>
<li>作用：将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据，常用的操作之一：用于<strong>基本数据类型</strong>与<strong>字符串</strong>之间的转换 </li>
<li>除了int变为Integer、char变成Character之外，其他都是开头改大写变成包装类</li>
</ul>
<p><strong>Integer类概述：</strong>包装一个对象中的原始类型 int 的值</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static Integer valueOf(int i)</td>
<td>返回表示指定的 int 值的 Integer 实例</td>
</tr>
<tr>
<td>public static Integer valueOf(String s)</td>
<td>返回一个保存指定值的 Integer 对象 String</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.valueOf(<span class="string">&quot;100&quot;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>int和String类型的相互转换</p>
</blockquote>
<ul>
<li><p>**int转换成String **</p>
<ul>
<li>方法一：直接在数字后加一个空字符串</li>
<li><strong>方法二</strong>：通过String类静态方法<strong>valueOf()</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> number + <span class="string">&quot;&quot;</span>; <span class="comment">//方式1</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> String.valueOf(number); <span class="comment">//方式2</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**String转换成int **</p>
<ul>
<li>方法一：先将字符串数字转成Integer，再调用valueOf()方法</li>
<li><strong>方式二</strong>：通过Integer静态方法**parseInt()**进行转换<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;100&quot;</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(s); <span class="comment">//方式1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">s1</span> <span class="operator">=</span> i.intValue();</span><br><span class="line"><span class="type">int</span> <span class="variable">s2</span> <span class="operator">=</span> Integer.parseInt(s); <span class="comment">//方式2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>自动拆箱和自动装箱</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>自动装箱</strong>：把基本数据类型转换为对应的包装类类型 </p>
</li>
<li><p>** 自动拆箱**：把包装类类型转换为对应的基本数据类型 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 自动装箱</span></span><br><span class="line">i += <span class="number">200</span>; <span class="comment">// i + 200 自动拆箱；注意：i=i+200 是自动装箱</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-5-Date-Calender类"><a href="#3-5-Date-Calender类" class="headerlink" title="3.5 Date &#x2F; Calender类"></a>3.5 Date &#x2F; Calender类</h2><blockquote>
<p>1、Date类</p>
</blockquote>
<p>概述：Date 代表了一个特定的时间，精确到毫秒 </p>
<ul>
<li>Date构造方法 <table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Date()</td>
<td>分配一个 Date对象，并初始化，以便它代表它被分配的时间，精确到毫秒</td>
</tr>
<tr>
<td>public Date(long date)</td>
<td>分配一个 Date对象，并将其初始化为表示从<strong>标准基准时间</strong>起指定的毫秒数（Thu Jan 01 08:00:00 CST 1970）</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();<span class="comment">//Sun Jan 29 16:23:30 CST 2023</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">date</span> <span class="operator">=</span> <span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>;</span><br><span class="line"><span class="type">Date</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(date); <span class="comment">//Thu Jan 01 09:00:00 CST 1970</span></span><br></pre></td></tr></table></figure>

<ul>
<li>常用方法<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public long getTime()</td>
<td>获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值</td>
</tr>
<tr>
<td>public void setTime(long time)</td>
<td>设置时间，给的是毫秒值</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">//创建日期对象</span></span><br><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">d.setTime(time);</span><br><span class="line">System.out.println(d); <span class="comment">//now</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>2、SimpleDateFormat类</p>
</blockquote>
<p>概述：SimpleDateFormat是一个具体的类，用于以区域设置敏感的方式格式化和解析日期。我们重点学习<strong>日期格式化</strong>和<strong>解析。</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public final String <strong>format</strong>(Date date)</td>
<td><strong>Date</strong>转换成<strong>String</strong></td>
</tr>
<tr>
<td>public Date <strong>parse</strong>(String source)</td>
<td><strong>String</strong>转换成<strong>Date</strong></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式化：从 Date 到 String</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sdf.format(d); <span class="comment">//2023年01月29日 16:36:27</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从 String 到 Date</span></span><br><span class="line"><span class="type">String</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="string">&quot;2048-08-09 11:11:11&quot;</span>;</span><br><span class="line"><span class="comment">//ParseException</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">dd</span> <span class="operator">=</span> sdf2.parse(ss); <span class="comment">//Sun Aug 09 11:11:11 CST 2048</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>3、自定义DateUtils日期工具类</p>
</blockquote>
<p>定义一个日期工具类(DateUtils)，包含两个方法：把日期转换为指定格式的字符串；把字符串解析为指定格式 的日期，然后定义一个测试类(DateDemo)，测试日期工具类的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DateUtils</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    把日期转为指定格式的字符串</span></span><br><span class="line"><span class="comment">    返回值类型：String</span></span><br><span class="line"><span class="comment">    参数：Date date, String format</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">dateToString</span><span class="params">(Date date, String format)</span> &#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(format);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sdf.format(date);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    把字符串解析为指定格式的日期</span></span><br><span class="line"><span class="comment">    返回值类型：Date</span></span><br><span class="line"><span class="comment">    参数：String s, String format</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">stringToDate</span><span class="params">(String s, String format)</span> <span class="keyword">throws</span></span><br><span class="line">        ParseException &#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(format);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> sdf.parse(s);</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">//创建日期对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> DateUtils.dateToString(d, <span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> DateUtils.dateToString(d, <span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> DateUtils.dateToString(d, <span class="string">&quot;HH:mm:ss&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;2048-08-09 12:12:12&quot;</span>;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">dd</span> <span class="operator">=</span> DateUtils.stringToDate(s, <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>4、Calender日历类</p>
</blockquote>
<p>概述：Calendar 为特定瞬间与一组日历字段之间的转换提供了一些方法，并为操作日历字段提供了一些方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Calendar.getInstance();</td>
<td>提供 Calendar 实例</td>
</tr>
<tr>
<td>public int <strong>get</strong>(int field)</td>
<td>返回给定日历字段的值</td>
</tr>
<tr>
<td>public abstract void <strong>add</strong>(int field, int amount)</td>
<td>根据日历的规则，将指定的时间量添加或减去给定的日历字段</td>
</tr>
<tr>
<td>public final void <strong>set</strong>(int year,int month,int date)</td>
<td>设置当前日历的年月日</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二月天案例：获取任意一年的二月有多少天</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalendarTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入年：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        </span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance(); <span class="comment">//设置日历对象的年、月、日</span></span><br><span class="line">        c.set(year, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        c.add(Calendar.DATE, -<span class="number">1</span>); <span class="comment">//3月1日往前推一天，就是2月的最后一天</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">date</span> <span class="operator">=</span> c.get(Calendar.DATE); <span class="comment">//获取这一天输出即可</span></span><br><span class="line">        System.out.println(year + <span class="string">&quot;年的2月份有&quot;</span> + date + <span class="string">&quot;天&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4、泛型"><a href="#4、泛型" class="headerlink" title="4、泛型"></a>4、泛型</h1><ul>
<li><p>概述：泛型是<strong>JDK5</strong>中引入的特性，它提供了<strong>编译时类型安全检测机制</strong>，该机制允许在编译时检测到非法的类型 它的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。一提到参数，最熟悉的就是定义方 法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，然后在使用&#x2F;调用时传入具体的类型。这种参数类型可以用在类、方法和接口中，分别被称为**泛型类、泛型方法、泛型接口 **<br>:::tips</p>
</li>
<li><p><strong>泛型定义格式：</strong></p>
<ul>
<li>&lt;类型&gt;：指定一种类型的格式。这里的类型可以看成是形参</li>
<li>&lt;类型1,类型2…&gt;：指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看成是形参</li>
<li>将来具体调用时候给定的类型可以看成是实参，并且实参的类型只能是引用数据类型</li>
</ul>
</li>
<li><p>**泛型的好处 **</p>
<ul>
<li>把运行时期的问题提前到了编译期间</li>
<li>避免了强制类型转换<br> :::</li>
</ul>
</li>
</ul>
<ol>
<li><p><strong>泛型类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 class 类名&lt;类型&gt; &#123; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getT</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setT</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Generic&lt;String&gt; g1 = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;String&gt;();</span><br><span class="line">Generic&lt;Integer&gt; g2 = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>泛型方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 &lt;类型&gt; 返回值类型 方法名(类型 变量名) &#123; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Generic</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Generic</span>();</span><br><span class="line">g.show(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">g.show(<span class="number">30</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>泛型接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 interface 接口名&lt;类型&gt; &#123; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generic</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generic</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Generic&lt;String&gt; g1 = <span class="keyword">new</span> <span class="title class_">GenericImpl</span>&lt;String&gt;();</span><br><span class="line">g1.show(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">Generic&lt;Integer&gt; g2 = <span class="keyword">new</span> <span class="title class_">GenericImpl</span>&lt;Integer&gt;();</span><br><span class="line">g2.show(<span class="number">30</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>类型通配符</strong></p>
</li>
</ol>
<ul>
<li><p>作用：为了表示各种泛型List的父类，可以使用类型通配符<br>:::tips<br><strong>类型通配符的分类：</strong></p>
</li>
<li><p>**类型通配符：&lt;?&gt; **</p>
<ul>
<li>List&lt;?&gt;：表示元素类型未知的List，它的元素可以匹配任何的类型</li>
<li>这种带通配符的List仅表示它是各种泛型List的父类，并不能把元素添加到其中</li>
</ul>
</li>
<li><p>**类型通配符上限： &lt;? extends 类型&gt; **</p>
<ul>
<li>List&lt;? extends Number&gt;：它表示的类型是Number或者其子类型</li>
</ul>
</li>
<li><p>**类型通配符下限： &lt;? super 类型&gt; **</p>
<ul>
<li>List&lt;? super Number&gt; ：它表示的类型是Number或者其父类型<br> :::<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类型通配符：&lt;?&gt;</span></span><br><span class="line">List&lt;?&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">List&lt;?&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line">List&lt;?&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//类型通配符上限：&lt;? extends 类型&gt;</span></span><br><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; list5 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; list6 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//类型通配符下限：&lt;? super 类型&gt;</span></span><br><span class="line">List&lt;? <span class="built_in">super</span> Number&gt; list7 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">List&lt;? <span class="built_in">super</span> Number&gt; list8 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line"><span class="comment">// List&lt;? super Number&gt; list9 = new ArrayList&lt;Integer&gt;();</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="5、异常-⭐"><a href="#5、异常-⭐" class="headerlink" title="5、异常 ⭐"></a>5、异常 ⭐</h1><ul>
<li><strong>父类 Throwable：</strong>Throwable 是 Java 异常体系的顶级父类，它具有两个重要的子类，即 Exception 和 Error</li>
<li><strong>异常 Error：</strong>Error 是严重的错误，表示 JVM 或底层系统发生的不可恢复的错误。Error 类型的异常通常不被捕获或声明抛出。</li>
<li><strong>错误 Exception：</strong>Exception 是可被检查的异常，表示程序在正常运行时遇到的非预期情况。Exception 类型的异常需要通过捕获或声明抛出来处理。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1696662064627-4eaef782-aa66-4c90-8930-45e888de648a.png#averageHue=%23f4f3ee&clientId=uff5592ff-7738-4&from=drop&id=ud9e6568e&originHeight=485&originWidth=969&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=175405&status=done&style=none&taskId=u0e5a0331-1809-46cb-93f0-c83eea27263&title=" alt="74c5a727d11d1c36f75c9422f38e326a.png"><br>:::tips</p>
<ul>
<li><strong>编译时异常</strong> （都是Exception类及其子类）<ul>
<li>必须显示处理，否则程序就会发生错误，无法通过编译</li>
</ul>
</li>
<li><strong>运行时异常</strong> （都是RuntimeException类及其子类）<ul>
<li>无需显示处理，也可以和编译时异常一样处理<br> :::<br> <img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1694220597665-4d144d12-8d59-4ea2-9200-b359493466a1.png#averageHue=%23f2fcf4&from=url&id=tfZxQ&originHeight=661&originWidth=936&originalType=binary&ratio=1&rotation=0&showTitle=false&size=148307&status=done&style=none&title=" alt="mmexport1694220539925.png"></li>
</ul>
</li>
</ul>
<ol>
<li><p><strong>try-catch方式处理异常：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    可能出现异常的代码;</span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类名 变量名) &#123;</span><br><span class="line">    异常的处理代码;</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    执行完上面的一定执行的代码；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Throwable成员方法</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String getMessage()</td>
<td>返回此 throwable 的详细消息字符串</td>
</tr>
<tr>
<td>public String toString()</td>
<td>返回此可抛出的简短描述</td>
</tr>
<tr>
<td>public void printStackTrace()</td>
<td>把异常的错误信息输出在控制台</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="5-1-throw-throws"><a href="#5-1-throw-throws" class="headerlink" title="5.1 throw&#x2F;throws"></a>5.1 throw&#x2F;throws</h2><p><strong>throws和throw的区别：</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697187691766-f90aa803-1b56-4462-b99c-0fb7a1d6eddb.png#averageHue=%23ececec&clientId=ud965fb95-e94f-4&id=KSu5L&originHeight=131&originWidth=771&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3dbb7db9-3bfb-4526-ae2d-9df6b0ed7ae&title="></p>
<ol>
<li><p><strong>throw 处理异常：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">menthod</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;年龄不能小于18岁！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>throws 处理异常：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">menthod</span><span class="params">()</span> <span class="keyword">throws</span> 异常类名 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编译时异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;2048-08-09&quot;</span>;</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">    <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> sdf.parse(s);</span><br><span class="line">    System.out.println(d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行时异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> ArrayIndexOutOfBoundsException &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="5-2-自定义异常"><a href="#5-2-自定义异常" class="headerlink" title="5.2 自定义异常"></a>5.2 自定义异常</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScoreException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ScoreException</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ScoreException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkScore</span><span class="params">(<span class="type">int</span> score)</span> <span class="keyword">throws</span> ScoreException &#123;</span><br><span class="line">        <span class="keyword">if</span>(score&lt;<span class="number">0</span> || score&gt;<span class="number">100</span>) &#123;</span><br><span class="line">            <span class="comment">// throw new ScoreException();</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ScoreException</span>(<span class="string">&quot;你给的分数有误，分数应该在0-100之间&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;成绩正常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6、反射-⭐"><a href="#6、反射-⭐" class="headerlink" title="6、反射 ⭐"></a>6、反射 ⭐</h1><p>:::tips<br>是指在运行时去获取一个<strong>类的变量&#x2F;方法信息</strong>。然后通过<strong>获取到的信息来创建对象</strong>，调用方法的一种机制。 由于这种动态性，可以极大的增强程序的灵活性，程序不用在编译期就完成确定，在运行期仍然可以扩展<br>:::</p>
<h2 id="6-1-获取Class类对象的三种方法"><a href="#6-1-获取Class类对象的三种方法" class="headerlink" title="6.1 获取Class类对象的三种方法"></a>6.1 获取Class类对象的三种方法</h2><ul>
<li>类名.class属性</li>
<li>对象名.getClass()方法</li>
<li>Class.forName(全类名)方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">//使用类的class属性来获取该类对应的Class对象</span></span><br><span class="line">    Class&lt;Student&gt; c1 = Student.class;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用对象的getClass()方法，返回该对象所属类对应的Class对象</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Student</span>&gt; c3 = s.getClass();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用Class类中的静态方法forName(String className)</span></span><br><span class="line">    Class&lt;?&gt; c4 = Class.forName(<span class="string">&quot;com.itheima_02.Student&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-2-Class类反射获取属性"><a href="#6-2-Class类反射获取属性" class="headerlink" title="6.2 Class类反射获取属性"></a>6.2 Class类反射获取属性</h2><p>:::tips<br>Class类反射可以获取到（创建对象）：<strong>构造方法 &#x2F; 成员方法 &#x2F; 成员变量</strong><br>:::<br><strong>Class类反射获取：创建对象</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>T newInstance(Object…initargs)</td>
<td>根据指定的构造方法创建对象</td>
</tr>
</tbody></table>
<ol>
<li><strong>Class类反射获取：构造方法</strong><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>getConstructors()</td>
<td>返回所有公共构造方法对象的数组</td>
</tr>
<tr>
<td>getDeclaredConstructors()</td>
<td>返回所有构造方法对象的数组</td>
</tr>
<tr>
<td>getConstructor(Class… parameterTypes)</td>
<td>返回单个公共构造方法对象</td>
</tr>
<tr>
<td>getDeclaredConstructor(Class… parameterTypes)</td>
<td>返回单个构造方法对象</td>
</tr>
</tbody></table>
</li>
</ol>
<ul>
<li><p>案例1 ：通过反射获取<strong>公共的构造方法</strong>并创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Class对象</span></span><br><span class="line">Class&lt;?&gt; c = Class.forName(<span class="string">&quot;com.itheima_02.Student&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; con = c.getConstructor(String.class, <span class="type">int</span>.class,</span><br><span class="line">                                      String.class);</span><br><span class="line"><span class="comment">//基本数据类型也可以通过.class得到对应的Class类型</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> con.newInstance(<span class="string">&quot;林青霞&quot;</span>, <span class="number">30</span>, <span class="string">&quot;西安&quot;</span>);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure>
</li>
<li><p>案例2 ：通过反射获取<strong>私有构造方法</strong>并创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Class对象</span></span><br><span class="line">Class&lt;?&gt; c = Class.forName(<span class="string">&quot;com.itheima_02.Student&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; con = c.getDeclaredConstructor(String.class);</span><br><span class="line">con.setAccessible(<span class="literal">true</span>); <span class="comment">//取消访问检查-暴力反射</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> con.newInstance(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><strong>Class类反射获取：成员方法</strong><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Method[] getMethods()</td>
<td>返回所有公共成员方法对象的数组，包 括继承的</td>
</tr>
<tr>
<td>Method[] getDeclaredMethods()</td>
<td>返回所有成员方法对象的数组，不包括 继承的</td>
</tr>
<tr>
<td>Method getMethod(String name, Class… parameterTypes)</td>
<td>返回单个公共成员方法对象</td>
</tr>
<tr>
<td>Method getDeclaredMethod(String name, Class… parameterTypes)</td>
<td>返回单个成员方法对象</td>
</tr>
<tr>
<td>invoke(Object obj,Object… args)</td>
<td>调用obj对象的成员方法，参数是args,返回值是Object类型</td>
</tr>
</tbody></table>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Class对象</span></span><br><span class="line">Class&lt;?&gt; c = Class.forName(<span class="string">&quot;com.itheima_02.Student&quot;</span>);</span><br><span class="line"><span class="comment">//Method[] getMethods() 返回一个包含 方法对象的数组， 方法对象反映由该 Class对象表示的类或接口的所有公共方法，包括由类或接口声明的对象以及从超类和超级接口继承的类</span></span><br><span class="line"><span class="comment">//Method[] getDeclaredMethods() 返回一个包含 方法对象的数组， 方法对象反映由Class对象表示的类或接口的所有声明方法，包括public，protected，default（package）访问和私有方法，但不包括继承方法</span></span><br><span class="line">Method[] methods = c.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span>(Method method : methods) </span><br><span class="line">    System.out.println(method);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 返回一个 方法对象，该对象反映由该 Class对象表示的类或接口的指定公共成员方法</span></span><br><span class="line"><span class="comment">//Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) 返回一个方法对象，它反映此表示的类或接口的指定声明的方法 Class对象</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> c.getMethod(<span class="string">&quot;method1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取无参构造方法创建对象</span></span><br><span class="line">Constructor&lt;?&gt; con = c.getConstructor();</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> con.newInstance();</span><br><span class="line"><span class="comment">//Object invoke(Object obj, Object... args) 在具有指定参数的指定对象上调用此方法对象表示的基础方法</span></span><br><span class="line">m.invoke(obj);</span><br></pre></td></tr></table></figure>

<ul>
<li>案例1：通过<strong>反射获取成员方法</strong>并调用<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; c = Class.forName(<span class="string">&quot;com.itheima_02.Student&quot;</span>);<span class="comment">//获取Class对象</span></span><br><span class="line">Constructor&lt;?&gt; con = c.getConstructor();</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> con.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//s.method1();</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> c.getMethod(<span class="string">&quot;method1&quot;</span>);</span><br><span class="line">m1.invoke(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">//s.method2();</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m2</span> <span class="operator">=</span> c.getMethod(<span class="string">&quot;method2&quot;</span>, String.class);</span><br><span class="line">m2.invoke(obj,<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//s.method3();</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m3</span> <span class="operator">=</span> c.getMethod(<span class="string">&quot;method3&quot;</span>, String.class, <span class="type">int</span>.class);</span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> m3.invoke(obj, <span class="string">&quot;林青霞&quot;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//s.method4();</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m4</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;function&quot;</span>);</span><br><span class="line">m4.setAccessible(<span class="literal">true</span>);</span><br><span class="line">m4.invoke(obj);</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li><strong>Class类反射获取：成员变量</strong><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Field[] getFields()</td>
<td>返回所有公共成员变量对象的数组</td>
</tr>
<tr>
<td>Field[] getDeclaredFields()</td>
<td>返回所有成员变量对象的数组</td>
</tr>
<tr>
<td>Field getField(String name)</td>
<td>返回单个公共成员变量对象</td>
</tr>
<tr>
<td>Field getDeclaredField(String name)</td>
<td>返回单个成员变量对象</td>
</tr>
<tr>
<td>voidset(Object obj,Object value)</td>
<td>给obj对象的成员变量赋值为value</td>
</tr>
</tbody></table>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Class对象</span></span><br><span class="line">Class&lt;?&gt; c = Class.forName(<span class="string">&quot;com.itheima_02.Student&quot;</span>);</span><br><span class="line"><span class="comment">//Field[] getFields() 返回一个包含 Field对象的数组， Field对象反映由该 Class对象表示的类或接口的所有可访问的公共字段</span></span><br><span class="line"><span class="comment">//Field[] getDeclaredFields() 返回一个 Field对象的数组，反映了由该 Class对象表示的类或接口声明的所有字段</span></span><br><span class="line">Field[] fields = c.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span>(Field field : fields) </span><br><span class="line">    System.out.println(field);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Field getField(String name) 返回一个 Field对象，该对象反映由该 Class对象表示的类或接口的指定公共成员字段</span></span><br><span class="line"><span class="comment">//Field getDeclaredField(String name) 返回一个 Field对象，该对象反映由该Class对象表示的类或接口的指定声明字段</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">addressField</span> <span class="operator">=</span> c.getField(<span class="string">&quot;address&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取无参构造方法创建对象</span></span><br><span class="line">Constructor&lt;?&gt; con = c.getConstructor();</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> con.newInstance();</span><br><span class="line"><span class="comment">//Field提供有关类或接口的单个字段的信息和动态访问</span></span><br><span class="line"><span class="comment">//void set(Object obj, Object value) 将指定的对象参数中由此 Field对象表示的字段设置为指定的新值</span></span><br><span class="line">addressField.set(obj,<span class="string">&quot;西安&quot;</span>); <span class="comment">//给obj的成员变量addressField赋值为西安</span></span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure>

<ul>
<li>案例1：通过<strong>反射获取成员变量</strong>并赋值<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Class对象</span></span><br><span class="line">Class&lt;?&gt; c = Class.forName(<span class="string">&quot;com.itheima_02.Student&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; con = c.getConstructor();</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> con.newInstance();</span><br><span class="line">System.out.println(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">//s.name = &quot;林青霞&quot;;</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">nameField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">nameField.set(obj, <span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">System.out.println(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">//s.age = 30;</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">ageField</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">ageField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">ageField.set(obj,<span class="number">30</span>);</span><br><span class="line">System.out.println(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">//s.address = &quot;西安&quot;;</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">addressField</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;address&quot;</span>);</span><br><span class="line">addressField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">addressField.set(obj,<span class="string">&quot;西安&quot;</span>);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-3-反射案例"><a href="#6-3-反射案例" class="headerlink" title="6.3 反射案例"></a>6.3 反射案例</h2><p><strong>案例1-越过泛型检查：</strong>通过反射技术，向一个泛型为Integer的集合中添加一些字符串数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建集合</span></span><br><span class="line">ArrayList&lt;Integer&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// array.add(10);</span></span><br><span class="line"><span class="comment">// array.add(20);</span></span><br><span class="line"><span class="comment">// array.add(&quot;hello&quot;);</span></span><br><span class="line"></span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">ArrayList</span>&gt; c = array.getClass();</span><br><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> c.getMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">m.invoke(array,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">m.invoke(array,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">m.invoke(array,<span class="string">&quot;java&quot;</span>);</span><br><span class="line">System.out.println(array);</span><br></pre></td></tr></table></figure>
<p><strong>案例2：</strong>通过反射运行配置文件中指定类的指定方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载数据</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;myReflect\\class.txt&quot;</span>);</span><br><span class="line">prop.load(fr);</span><br><span class="line">fr.close();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">className=com.itheima_06.Student</span></span><br><span class="line"><span class="comment">methodName=study</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> prop.getProperty(<span class="string">&quot;className&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> prop.getProperty(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line"><span class="comment">//通过反射来使用</span></span><br><span class="line">Class&lt;?&gt; c = Class.forName(className);<span class="comment">//com.itheima_06.Student</span></span><br><span class="line">Constructor&lt;?&gt; con = c.getConstructor();</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> con.newInstance();</span><br><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> c.getMethod(methodName);<span class="comment">//study</span></span><br><span class="line">m.invoke(obj);</span><br></pre></td></tr></table></figure>

<h1 id="7、类加载器-⭐-o"><a href="#7、类加载器-⭐-o" class="headerlink" title="7、类加载器 ⭐ o"></a>7、类加载器 ⭐ o</h1><ol>
<li>Bootstrap ClassLoader（启动类加载器）：负责加载Java核心类库，比如rt.jar等。它是用C++实现的，并不继承自java.lang.ClassLoader。</li>
<li>Extension ClassLoader（扩展类加载器）：负责加载Java的扩展类库，主要加载jre&#x2F;lib&#x2F;ext或者被java.ext.dirs系统属性指定的目录中的类。</li>
<li>System ClassLoader（系统类加载器）：也称为应用程序类加载器，负责加载应用程序classpath下的类。</li>
</ol>
<p>这些内置类加载器按照父子关系组成了一个层次结构，ClassLoader通过委托机制来寻找并加载类。当一个类加载器收到加载请求时，它首先会尝试使用自己的类路径加载类，只有当找不到类时，它才会将加载请求委托给其父类加载器。<br>除了这些内置的类加载器，Java还提供了自定义类加载器的机制，可以通过继承java.lang.ClassLoader类来实现自定义的类加载器，并且可以通过调用ClassLoader的相关方法来加载、链接和实例化类。</p>
<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p>类加载概念：当需要使用某个类时，虚拟机将会加载它的”.class”文件，并创建对应的java.lang.Class对象，将class文件加载到虚拟机的内存<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697186662026-fced95e0-0035-4d46-9450-96a2d164aa7a.png#averageHue=%23f3f1f1&clientId=ufb8daf59-3664-4&from=drop&id=u7a168024&originHeight=317&originWidth=700&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=111731&status=done&style=none&taskId=ucfd2c7e5-85d9-447e-8196-a21171a835f&title=" alt="20170430160610299.png"></p>
<ul>
<li>类加载的描述 <ul>
<li>当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过类的加载，类的连接，类的初始 化这三个步骤来对类进行初始化。如果不出现意外情况，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载或者类初始化</li>
</ul>
</li>
<li>类的加载</li>
<li>就是指将class文件读入内存，并为之创建一个 java.lang.Class 对象</li>
<li>任何类被使用时，系统都会为之建立一个 java.lang.Class 对象</li>
<li>类的连接 <ul>
<li><strong>验证阶段</strong>：用于检验被加载的类是否有正确的内部结构，并和其他类协调一致</li>
<li><strong>准备阶段</strong>：负责为类的类变量分配内存，并设置默认初始化值</li>
<li><strong>解析阶段</strong>：将类的二进制数据中的符号引用替换为直接引用</li>
</ul>
</li>
<li>类的初始化 <ul>
<li>在该阶段，主要就是对类变量进行初始化</li>
</ul>
</li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><blockquote>
<p>1、类加载器的作用</p>
</blockquote>
<ul>
<li>负责将.class文件加载到内存中，并为之生成对应的 java.lang.Class 对象。</li>
</ul>
<blockquote>
<p>2、JVM的类加载机制</p>
</blockquote>
<ul>
<li>全盘负责：就是当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li>
<li>父类委托：就是当一个类加载器负责加载某个Class时，先让父类加载器试图加载该Class，只有在父类加载器 无法加载该类时才尝试从自己的类路径中加载该类</li>
<li>缓存机制：保证所有加载过的Class都会被缓存，当程序需要使用某个Class对象时，类加载器先从缓存区中搜索该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存储到缓存区</li>
</ul>
<blockquote>
<p>3、Java中的内置类加载器</p>
</blockquote>
<ul>
<li><strong>Bootstrap class loader</strong>：它是虚拟机的内置类加载器，通常表示为null ，并且没有父null</li>
<li><strong>Platform class loader</strong>：平台类加载器可以看到所有平台类 ，平台类包括由平台类加载器或其祖先定义的Java SE平台API，其实现类和JDK特定的运行时类</li>
<li><strong>System class loader</strong>：它也被称为应用程序类加载器 ，与平台类加载器不同。 系统类加载器通常用于定义应 用程序类路径，模块路径和JDK特定工具上的类</li>
<li>类加载器的继承关系：System的父加载器为Platform，而Platform的父加载器为Bootstrap</li>
</ul>
<blockquote>
<p>4、ClassLoader 中的两个方法</p>
</blockquote>
<ul>
<li>方法分类<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>static ClassLoader getSystemClassLoader()</td>
<td>返回用于委派的系统类加载器</td>
</tr>
<tr>
<td>ClassLoader getParent()</td>
<td>返回父类加载器进行委派</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//static ClassLoader getSystemClassLoader()：返回用于委派的系统类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">c</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(c); <span class="comment">//AppClassLoader</span></span><br><span class="line">        <span class="comment">//ClassLoader getParent()：返回父类加载器进行委派</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">c2</span> <span class="operator">=</span> c.getParent();</span><br><span class="line">        System.out.println(c2); <span class="comment">//PlatformClassLoader</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">c3</span> <span class="operator">=</span> c2.getParent();</span><br><span class="line">        System.out.println(c3); <span class="comment">//null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Lambda表达式-o"><a href="#Lambda表达式-o" class="headerlink" title="Lambda表达式 o"></a>Lambda表达式 o</h1><blockquote>
<p>1、体验Lambda表达式</p>
</blockquote>
<ul>
<li><p>案例需求<br>启动一个线程，在控制台输出一句话：多线程程序启动了 </p>
</li>
<li><p>实现方式一 </p>
<ul>
<li>实现步骤 <ul>
<li>定义一个类MyRunnable实现Runnable接口，重写run()方法</li>
<li>创建MyRunnable类的对象</li>
<li>创建Thread类的对象，把MyRunnable的对象作为构造参数传递</li>
<li>启动线程</li>
</ul>
</li>
</ul>
</li>
<li><p>实现方式二 </p>
<ul>
<li>匿名内部类的方式改进</li>
</ul>
</li>
<li><p>实现方式三 </p>
<ul>
<li>Lambda表达式的方式改进<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一的线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;多线程程序启动了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//方式一</span></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">my</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(my);</span><br><span class="line">        t.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方式二</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;多线程程序启动了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方式三</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>( () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;多线程程序启动了&quot;</span>);</span><br><span class="line">        &#125; ).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>函数式编程思想概述<br>函数式思想则尽量忽略面向对象的复杂语法：“强调做什么，而不是以什么形式去做”<br>而我们要学习的Lambda表达式就是函数式思想的体现</p>
</li>
</ul>
<blockquote>
<p>2、Lambda表达式的标准格式</p>
</blockquote>
<ul>
<li>格式：<br><strong>(形式参数) -&gt; {代码块}</strong> <ul>
<li>形式参数：如果有多个参数，参数之间用逗号隔开；如果没有参数，留空即可</li>
<li>-&gt;：由英文中画线和大于符号组成，固定写法。代表指向动作</li>
<li>代码块：是我们具体要做的事情，也就是以前我们写的方法体内容</li>
</ul>
</li>
<li>组成Lambda表达式的三要素： <ul>
<li>形式参数，箭头，代码块</li>
</ul>
</li>
</ul>
<h2 id="Lambda练习"><a href="#Lambda练习" class="headerlink" title="Lambda练习"></a>Lambda练习</h2><ol>
<li>Lambda练习1</li>
</ol>
<ul>
<li>Lambda表达式的使用前提 <ul>
<li>有一个接口</li>
<li>接口中有且仅有一个抽象方法</li>
</ul>
</li>
<li>练习描述<br>无参无返回值抽象方法的练习 </li>
<li>操作步骤 <ul>
<li>定义一个接口(Eatable)，里面定义一个抽象方法：void eat();</li>
<li>定义一个测试类(EatableDemo)，在测试类中提供两个方法 <ul>
<li>一个方法是：useEatable(Eatable e)</li>
<li>一个方法是主方法，在主方法中调用useEatable方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Eatable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EatableImpl</span> <span class="keyword">implements</span> <span class="title class_">Eatable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;一天一苹果，医生远离我&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EatableDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//在主方法中调用useEatable方法</span></span><br><span class="line">        <span class="type">Eatable</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EatableImpl</span>();</span><br><span class="line">        useEatable(e);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//匿名内部类</span></span><br><span class="line">        useEatable(<span class="keyword">new</span> <span class="title class_">Eatable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;一天一苹果，医生远离我&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Lambda表达式</span></span><br><span class="line">        useEatable(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;一天一苹果，医生远离我&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">useEatable</span><span class="params">(Eatable e)</span> &#123;</span><br><span class="line">        e.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li>Lambda练习2</li>
</ol>
<ul>
<li>练习描述<br>有参无返回值抽象方法的练习 </li>
<li>操作步骤 <ul>
<li>定义一个接口(Flyable)，里面定义一个抽象方法：void fly(String s);</li>
<li>定义一个测试类(FlyableDemo)，在测试类中提供两个方法 <ul>
<li>一个方法是：useFlyable(Flyable f)</li>
<li>一个方法是主方法，在主方法中调用useFlyable方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匿名内部类</span></span><br><span class="line">useFlyable(<span class="keyword">new</span> <span class="title class_">Flyable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        System.out.println(<span class="string">&quot;飞机自驾游&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lambda</span></span><br><span class="line">useFlyable((String s) -&gt; &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    System.out.println(<span class="string">&quot;飞机自驾游&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li>Lambda练习3</li>
</ol>
<ul>
<li>练习描述<br>有参有返回值抽象方法的练习 </li>
<li>操作步骤 <ul>
<li>定义一个接口(Addable)，里面定义一个抽象方法：int add(int x,int y);</li>
<li>定义一个测试类(AddableDemo)，在测试类中提供两个方法 <ul>
<li>一个方法是：useAddable(Addable a)</li>
<li>一个方法是主方法，在主方法中调用useAddable方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Addable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddableDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//在主方法中调用useAddable方法</span></span><br><span class="line">        useAddable((<span class="type">int</span> x,<span class="type">int</span> y) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">useAddable</span><span class="params">(Addable a)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a.add(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="省略模式和注意事项"><a href="#省略模式和注意事项" class="headerlink" title="省略模式和注意事项"></a>省略模式和注意事项</h2><ol>
<li>省略模式</li>
</ol>
<ul>
<li>省略的规则 <ul>
<li>参数类型可以省略。但是有多个参数的情况下，不能只省略一个</li>
<li>如果参数有且仅有一个，那么小括号可以省略</li>
<li>如果代码块的语句只有一条，可以省略大括号和分号，和return关键字<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Addable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">(String s)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// useAddable((int x,int y) -&gt; &#123;</span></span><br><span class="line">        <span class="comment">// return x + y;</span></span><br><span class="line">        <span class="comment">// &#125;);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//参数的类型可以省略</span></span><br><span class="line">        useAddable((x, y) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;);</span><br><span class="line">     </span><br><span class="line">        <span class="comment">// useFlyable((String s) -&gt; &#123;</span></span><br><span class="line">        <span class="comment">// System.out.println(s);</span></span><br><span class="line">        <span class="comment">// &#125;);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果参数有且仅有一个，那么小括号可以省略</span></span><br><span class="line">        <span class="comment">// useFlyable(s -&gt; &#123;</span></span><br><span class="line">        <span class="comment">// System.out.println(s);</span></span><br><span class="line">        <span class="comment">// &#125;);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果代码块的语句只有一条，可以省略大括号和分号</span></span><br><span class="line">        useFlyable(s -&gt; System.out.println(s));</span><br><span class="line">        <span class="comment">//如果代码块的语句只有一条，可以省略大括号和分号，如果有return，return也要省略掉</span></span><br><span class="line">        useAddable((x, y) -&gt; x + y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">useFlyable</span><span class="params">(Flyable f)</span> &#123;</span><br><span class="line">        f.fly(<span class="string">&quot;风和日丽，晴空万里&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">useAddable</span><span class="params">(Addable a)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a.add(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ol start="2">
<li>注意事项</li>
</ol>
<ul>
<li>使用Lambda必须要有接口，并且要求接口中有且仅有一个抽象方法 </li>
<li>必须有上下文环境，才能推导出Lambda对应的接口 <ul>
<li>根据局部变量的赋值得知Lambda对应的接口<br>Runnable r &#x3D; () -&gt; System.out.println(“Lambda表达式”); </li>
<li>根据调用方法的参数得知Lambda对应的接口<br>new Thread(() -&gt; System.out.println(“Lambda表达式”)).start();</li>
</ul>
</li>
</ul>
<blockquote>
<p>Lambda表达式和匿名内部类的区别</p>
</blockquote>
<ul>
<li>所需类型不同 <ul>
<li>匿名内部类：可以是接口，也可以是抽象类，还可以是具体类</li>
<li>Lambda表达式：只能是接口</li>
</ul>
</li>
<li>使用限制不同 <ul>
<li>如果接口中有且仅有一个抽象方法，可以使用Lambda表达式，也可以使用匿名内部类</li>
<li>如果接口中多于一个抽象方法，只能使用匿名内部类，而不能使用Lambda表达式</li>
</ul>
</li>
<li>实现原理不同 <ul>
<li>匿名内部类：编译之后，产生一个单独的.class字节码文件</li>
<li>Lambda表达式：编译之后，没有一个单独的.class字节码文件。对应的字节码会在运行的时候动态生成</li>
</ul>
</li>
</ul>
<h1 id="方法引用-o"><a href="#方法引用-o" class="headerlink" title="方法引用 o"></a>方法引用 o</h1><blockquote>
<p>1、概述</p>
</blockquote>
<ul>
<li>方法引用的出现原因<br>在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿参数做操作<br>那么考虑一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑呢？答案肯定是没有必要<br>那我们又是如何使用已经存在的方案的呢？<br>这就是我们要讲解的方法引用，我们是通过方法引用来使用已经存在的方案 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Printable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printString</span><span class="params">(String s)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintableDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//在主方法中调用usePrintable方法</span></span><br><span class="line">        <span class="comment">// usePrintable((String s) -&gt; &#123;</span></span><br><span class="line">        <span class="comment">// System.out.println(s);</span></span><br><span class="line">        <span class="comment">// &#125;);</span></span><br><span class="line">        <span class="comment">//Lambda简化写法</span></span><br><span class="line">        usePrintable(s -&gt; System.out.println(s));</span><br><span class="line">        <span class="comment">//方法引用</span></span><br><span class="line">        usePrintable(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">usePrintable</span><span class="params">(Printable p)</span> &#123;</span><br><span class="line">        p.printString(<span class="string">&quot;爱生活爱Java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>2、方法引用符</p>
</blockquote>
<ul>
<li>方法引用符<br><strong>::</strong> 该符号为引用运算符，而它所在的表达式被称为方法引用 </li>
<li>推导与省略 <ul>
<li>如果使用Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式， 它们都将被自动推导</li>
<li>如果使用方法引用，也是同样可以根据上下文进行推导</li>
<li>方法引用是Lambda的孪生兄弟</li>
</ul>
</li>
</ul>
<h2 id="引用类方法"><a href="#引用类方法" class="headerlink" title="引用类方法"></a>引用类方法</h2><p>引用类方法，其实就是引用类的静态方法</p>
<ul>
<li><p>格式<br>类名::静态方法 </p>
</li>
<li><p>范例<br>Integer::parseInt<br>Integer类的方法：public static int parseInt(String s) 将此String转换为int类型数据 </p>
</li>
<li><p>练习描述 </p>
<ul>
<li>定义一个接口(Converter)，里面定义一个抽象方法 int convert(String s);</li>
<li>定义一个测试类(ConverterDemo)，在测试类中提供两个方法 <ul>
<li>一个方法是：useConverter(Converter c) 、</li>
<li>一个方法是主方法，在主方法中调用useConverter方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Converter</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">convert</span><span class="params">(String s)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConverterDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//Lambda写法</span></span><br><span class="line">        useConverter(s -&gt; Integer.parseInt(s));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//引用类方法</span></span><br><span class="line">        useConverter(Integer::parseInt);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">useConverter</span><span class="params">(Converter c)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> c.convert(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">        System.out.println(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>使用说明<br>Lambda表达式被类方法替代的时候，它的形式参数全部传递给静态方法作为参数</p>
</li>
</ul>
<h2 id="引用对象的实例方法"><a href="#引用对象的实例方法" class="headerlink" title="引用对象的实例方法"></a>引用对象的实例方法</h2><p>引用对象的实例方法，其实就引用类中的成员方法</p>
<ul>
<li>格式<br>对象::成员方法 </li>
<li>范例<br>“HelloWorld”::toUpperCase<br>String类中的方法：public String toUpperCase() 将此String所有字符转换为大写 </li>
<li>练习描述 <ul>
<li>定义一个类(PrintString)，里面定义一个方法 </li>
<li>public void printUpper(String s)：把字符串参数变成大写的数据，然后在控制台输出 </li>
<li>定义一个接口(Printer)，里面定义一个抽象方法<br>void printUpperCase(String s) </li>
<li>定义一个测试类(PrinterDemo)，在测试类中提供两个方法 <ul>
<li>一个方法是：usePrinter(Printer p)</li>
<li>一个方法是主方法，在主方法中调用usePrinter方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintString</span> &#123;</span><br><span class="line">    <span class="comment">//把字符串参数变成大写的数据，然后在控制台输出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printUpper</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> s.toUpperCase();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printUpperCase</span><span class="params">(String s)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrinterDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//Lambda简化写法</span></span><br><span class="line">        usePrinter(s -&gt; System.out.println(s.toUpperCase()));</span><br><span class="line">        <span class="comment">//引用对象的实例方法</span></span><br><span class="line">        <span class="type">PrintString</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintString</span>();</span><br><span class="line">        usePrinter(ps::printUpper);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">usePrinter</span><span class="params">(Printer p)</span> &#123;</span><br><span class="line">        p.printUpperCase(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="引用类的实例方法"><a href="#引用类的实例方法" class="headerlink" title="引用类的实例方法"></a>引用类的实例方法</h2><p>引用类的实例方法，其实就是引用类中的成员方法</p>
<ul>
<li><p>格式<br>类名::成员方法 </p>
</li>
<li><p>范例<br>String::substring<br>public String substring(int beginIndex,int endIndex)<br>从beginIndex开始到endIndex结束，截取字符串。返回一个子串，子串的长度为endIndex-beginIndex </p>
</li>
<li><p>练习描述 </p>
<ul>
<li>定义一个接口(MyString)，里面定义一个抽象方法：<br>String mySubString(String s,int x,int y); </li>
<li>定义一个测试类(MyStringDemo)，在测试类中提供两个方法 <ul>
<li>一个方法是：useMyString(MyString my)</li>
<li>一个方法是主方法，在主方法中调用useMyString方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line">    String <span class="title function_">mySubString</span><span class="params">(String s,<span class="type">int</span> x,<span class="type">int</span> y)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStringDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//Lambda简化写法</span></span><br><span class="line">        useMyString((s,x,y) -&gt; s.substring(x,y));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//引用类的实例方法</span></span><br><span class="line">        useMyString(String::substring);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">useMyString</span><span class="params">(MyString my)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> my.mySubString(<span class="string">&quot;HelloWorld&quot;</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>使用说明<br>Lambda表达式被类的实例方法替代的时候 第一个参数作为调用者 后面的参数全部传递给该方法作为参数</p>
</li>
</ul>
<h2 id="引用构造器"><a href="#引用构造器" class="headerlink" title="引用构造器"></a>引用构造器</h2><p>引用构造器，其实就是引用构造方法</p>
<ul>
<li><p>l格式<br>类名::new </p>
</li>
<li><p>范例<br>Student::new </p>
</li>
<li><p>练习描述 </p>
<ul>
<li>定义一个<strong>类</strong>(Student)，里面有两个成员变量(name,age)<br>并提供无参构造方法和带参构造方法，以及成员变量对应的get和set方法 </li>
<li>定义一个<strong>接口</strong>(StudentBuilder)，里面定义一个抽象方法<br>Student build(String name,int age); </li>
<li>定义一个<strong>测试类</strong>(StudentDemo)，在测试类中提供两个方法 <ul>
<li>一个方法是：useStudentBuilder(StudentBuilder s)</li>
<li>一个方法是主方法，在主方法中调用useStudentBuilder方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentBuilder</span> &#123;</span><br><span class="line">    Student <span class="title function_">build</span><span class="params">(String name,<span class="type">int</span> age)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//Lambda简化写法</span></span><br><span class="line">        useStudentBuilder((name,age) -&gt; <span class="keyword">new</span> <span class="title class_">Student</span>(name,age));</span><br><span class="line">        <span class="comment">//引用构造器</span></span><br><span class="line">        useStudentBuilder(Student::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">useStudentBuilder</span><span class="params">(StudentBuilder sb)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> sb.build(<span class="string">&quot;林青霞&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        System.out.println(s.getName() + <span class="string">&quot;,&quot;</span> + s.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>使用说明<br>Lambda表达式被构造器替代的时候，它的形式参数全部传递给构造器作为参数</p>
</li>
</ul>
<h1 id="函数式接口-o"><a href="#函数式接口-o" class="headerlink" title="函数式接口 o"></a>函数式接口 o</h1><p>Java 函数式接口是在 java.util.function 包下定义的，用于支持函数式编程的特性。它提供了一系列的函数式接口，用于便捷地使用Lambda表达式和方法引用。<br>:::tips</p>
<ul>
<li>Consumer<T>：接受一个输入参数并且不返回结果的操作。</li>
<li>Supplier<T>：提供一个结果的供应商。</li>
<li>Function&lt;T, R&gt;：将一个类型的值转换为另一个类型的值。</li>
<li>Predicate<T>：对一个输入参数进行判断，并返回一个布尔值。<br>:::</li>
</ul>
<blockquote>
<p>1、概述</p>
</blockquote>
<ul>
<li>概念<br>有且仅有一个抽象方法的接口 </li>
<li>如何检测一个接口是不是函数式接口<br><a href="/FunctionalInterface">@FunctionalInterface </a><br>放在接口定义的上方：如果接口是函数式接口，编译通过；如果不是，编译失败 </li>
<li>注意事项 我们自己定义函数式接口的时候，@FunctionalInterface是可选的，就算我不写这个注解，只要保证满足函数式接口定义的条件，也照样是函数式接口。但是，建议加上该注解</li>
</ul>
<blockquote>
<p>2、函数式接口作为方法的参数</p>
</blockquote>
<ul>
<li>需求描述<br>定义一个类(RunnableDemo)，在类中提供两个方法<br>一个方法是：startThread(Runnable r) 方法参数Runnable是一个函数式接口<br>一个方法是主方法，在主方法中调用startThread方法 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//在主方法中调用startThread方法</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//匿名内部类的方式</span></span><br><span class="line">        startThread(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程启动了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Lambda方式</span></span><br><span class="line">        startThread(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程启动了&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">startThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>3、函数式接口作为方法的返回值</p>
</blockquote>
<ul>
<li><p>需求描述<br>定义一个类(ComparatorDemo)，在类中提供两个方法<br>一个方法是：Comparator getComparator() 方法返回值Comparator是一个函数式接口<br>一个方法是主方法，在主方法中调用getComparator方法 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComparatorDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义集合，存储字符串元素</span></span><br><span class="line">        ArrayList&lt;String&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        array.add(<span class="string">&quot;cccc&quot;</span>);</span><br><span class="line">        array.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        array.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        array.add(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前：&quot;</span> + array);</span><br><span class="line">        Collections.sort(array, getComparator());</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后：&quot;</span> + array);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparator&lt;String&gt; <span class="title function_">getComparator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//匿名内部类的方式实现</span></span><br><span class="line">        <span class="comment">// return new Comparator&lt;String&gt;() &#123;</span></span><br><span class="line">        <span class="comment">// @Override</span></span><br><span class="line">        <span class="comment">// public int compare(String s1, String s2) &#123;</span></span><br><span class="line">        <span class="comment">// return s1.length()-s2.length();</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// &#125;;</span></span><br><span class="line">        <span class="comment">//Lambda方式实现</span></span><br><span class="line">        <span class="keyword">return</span> (s1, s2) -&gt; s1.length() - s2.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>以下是常用的函数式接口</p>
</li>
</ul>
<h2 id="Supplier接口"><a href="#Supplier接口" class="headerlink" title="Supplier接口"></a>Supplier接口</h2><ul>
<li>Supplier接口<br>Supplier接口也被称为<strong>生产型接口</strong>，如果我们指定了接口的泛型是什么类型，那么接口中的get方法就会生产 什么类型的数据供我们使用。 </li>
<li>常用方法<br>只有一个无参的方法 <table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>T get()</td>
<td>按照某种实现逻辑(由Lambda表达式实现)返回一个数据</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SupplierDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> getString(() -&gt; <span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> getInteger(() -&gt; <span class="number">30</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一个方法，返回一个整数数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer <span class="title function_">getInteger</span><span class="params">(Supplier&lt;Integer&gt; sup)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sup.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一个方法，返回一个字符串数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getString</span><span class="params">(Supplier&lt;String&gt; sup)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sup.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Supplier接口练习之获取最大值</p>
</blockquote>
<ul>
<li>案例需求<br>定义一个类(SupplierTest)，在类中提供两个方法<br>一个方法是：int getMax(Supplier sup) 用于返回一个int数组中的最大值<br>一个方法是主方法，在主方法中调用getMax方法 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SupplierTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个int数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">19</span>, <span class="number">50</span>, <span class="number">28</span>, <span class="number">37</span>, <span class="number">46</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> getMax(()-&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] &gt; max) &#123;</span><br><span class="line">                    max = arr[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(maxValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回一个int数组中的最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(Supplier&lt;Integer&gt; sup)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sup.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Consumer接口"><a href="#Consumer接口" class="headerlink" title="Consumer接口"></a>Consumer接口</h2><ul>
<li>Consumer接口<br>Consumer接口也被称为<strong>消费型接口</strong>，它消费的数据的数据类型由泛型指定 </li>
<li>常用方法<br>Consumer：包含两个方法 <table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void accept(T t)</td>
<td>对给定的参数执行此操作</td>
</tr>
<tr>
<td>default Consumer andThen(Consumer after)</td>
<td>返回一个组合的Consumer，依次执行此操作，然后执行after操作</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//操作一</span></span><br><span class="line">        operatorString(<span class="string">&quot;林青霞&quot;</span>, s -&gt; System.out.println(s));</span><br><span class="line">        <span class="comment">//操作二</span></span><br><span class="line">        operatorString(<span class="string">&quot;林青霞&quot;</span>, s -&gt; System.out.println(<span class="keyword">new</span></span><br><span class="line">                                                      <span class="title class_">StringBuilder</span>(s).reverse().toString()));</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">        <span class="comment">//传入两个操作使用andThen完成</span></span><br><span class="line">        operatorString(<span class="string">&quot;林青霞&quot;</span>, s -&gt; System.out.println(s), s -&gt;</span><br><span class="line">                       System.out.println(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s).reverse().toString()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义一个方法，用不同的方式消费同一个字符串数据两次</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">operatorString</span><span class="params">(String name, Consumer&lt;String&gt; con1,</span></span><br><span class="line"><span class="params">                                       Consumer&lt;String&gt; con2)</span> &#123;</span><br><span class="line">        <span class="comment">// con1.accept(name);</span></span><br><span class="line">        <span class="comment">// con2.accept(name);</span></span><br><span class="line">        con1.andThen(con2).accept(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义一个方法，消费一个字符串数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">operatorString</span><span class="params">(String name, Consumer&lt;String&gt; con)</span> &#123;</span><br><span class="line">        con.accept(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Consumer接口练习之按要求打印信息</p>
</blockquote>
<ul>
<li>案例需求<br>String[] strArray &#x3D; {“林青霞,30”, “张曼玉,35”, “王祖贤,33”};<br>字符串数组中有多条信息，请按照格式：“姓名：XX,年龄：XX”的格式将信息打印出来 </li>
<li>要求： <ul>
<li>把打印姓名的动作作为第一个Consumer接口的Lambda实例</li>
<li>把打印年龄的动作作为第二个Consumer接口的Lambda实例</li>
<li>将两个Consumer接口按照顺序组合到一起使用<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] strArray = &#123;<span class="string">&quot;林青霞,30&quot;</span>, <span class="string">&quot;张曼玉,35&quot;</span>, <span class="string">&quot;王祖贤,33&quot;</span>&#125;;</span><br><span class="line">        printInfo(strArray, str -&gt; System.out.print(<span class="string">&quot;姓名：&quot;</span> + str.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>]),</span><br><span class="line">                  str -&gt; System.out.println(<span class="string">&quot;,年龄：&quot;</span> +</span><br><span class="line">                                            Integer.parseInt(str.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>])));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printInfo</span><span class="params">(String[] strArray, Consumer&lt;String&gt; con1,</span></span><br><span class="line"><span class="params">                                  Consumer&lt;String&gt; con2)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String str : strArray) &#123;</span><br><span class="line">            con1.andThen(con2).accept(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="Predicate接口"><a href="#Predicate接口" class="headerlink" title="Predicate接口"></a>Predicate接口</h2><ul>
<li>Predicate接口<br>Predicate接口通常用于判断参数是否满足指定的条件 </li>
<li>常用方法 <table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean test(T t)</td>
<td>对给定的参数进行判断(判断逻辑由Lambda表达式实现)，返回 一个布尔值</td>
</tr>
<tr>
<td>default Predicate negate()</td>
<td>返回一个逻辑的否定，对应逻辑非</td>
</tr>
<tr>
<td>default Predicate and(Predicate other)</td>
<td>返回一个组合判断，对应短路与</td>
</tr>
<tr>
<td>default Predicate or(Predicate other)</td>
<td>返回一个组合判断，对应短路或</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PredicateDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> checkString(<span class="string">&quot;hello&quot;</span>, s -&gt; s.length() &gt; <span class="number">8</span>);</span><br><span class="line">        System.out.println(b1);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> checkString(<span class="string">&quot;helloworld&quot;</span>,s -&gt; s.length() &gt; <span class="number">8</span>);</span><br><span class="line">        System.out.println(b2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断给定的字符串是否满足要求</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkString</span><span class="params">(String s, Predicate&lt;String&gt; pre)</span> &#123;</span><br><span class="line">        <span class="comment">// return !pre.test(s);</span></span><br><span class="line">        <span class="keyword">return</span> pre.negate().test(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PredicateDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> checkString(<span class="string">&quot;hello&quot;</span>, s -&gt; s.length() &gt; <span class="number">8</span>);</span><br><span class="line">        System.out.println(b1);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> checkString(<span class="string">&quot;helloworld&quot;</span>, s -&gt; s.length() &gt; <span class="number">8</span>);</span><br><span class="line">        System.out.println(b2);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b3</span> <span class="operator">=</span> checkString(<span class="string">&quot;hello&quot;</span>,s -&gt; s.length() &gt; <span class="number">8</span>, s -&gt; s.length() &lt;</span><br><span class="line">                                 <span class="number">15</span>);</span><br><span class="line">        System.out.println(b3);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b4</span> <span class="operator">=</span> checkString(<span class="string">&quot;helloworld&quot;</span>,s -&gt; s.length() &gt; <span class="number">8</span>, s -&gt; s.length()</span><br><span class="line">                                 &lt; <span class="number">15</span>);</span><br><span class="line">        System.out.println(b4);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同一个字符串给出两个不同的判断条件，最后把这两个判断的结果做逻辑与运算的结果作为最终的结果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkString</span><span class="params">(String s, Predicate&lt;String&gt; pre1,</span></span><br><span class="line"><span class="params">                                       Predicate&lt;String&gt; pre2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pre1.or(pre2).test(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断给定的字符串是否满足要求</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkString</span><span class="params">(String s, Predicate&lt;String&gt; pre)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pre.test(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Predicate接口练习之筛选满足条件数据</p>
</blockquote>
<ul>
<li>练习描述 <ul>
<li>String[] strArray &#x3D; {“林青霞,30”, “柳岩,34”, “张曼玉,35”, “貂蝉,31”, “王祖贤,33”};</li>
<li>字符串数组中有多条信息，请通过Predicate接口的拼装将符合要求的字符串筛选到集合ArrayList中，并遍历ArrayList集合</li>
<li>同时满足如下要求：姓名长度大于2；年龄大于33</li>
</ul>
</li>
<li>分析 <ul>
<li>有两个判断条件,所以需要使用两个Predicate接口,对条件进行判断</li>
<li>必须同时满足两个条件,所以可以使用and方法连接两个判断条件<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PredicateTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] strArray = &#123;<span class="string">&quot;林青霞,30&quot;</span>, <span class="string">&quot;柳岩,34&quot;</span>, <span class="string">&quot;张曼玉,35&quot;</span>, <span class="string">&quot;貂蝉,31&quot;</span>, <span class="string">&quot;王祖贤,33&quot;</span>&#125;;</span><br><span class="line">        ArrayList&lt;String&gt; array = myFilter(strArray, s -&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>].length()&gt;<span class="number">2</span>,s -&gt; Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]) &gt; <span class="number">33</span>);</span><br><span class="line">        <span class="keyword">for</span> (String str : array) &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过Predicate接口的拼装将符合要求的字符串筛选到集合ArrayList中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title function_">myFilter</span><span class="params">(String[] strArray, Predicate&lt;String&gt; pre1, Predicate&lt;String&gt; pre2)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个集合</span></span><br><span class="line">        ArrayList&lt;String&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (String str : strArray) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre1.and(pre2).test(str)) &#123;</span><br><span class="line">                array.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="Function接口"><a href="#Function接口" class="headerlink" title="Function接口"></a>Function接口</h2><ul>
<li>Function接口<br>Function接口通常用于对参数进行处理，转换(处理逻辑由Lambda表达式实现)，然后返回一个新的值 </li>
<li>常用方法 <table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>R apply(T t)</td>
<td>将此函数应用于给定的参数</td>
</tr>
<tr>
<td>default Function andThen(Function after)</td>
<td>返回一个组合函数，首先将该函数应用于输入，然后将after函数应用于结果</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//操作一</span></span><br><span class="line">        convert(<span class="string">&quot;100&quot;</span>,s -&gt; Integer.parseInt(s));</span><br><span class="line">        <span class="comment">//操作二</span></span><br><span class="line">        convert(<span class="number">100</span>,i -&gt; String.valueOf(i + <span class="number">566</span>));</span><br><span class="line">        <span class="comment">//使用andThen的方式连续执行两个操作</span></span><br><span class="line">        convert(<span class="string">&quot;100&quot;</span>, s -&gt; Integer.parseInt(s), i -&gt; String.valueOf(i + <span class="number">566</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一个方法，把一个字符串转换int类型，在控制台输出</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">convert</span><span class="params">(String s, Function&lt;String,Integer&gt; fun)</span> &#123;</span><br><span class="line">        <span class="comment">// Integer i = fun.apply(s);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> fun.apply(s);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一个方法，把一个int类型的数据加上一个整数之后，转为字符串在控制台输出</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">convert</span><span class="params">(<span class="type">int</span> i, Function&lt;Integer,String&gt; fun)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> fun.apply(i);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一个方法，把一个字符串转换int类型，把int类型的数据加上一个整数之后，转为字符串在控制台输出</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">convert</span><span class="params">(String s, Function&lt;String,Integer&gt; fun1,</span></span><br><span class="line"><span class="params">                                Function&lt;Integer,String&gt; fun2)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ss</span> <span class="operator">=</span> fun1.andThen(fun2).apply(s);</span><br><span class="line">        System.out.println(ss);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Function接口练习之按照指定要求操作数据</p>
</blockquote>
<ul>
<li>练习描述 <ul>
<li>String s &#x3D; “林青霞,30”; </li>
<li>请按照我指定的要求进行操作：<br>1:将字符串截取得到数字年龄部分<br>2:将上一步的年龄字符串转换成为int类型的数据<br>3:将上一步的int数据加70，得到一个int结果，在控制台输出 </li>
<li>请通过Function接口来实现函数拼接 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;林青霞,30&quot;</span>;</span><br><span class="line">        convert(s, ss -&gt; ss.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>], Integer::parseInt, i -&gt; i + <span class="number">70</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">convert</span><span class="params">(String s, Function&lt;String, String&gt; fun1,</span></span><br><span class="line"><span class="params">                                Function&lt;String, Integer&gt; fun2, Function&lt;Integer, Integer&gt; fun3)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> fun1.andThen(fun2).andThen(fun3).apply(s);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="Stream流-o"><a href="#Stream流-o" class="headerlink" title="Stream流 o"></a>Stream流 o</h1><p>:::tips</p>
<ul>
<li><p>现在有两个ArrayList集合，分别存储6名男演员名称和6名女演员名称，要求完成如下的操作 </p>
<ul>
<li>男演员只要名字为3个字的前三人</li>
<li>女演员只要姓林的，并且不要第一个</li>
<li>把过滤后的男演员姓名和女演员姓名合并到一起</li>
<li>把上一步操作后的元素作为构造方法的参数创建演员对象,遍历数据<br> :::<br> 演员类Actor已经提供，里面有一个成员变量，一个带参构造方法，以及成员变量对应的get&#x2F;set方法 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建集合</span></span><br><span class="line">ArrayList&lt;String&gt; manList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">manList.add(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">ArrayList&lt;String&gt; womanList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">womanList.add(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"></span><br><span class="line">Stream.concat(manList.stream()</span><br><span class="line">                  .filter(s -&gt; s.length() == <span class="number">3</span>)</span><br><span class="line">                  .limit(<span class="number">3</span>),</span><br><span class="line">              womanList.stream()</span><br><span class="line">                  .filter(s -&gt; s.startsWith(<span class="string">&quot;林&quot;</span>)).skip(<span class="number">1</span>))</span><br><span class="line">                  .map(Actor::<span class="keyword">new</span>)</span><br><span class="line">                  .forEach(p -&gt; System.out.println(p.getName()));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>案例需求<br>按照下面的要求完成集合的创建和遍历 </p>
<ul>
<li>创建一个集合，存储多个字符串元素</li>
<li>把集合中所有以”张”开头的元素存储到一个新的集合</li>
<li>把”张”开头的集合中的长度为3的元素存储到一个新的集合</li>
<li>遍历上一步得到的集合<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个集合，存储多个字符串元素</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张曼玉&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;王祖贤&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;柳岩&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张敏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//把集合中所有以&quot;张&quot;开头的元素存储到一个新的集合</span></span><br><span class="line">        ArrayList&lt;String&gt; zhangList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s : list) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.startsWith(<span class="string">&quot;张&quot;</span>)) &#123;</span><br><span class="line">                zhangList.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(zhangList);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//把&quot;张&quot;开头的集合中的长度为3的元素存储到一个新的集合</span></span><br><span class="line">        ArrayList&lt;String&gt; threeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s : zhangList) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.length() == <span class="number">3</span>) &#123;</span><br><span class="line">                threeList.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(threeList);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历上一步得到的集合</span></span><br><span class="line">        <span class="keyword">for</span>(String s : threeList) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个集合，存储多个字符串元素</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张曼玉&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;王祖贤&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;柳岩&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张敏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        <span class="comment">//Stream流来改进</span></span><br><span class="line">        list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).filter(s -&gt; s.length() ==</span><br><span class="line">                                                            <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Stream流的好处 </p>
<ul>
<li>直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：获取流、过滤姓张、过滤长度为3、逐一打印</li>
<li>Stream流把真正的函数式编程风格引入到Java中</li>
</ul>
</li>
</ul>
<h2 id="Stream流的常见生成方式"><a href="#Stream流的常见生成方式" class="headerlink" title="Stream流的常见生成方式"></a>Stream流的常见生成方式</h2><ul>
<li>Stream流的思想</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35382725/1697183013414-5ff5b073-aceb-4b0d-82f4-7a40ff3026cb.png#averageHue=%23c9d9ee&clientId=uc4f565ad-210d-4&id=qCJeJ&originHeight=185&originWidth=636&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2d4342cf-4ebc-4fae-aff8-15e83219987&title="></p>
<ul>
<li>生成Stream流的方式 <ul>
<li>Collection体系集合<br>使用默认方法stream()生成流， default Stream stream() </li>
<li>Map体系集合<br>把Map转成Set集合，间接的生成流 </li>
<li>数组<br>通过Stream接口的静态方法of(T… values)生成流 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//Collection体系的集合可以使用默认方法stream()生成流</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        Stream&lt;String&gt; listStream = list.stream();</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        Stream&lt;String&gt; setStream = set.stream();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Map体系的集合间接的生成流</span></span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line">        Stream&lt;String&gt; keyStream = map.keySet().stream();</span><br><span class="line">        Stream&lt;Integer&gt; valueStream = map.values().stream();</span><br><span class="line">        Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; entryStream = map.entrySet().stream();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//数组可以通过Stream接口的静态方法of(T... values)生成流</span></span><br><span class="line">        String[] strArray = &#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;java&quot;</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; strArrayStream = Stream.of(strArray);</span><br><span class="line">        Stream&lt;String&gt; strArrayStream2 = Stream.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;java&quot;</span>);</span><br><span class="line">        Stream&lt;Integer&gt; intStream = Stream.of(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="Stream流中间操作方法"><a href="#Stream流中间操作方法" class="headerlink" title="Stream流中间操作方法"></a>Stream流中间操作方法</h2><ul>
<li>概述<br>中间操作的意思是，执行完此方法之后，Stream流依然可以继续执行其他操作。 </li>
<li>常见方法 <table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Stream filter(Predicate predicate)</td>
<td>用于对流中的数据进行过滤</td>
</tr>
<tr>
<td>Stream limit(long maxSize)</td>
<td>返回此流中的元素组成的流，截取前指定参数个数的数据</td>
</tr>
<tr>
<td>Stream skip(long n)</td>
<td>跳过指定参数个数的数据，返回由该流的剩余元素组成的流</td>
</tr>
<tr>
<td>static Stream concat(Stream a, Stream b)</td>
<td>合并a和b两个流为一个流</td>
</tr>
<tr>
<td>Stream distinct()</td>
<td>返回由该流的不同元素（根据Object.equals(Object) ）组成的流</td>
</tr>
<tr>
<td>Stream sorted()</td>
<td>返回由此流的元素组成的流，根据自然顺序排序</td>
</tr>
<tr>
<td>Stream sorted(Comparator comparator)</td>
<td>返回由该流的元素组成的流，根据提供的Comparator进行排序</td>
</tr>
<tr>
<td>Stream map(Function mapper)</td>
<td>返回由给定函数应用于此流的元素的结果组成的流</td>
</tr>
<tr>
<td>IntStream mapToInt(ToIntFunction mapper)</td>
<td>返回一个IntStream其中包含将给定函数应用于此流的元素的结果</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个集合，存储多个字符串元素</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张曼玉&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;王祖贤&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;柳岩&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张敏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//需求1：把list集合中以张开头的元素在控制台输出</span></span><br><span class="line">        list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//需求2：把list集合中长度为3的元素在控制台输出</span></span><br><span class="line">        list.stream().filter(s -&gt; s.length() == <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//需求3：把list集合中以张开头的，长度为3的元素在控制台输出</span></span><br><span class="line">        list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).filter(s -&gt; s.length() ==</span><br><span class="line">                                                            <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个集合，存储多个字符串元素</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张曼玉&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;王祖贤&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;柳岩&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张敏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        <span class="comment">//需求1：取前3个数据在控制台输出</span></span><br><span class="line">        list.stream().limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">        <span class="comment">//需求2：跳过3个元素，把剩下的元素在控制台输出</span></span><br><span class="line">        list.stream().skip(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">        <span class="comment">//需求3：跳过2个元素，把剩下的元素中前2个在控制台输出</span></span><br><span class="line">        list.stream().skip(<span class="number">2</span>).limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个集合，存储多个字符串元素</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张曼玉&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;王祖贤&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;柳岩&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张敏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        <span class="comment">//需求1：取前4个数据组成一个流</span></span><br><span class="line">        Stream&lt;String&gt; s1 = list.stream().limit(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">//需求2：跳过2个数据组成一个流</span></span><br><span class="line">        Stream&lt;String&gt; s2 = list.stream().skip(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//需求3：合并需求1和需求2得到的流，并把结果在控制台输出</span></span><br><span class="line">        <span class="comment">// Stream.concat(s1,s2).forEach(System.out::println);</span></span><br><span class="line">        <span class="comment">//需求4：合并需求1和需求2得到的流，并把结果在控制台输出，要求字符串元素不能重复</span></span><br><span class="line">        Stream.concat(s1,s2).distinct().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个集合，存储多个字符串元素</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;linqingxia&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;zhangmanyu&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;wangzuxian&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;liuyan&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;zhangmin&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;zhangwuji&quot;</span>);</span><br><span class="line">        <span class="comment">//需求1：按照字母顺序把数据在控制台输出</span></span><br><span class="line">        <span class="comment">// list.stream().sorted().forEach(System.out::println);</span></span><br><span class="line">        <span class="comment">//需求2：按照字符串长度把数据在控制台输出</span></span><br><span class="line">        list.stream().sorted((s1,s2) -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> s1.length()-s2.length();</span><br><span class="line">            <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> num==<span class="number">0</span>?s1.compareTo(s2):num;</span><br><span class="line">            <span class="keyword">return</span> num2;</span><br><span class="line">        &#125;).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个集合，存储多个字符串元素</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;20&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;30&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;40&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;50&quot;</span>);</span><br><span class="line">        <span class="comment">//需求：将集合中的字符串数据转换为整数之后在控制台输出</span></span><br><span class="line">        <span class="comment">// list.stream().map(s -&gt; Integer.parseInt(s)).forEach(System.out::println);</span></span><br><span class="line">        <span class="comment">// list.stream().map(Integer::parseInt).forEach(System.out::println);</span></span><br><span class="line">        <span class="comment">// list.stream().mapToInt(Integer::parseInt).forEach(System.out::println);</span></span><br><span class="line">        <span class="comment">//int sum() 返回此流中元素的总和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> list.stream().mapToInt(Integer::parseInt).sum();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Stream流终结操作方法"><a href="#Stream流终结操作方法" class="headerlink" title="Stream流终结操作方法"></a>Stream流终结操作方法</h2><ul>
<li>概念<br>终结操作的意思是，执行完此方法之后，Stream流将不能再执行其他操作。 </li>
<li>常见方法 <table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void forEach(Consumer action)</td>
<td>对此流的每个元素执行操作</td>
</tr>
<tr>
<td>long count()</td>
<td>返回此流中的元素数</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个集合，存储多个字符串元素</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张曼玉&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;王祖贤&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;柳岩&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张敏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        <span class="comment">//需求1：把集合中的元素在控制台输出</span></span><br><span class="line">        <span class="comment">// list.stream().forEach(System.out::println);</span></span><br><span class="line">        <span class="comment">//需求2：统计集合中有几个以张开头的元素，并把统计结果在控制台输出</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Stream流的收集操作"><a href="#Stream流的收集操作" class="headerlink" title="Stream流的收集操作"></a>Stream流的收集操作</h2><ul>
<li><p>概念<br>对数据使用Stream流的方式操作完毕后，可以把流中的数据收集到集合中。 </p>
</li>
<li><p>常见方法 </p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>R collect(Collector collector)</td>
<td>把结果收集到集合中</td>
</tr>
</tbody></table>
</li>
<li><p>工具类Collectors提供了具体的收集方式</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static Collector toList()</td>
<td>把元素收集到List集合中</td>
</tr>
<tr>
<td>public static Collector toSet()</td>
<td>把元素收集到Set集合中</td>
</tr>
<tr>
<td>public static Collector toMap(Function keyMapper,Function valueMapper)</td>
<td>把元素收集到Map集合中</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建List集合对象</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张曼玉&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;王祖贤&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;柳岩&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //需求1：得到名字为3个字的流</span></span><br><span class="line"><span class="comment">        Stream&lt;String&gt; listStream = list.stream().filter(s -&gt; s.length() == 3);</span></span><br><span class="line"><span class="comment">        //需求2：把使用Stream流操作完毕的数据收集到List集合中并遍历</span></span><br><span class="line"><span class="comment">        List&lt;String&gt; names = listStream.collect(Collectors.toList());</span></span><br><span class="line"><span class="comment">        for(String name : names) &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(name);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//创建Set集合对象</span></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        set.add(<span class="number">10</span>);</span><br><span class="line">        set.add(<span class="number">20</span>);</span><br><span class="line">        set.add(<span class="number">30</span>);</span><br><span class="line">        set.add(<span class="number">33</span>);</span><br><span class="line">        set.add(<span class="number">35</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //需求3：得到年龄大于25的流</span></span><br><span class="line"><span class="comment">        Stream&lt;Integer&gt; setStream = set.stream().filter(age -&gt; age &gt; 25);</span></span><br><span class="line"><span class="comment">        //需求4：把使用Stream流操作完毕的数据收集到Set集合中并遍历</span></span><br><span class="line"><span class="comment">        Set&lt;Integer&gt; ages = setStream.collect(Collectors.toSet());</span></span><br><span class="line"><span class="comment">        for(Integer age : ages) &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(age);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//定义一个字符串数组，每一个字符串数据由姓名数据和年龄数据组合而成</span></span><br><span class="line">        String[] strArray = &#123;<span class="string">&quot;林青霞,30&quot;</span>, <span class="string">&quot;张曼玉,35&quot;</span>, <span class="string">&quot;王祖贤,33&quot;</span>, <span class="string">&quot;柳岩,25&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//需求5：得到字符串中年龄数据大于28的流</span></span><br><span class="line">        Stream&lt;String&gt; arrayStream = Stream.of(strArray).filter(s -&gt;</span><br><span class="line">                                                                Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]) &gt; <span class="number">28</span>);</span><br><span class="line">        <span class="comment">//需求6：把使用Stream流操作完毕的数据收集到Map集合中并遍历，字符串中的姓名作键，年龄作值</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = arrayStream.collect(Collectors.toMap(s -&gt;</span><br><span class="line">                                                                        s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>], s -&gt; Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>])));</span><br><span class="line">        Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;,&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">cocochimp</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/01/18/Java%E5%9F%BA%E7%A1%80:%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/">http://example.com/2024/01/18/Java基础:高级特性/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">cocochimpBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/Java%E5%9F%BA%E7%A1%80.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/18/Java%E9%9B%86%E5%90%88/" title="Java集合"><img class="cover" src="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/Java%E9%9B%86%E5%90%88.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java集合</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/18/Redis/" title="Redis"><img class="cover" src="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/redis.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Redis</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/01/18/Java%E9%9B%86%E5%90%88/" title="Java集合"><img class="cover" src="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/Java%E9%9B%86%E5%90%88.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-18</div><div class="title">Java集合</div></div></a></div><div><a href="/2024/01/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="Java多线程"><img class="cover" src="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-18</div><div class="title">Java多线程</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">cocochimp</div><div class="author-info__description">to be a cool man!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/cocochimp" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://gitee.com/cocochimp" target="_blank" title="Gitee"><i class="fab fa-github-alt"></i></a><a class="social-icon" href="https://blog.csdn.net/m0_51634403" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="mailto:2427886409@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">1、基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E2%AD%90"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 基本数据类型 ⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E6%8E%A5%E5%8F%A3-%E2%AD%90"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 抽象类 &#x2F; 接口 ⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 权限修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-final-static"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 final &#x2F; static</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 可变参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE"><span class="toc-number">1.6.</span> <span class="toc-text">1.6 对象内存图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">2、面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%B0%81%E8%A3%85"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E7%BB%A7%E6%89%BF"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%A4%9A%E6%80%81"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 多态</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E3%80%81%E5%B8%B8%E7%94%A8API"><span class="toc-number">3.</span> <span class="toc-text">3、常用API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-String%E7%B1%BB-%E2%AD%90"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 String类 ⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-StringBuilder%E7%B1%BB-%E2%AD%90"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 StringBuilder类 ⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Math-System%E7%B1%BB"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 Math &#x2F; System类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 包装类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-Date-Calender%E7%B1%BB"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 Date &#x2F; Calender类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E3%80%81%E6%B3%9B%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">4、泛型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E3%80%81%E5%BC%82%E5%B8%B8-%E2%AD%90"><span class="toc-number">5.</span> <span class="toc-text">5、异常 ⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-throw-throws"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 throw&#x2F;throws</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 自定义异常</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E3%80%81%E5%8F%8D%E5%B0%84-%E2%AD%90"><span class="toc-number">6.</span> <span class="toc-text">6、反射 ⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E8%8E%B7%E5%8F%96Class%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 获取Class类对象的三种方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-Class%E7%B1%BB%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 Class类反射获取属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E5%8F%8D%E5%B0%84%E6%A1%88%E4%BE%8B"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 反射案例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-%E2%AD%90-o"><span class="toc-number">7.</span> <span class="toc-text">7、类加载器 ⭐ o</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">7.1.</span> <span class="toc-text">类加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">7.2.</span> <span class="toc-text">类加载器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-o"><span class="toc-number">8.</span> <span class="toc-text">Lambda表达式 o</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E7%BB%83%E4%B9%A0"><span class="toc-number">8.1.</span> <span class="toc-text">Lambda练习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%81%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">8.2.</span> <span class="toc-text">省略模式和注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8-o"><span class="toc-number">9.</span> <span class="toc-text">方法引用 o</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">9.1.</span> <span class="toc-text">引用类方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">9.2.</span> <span class="toc-text">引用对象的实例方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">9.3.</span> <span class="toc-text">引用类的实例方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">9.4.</span> <span class="toc-text">引用构造器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3-o"><span class="toc-number">10.</span> <span class="toc-text">函数式接口 o</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Supplier%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.1.</span> <span class="toc-text">Supplier接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Consumer%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.2.</span> <span class="toc-text">Consumer接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Predicate%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.3.</span> <span class="toc-text">Predicate接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Function%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.4.</span> <span class="toc-text">Function接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Stream%E6%B5%81-o"><span class="toc-number">11.</span> <span class="toc-text">Stream流 o</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Stream%E6%B5%81%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F"><span class="toc-number">11.1.</span> <span class="toc-text">Stream流的常见生成方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stream%E6%B5%81%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-number">11.2.</span> <span class="toc-text">Stream流中间操作方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stream%E6%B5%81%E7%BB%88%E7%BB%93%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-number">11.3.</span> <span class="toc-text">Stream流终结操作方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stream%E6%B5%81%E7%9A%84%E6%94%B6%E9%9B%86%E6%93%8D%E4%BD%9C"><span class="toc-number">11.4.</span> <span class="toc-text">Stream流的收集操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text"></span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/18/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="23种设计模式"><img src="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="23种设计模式"/></a><div class="content"><a class="title" href="/2024/01/18/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="23种设计模式">23种设计模式</a><time datetime="2024-01-18T03:00:54.577Z" title="发表于 2024-01-18 11:00:54">2024-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/18/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="JUC并发编程"><img src="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/juc.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC并发编程"/></a><div class="content"><a class="title" href="/2024/01/18/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="JUC并发编程">JUC并发编程</a><time datetime="2024-01-18T03:00:43.042Z" title="发表于 2024-01-18 11:00:43">2024-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/18/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="JVM虚拟机"><img src="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/JVM.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM虚拟机"/></a><div class="content"><a class="title" href="/2024/01/18/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="JVM虚拟机">JVM虚拟机</a><time datetime="2024-01-18T03:00:28.866Z" title="发表于 2024-01-18 11:00:28">2024-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="Java多线程"><img src="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java多线程"/></a><div class="content"><a class="title" href="/2024/01/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="Java多线程">Java多线程</a><time datetime="2024-01-18T03:00:10.504Z" title="发表于 2024-01-18 11:00:10">2024-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/18/Java%E9%9B%86%E5%90%88/" title="Java集合"><img src="https://pet-diary.oss-cn-beijing.aliyuncs.com/2023-12/Java%E9%9B%86%E5%90%88.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java集合"/></a><div class="content"><a class="title" href="/2024/01/18/Java%E9%9B%86%E5%90%88/" title="Java集合">Java集合</a><time datetime="2024-01-18T02:59:47.232Z" title="发表于 2024-01-18 10:59:47">2024-01-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By cocochimp</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div></body></html>